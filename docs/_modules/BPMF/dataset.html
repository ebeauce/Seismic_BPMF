<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BPMF.dataset &mdash; BPMF 2.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script src="../../_static/documentation_options.js?v=51b770b3"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            BPMF
              <img src="../../_static/bpmf.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../updates.html">Updates</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BPMF</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">BPMF.dataset</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for BPMF.dataset</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">h5py</span> <span class="k">as</span> <span class="nn">h5</span>

<span class="kn">from</span> <span class="nn">.config</span> <span class="kn">import</span> <span class="n">cfg</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span>

<span class="kn">import</span> <span class="nn">obspy</span> <span class="k">as</span> <span class="nn">obs</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">UTCDateTime</span> <span class="k">as</span> <span class="n">udt</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span> <span class="k">as</span> <span class="n">give_time</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>


<div class="viewcode-block" id="Network">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network">[docs]</a>
<span class="k">class</span> <span class="nc">Network</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Station metadata.</span>

<span class="sd">    Contains station metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network_file</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        network_file: string</span>
<span class="sd">            Name of the station metadata file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NETWORK_PATH</span><span class="p">,</span> <span class="n">network_file</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;stations&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">station_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">networks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;networks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">latitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">longitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;depth_km&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elevation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;elevation_m&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Network.box">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network.box">[docs]</a>
    <span class="k">def</span> <span class="nf">box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat_min</span><span class="p">,</span> <span class="n">lat_max</span><span class="p">,</span> <span class="n">lon_min</span><span class="p">,</span> <span class="n">lon_max</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Geographical selection of sub-network.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        lat_min: scalar, float</span>
<span class="sd">            Minimum latitude of the box.</span>
<span class="sd">        lat_max: scalar, float</span>
<span class="sd">            Maximum latitude of the box.</span>
<span class="sd">        lon_min: scalar, float</span>
<span class="sd">            Minimum longitude of the box.</span>
<span class="sd">        lon_max: scalar, float</span>
<span class="sd">            Maximum longitude of the box.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------------</span>
<span class="sd">        subnet: Network instance</span>
<span class="sd">            The Network instance restricted to the relevant stations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">&gt;</span> <span class="n">lat_min</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">&lt;</span> <span class="n">lat_max</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span> <span class="o">&gt;</span> <span class="n">lon_min</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span> <span class="o">&lt;</span> <span class="n">lon_max</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">new_stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">[</span><span class="n">selection</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="n">subnet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="n">new_stations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;keep&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subnet</span></div>


<div class="viewcode-block" id="Network.datelist">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network.datelist">[docs]</a>
    <span class="k">def</span> <span class="nf">datelist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_date</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_date</span><span class="p">))</span></div>


<div class="viewcode-block" id="Network.read">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network.read">[docs]</a>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the metadata from the file at self.where</span>

<span class="sd">        Note: This function can be modified to match the user&#39;s</span>
<span class="sd">        data convention.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fin</span><span class="p">:</span>
            <span class="n">line1</span> <span class="o">=</span> <span class="n">fin</span><span class="o">.</span><span class="n">readline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_date</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">line1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">end_date</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">line1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">line2</span> <span class="o">=</span> <span class="n">fin</span><span class="o">.</span><span class="n">readline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">line2</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;station_code&quot;</span><span class="p">:</span> <span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="s2">&quot;network_code&quot;</span><span class="p">:</span> <span class="s2">&quot;networks&quot;</span><span class="p">},</span>
            <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;depth_km&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;elevation_m&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1000.0</span>  <span class="c1"># depth in km</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Network.stations_idx">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network.stations_idx">[docs]</a>
    <span class="k">def</span> <span class="nf">stations_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stations</span><span class="p">):</span>
        <span class="c1"># if not isinstance(stations, list) and not isinstance(stations, np.ndarray):</span>
        <span class="c1">#    stations = [stations]</span>
        <span class="c1"># idx = []</span>
        <span class="c1"># for station in stations:</span>
        <span class="c1">#    idx.append(self.stations.index(station))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">station_indexes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">stations</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">idx</span></div>


<div class="viewcode-block" id="Network.subset">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network.subset">[docs]</a>
    <span class="k">def</span> <span class="nf">subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;keep&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        stations: list or array of strings</span>
<span class="sd">            Stations to keep or discard, depending on the method.</span>
<span class="sd">        components: list or array of strings</span>
<span class="sd">            Components to keep or discard, depending on the method.</span>
<span class="sd">        method: string, default to &#39;keep&#39;</span>
<span class="sd">            Should be &#39;keep&#39; or &#39;discard&#39;.</span>
<span class="sd">            If &#39;keep&#39;, the stations and components provided to</span>
<span class="sd">            this function are what will be left in the subnetwork.</span>
<span class="sd">            If &#39;discard&#39;, the stations and components provided to</span>
<span class="sd">            this function are what won&#39;t be featured in the</span>
<span class="sd">            subnetwork.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        subnetwork</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">subnetwork</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="n">stations</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="p">[</span><span class="n">stations</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">components</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">components</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;discard&quot;</span><span class="p">:</span>
            <span class="n">subnetwork</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;rows&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">subnetwork</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
                    <span class="n">subnetwork</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> not a network component&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">station</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;keep&quot;</span><span class="p">:</span>
            <span class="n">subnetwork</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">subnetwork</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">stations</span><span class="p">]</span>
            <span class="n">subnetwork</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">components</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;method should be &quot;keep&quot; or &quot;discard&quot;!&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="n">subnetwork</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interstation_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the distance between all station pairs.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DataFrame: A pandas DataFrame containing the interstation distances.</span>
<span class="sd">                       The rows and columns represent the station names, and the</span>
<span class="sd">                       values represent the distances in kilometers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># should update code to reuse utils.compute_distamces</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_interstation_distances&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interstation_distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stations</span>
        <span class="p">):</span>
            <span class="c1"># was already computed and the size of the network was unchanged</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interstation_distances</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">cartopy.geodesic</span> <span class="kn">import</span> <span class="n">Geodesic</span>

            <span class="n">G</span> <span class="o">=</span> <span class="n">Geodesic</span><span class="p">()</span>

            <span class="n">intersta_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">)):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">[</span><span class="n">s</span><span class="p">]]]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="c1"># d is in m, convert it to km</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1000.0</span>
                <span class="n">intersta_dist</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="p">)</span>

            <span class="c1"># return distance in km</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interstation_distances</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">intersta_dist</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interstation_distances</span>

    <span class="c1"># plotting method</span>
<div class="viewcode-block" id="Network.plot_map">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network.plot_map">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot stations on map.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        ax: `plt.Axes`, default to None</span>
<span class="sd">            If None, create a new `plt.Figure` and `plt.Axes` instances. If</span>
<span class="sd">            speficied by user, use the provided instance to plot.</span>
<span class="sd">        figsize: tuple of floats, default to (20, 10)</span>
<span class="sd">            Size, in inches, of the figure (width, height).</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        fig: `plt.Figure`</span>
<span class="sd">            The map with seismic stations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">plotting_utils</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">cartopy.crs</span> <span class="kn">import</span> <span class="n">PlateCarree</span>

        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cmap&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">colorcet</span> <span class="k">as</span> <span class="nn">cc</span>

                <span class="n">cmap</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">fire_r</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">cmap</span> <span class="o">=</span> <span class="s2">&quot;hot_r&quot;</span>
        <span class="n">data_coords</span> <span class="o">=</span> <span class="n">PlateCarree</span><span class="p">()</span>
        <span class="n">lat_margin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lat_margin&quot;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="n">lon_margin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lon_margin&quot;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="c1"># ------------------------------------------------</span>
        <span class="c1">#           Scattering plot kwargs</span>
        <span class="n">scatter_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;linewidths&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;linewidths&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;zorder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zorder&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># ------------------------------------------------</span>
        <span class="n">map_longitudes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span> <span class="o">-</span> <span class="n">lon_margin</span><span class="p">,</span>
            <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span> <span class="o">+</span> <span class="n">lon_margin</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">map_latitudes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span> <span class="o">-</span> <span class="n">lat_margin</span><span class="p">,</span>
            <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span> <span class="o">+</span> <span class="n">lat_margin</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">seismic_stations</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;longitude&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
            <span class="s2">&quot;latitude&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
            <span class="s2">&quot;stations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plotting_utils</span><span class="o">.</span><span class="n">initialize_map</span><span class="p">(</span>
            <span class="n">map_longitudes</span><span class="p">,</span>
            <span class="n">map_latitudes</span><span class="p">,</span>
            <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
            <span class="n">map_axis</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">seismic_stations</span><span class="o">=</span><span class="n">seismic_stations</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="Catalog">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog">[docs]</a>
<span class="k">class</span> <span class="nc">Catalog</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class for catalog data, and basic plotting.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">depths</span><span class="p">,</span> <span class="n">origin_times</span><span class="p">,</span> <span class="n">event_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a catalog attribute as a pandas.DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        longitudes: List or numpy.ndarray of floats</span>
<span class="sd">            Event longitudes.</span>
<span class="sd">        latitudes: List or numpy.ndarray of floats</span>
<span class="sd">            Event latitudes.</span>
<span class="sd">        depths: List or numpy.ndarray of floats</span>
<span class="sd">            Event depths.</span>
<span class="sd">        origin_times: List or numpy.ndarray of strings or datetimes</span>
<span class="sd">            Event origin times.</span>
<span class="sd">        event_ids: List or numpy.ndarray, default to None</span>
<span class="sd">            If not None, is used to define named indexes of the rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">catalog</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">longitudes</span>
        <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">latitudes</span>
        <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">depths</span>
        <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">origin_times</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;datetime64[ms]&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">catalog</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">event_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;event_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">event_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">catalog</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">event_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;event_id&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;origin_time&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">latitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">longitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">origin_time</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">)</span>

<div class="viewcode-block" id="Catalog.concatenate">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.concatenate">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">catalogs</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build catalog from list of `pandas.DataFrame`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        catalogs: list of `pandas.DataFrame`</span>
<span class="sd">            List of `pandas.DataFrame` with consistent columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">catalogs</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="n">ignore_index</span><span class="p">)</span>
        <span class="n">cat</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;origin_time&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="s2">&quot;origin_time&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">cat</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
            <span class="n">cat</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
            <span class="n">cat</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span>
            <span class="n">cat</span><span class="o">.</span><span class="n">origin_time</span><span class="p">,</span>
            <span class="o">**</span><span class="n">cat</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">base</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Catalog.read_from_events">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.read_from_events">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_events</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">extra_attributes</span><span class="o">=</span><span class="p">[],</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build catalog from list of `Event` instances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        events : list</span>
<span class="sd">            List of `Event` instances.</span>
<span class="sd">        extra_attributes : list, optional</span>
<span class="sd">            Default attributes included in the catalog are: longitude,</span>
<span class="sd">            latitude, depth and origin time. Any extra attribute that</span>
<span class="sd">            should be returned in the catalog should be given here as</span>
<span class="sd">            a string in a list.</span>
<span class="sd">            Example: `extra_attributes=[&#39;hmax_inc&#39;, &#39;vmax_inc&#39;]`</span>
<span class="sd">        fill_value : any, optional</span>
<span class="sd">            Value that is returned in the catalog if an attribute</span>
<span class="sd">            from `extra_attributes` is not found. Default is `numpy.nan`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        catalog : `Catalog`</span>
<span class="sd">            `Catalog` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">depths</span><span class="p">,</span> <span class="n">origin_times</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">event_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">extra_attr</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># initialize empty lists for extra requested attributes</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">extra_attributes</span><span class="p">:</span>
            <span class="n">extra_attr</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">longitudes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span>
            <span class="n">latitudes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>
            <span class="n">depths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">depth</span><span class="p">)</span>
            <span class="n">origin_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">origin_time</span><span class="p">))</span>
            <span class="n">event_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">extra_attributes</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                    <span class="n">extra_attr</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">event</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
                    <span class="c1"># check if attribute is in aux_data</span>
                    <span class="n">extra_attr</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># attribute was not found, fill with default value</span>
                    <span class="n">extra_attr</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">longitudes</span><span class="p">,</span>
            <span class="n">latitudes</span><span class="p">,</span>
            <span class="n">depths</span><span class="p">,</span>
            <span class="n">origin_times</span><span class="p">,</span>
            <span class="n">event_ids</span><span class="o">=</span><span class="n">event_ids</span><span class="p">,</span>
            <span class="o">**</span><span class="n">extra_attr</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Catalog.read_from_dataframe">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.read_from_dataframe">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_dataframe</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a Catalog instance from a `pandas.DataFrame` instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataframe : `pandas.DataFrame`</span>
<span class="sd">            `pandas.DataFrame` from which the `Catalog` instance will</span>
<span class="sd">            be built.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        catalog : `Catalog`</span>
<span class="sd">            `Catalog` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">catalog</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">],</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">],</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">],</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">],</span>
            <span class="o">**</span><span class="n">dataframe</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="s2">&quot;origin_time&quot;</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">catalog</span></div>


<div class="viewcode-block" id="Catalog.read_from_detection_file">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.read_from_detection_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_detection_file</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">OUTPUT_PATH</span><span class="p">,</span>
        <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_attributes</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">return_events</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read all detected events and build catalog.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : string</span>
<span class="sd">            Name of the hdf5 file with the event data base.</span>
<span class="sd">        db_path : string, optional</span>
<span class="sd">            Name of the directory where `filename` is located.</span>
<span class="sd">            Default is `config.OUTPUT_PATH`.</span>
<span class="sd">        gid : string or float or int, optional</span>
<span class="sd">            Name of the group to read within the hdf5 file. If</span>
<span class="sd">            None (default), reads all the groups in the root</span>
<span class="sd">            directory of the hdf5 file.</span>
<span class="sd">        extra_attributes : list, optional</span>
<span class="sd">            Default attributes included in the catalog are: longitude,</span>
<span class="sd">            latitude, depth and origin time. Any extra attribute that</span>
<span class="sd">            should be returned in the catalog should be given here as</span>
<span class="sd">            a string in a list.</span>
<span class="sd">            Example: `extra_attributes=[&#39;hmax_inc&#39;, &#39;vmax_inc&#39;]`</span>
<span class="sd">        fill_value : any, optional</span>
<span class="sd">            Value that is returned in the catalog if an attribute</span>
<span class="sd">            from `extra_attributes` is not found. Default is `numpy.nan`.</span>
<span class="sd">        return_events : boolean, optional</span>
<span class="sd">            If True, returns the list of `Event` instances in addition to</span>
<span class="sd">            the `Catalog` instance. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        catalog : `Catalog`</span>
<span class="sd">            `Catalog` instance.</span>
<span class="sd">        events : list, optional</span>
<span class="sd">            List of `Event` instances of `return_events=True`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">gid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Event</span><span class="o">.</span><span class="n">read_from_file</span><span class="p">(</span><span class="n">hdf5_file</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Error while trying to read the detected events &quot;</span>
                <span class="s2">&quot;(perhaps there are none).&quot;</span>
            <span class="p">)</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="n">return_events</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">read_from_events</span><span class="p">(</span>
                    <span class="n">events</span><span class="p">,</span> <span class="n">extra_attributes</span><span class="o">=</span><span class="n">extra_attributes</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
                <span class="p">),</span>
                <span class="n">events</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">read_from_events</span><span class="p">(</span>
                <span class="n">events</span><span class="p">,</span> <span class="n">extra_attributes</span><span class="o">=</span><span class="n">extra_attributes</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
            <span class="p">)</span></div>


    <span class="c1"># ---------------------------------------------------------</span>
    <span class="c1">#                  Plotting methods</span>
    <span class="c1"># ---------------------------------------------------------</span>
<div class="viewcode-block" id="Catalog.plot_time_statistics">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.plot_time_statistics">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_time_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">UTC_local_corr</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the histograms of time of the day and day of the week.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        figsize : tuple of floats, optional</span>
<span class="sd">            Size, in inches, of the figure (width, height). Default is (16, 7).</span>
<span class="sd">        UTC_local_corr : float, optional</span>
<span class="sd">            Apply UTC to local time correction such that:</span>
<span class="sd">                `local_hour = UTC_hour + UTC_local_corr`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.figure.Figure</span>
<span class="sd">            The created matplotlib Figure object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span>
            <span class="n">num</span><span class="o">=</span><span class="s2">&quot;time_statistics&quot;</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">dayofweek</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="s2">&quot;Mon&quot;</span><span class="p">,</span> <span class="s2">&quot;Tues&quot;</span><span class="p">,</span> <span class="s2">&quot;Wed&quot;</span><span class="p">,</span> <span class="s2">&quot;Thurs&quot;</span><span class="p">,</span> <span class="s2">&quot;Fri&quot;</span><span class="p">,</span> <span class="s2">&quot;Sat&quot;</span><span class="p">,</span> <span class="s2">&quot;Sun&quot;</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Day of the Week&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Event Count&quot;</span><span class="p">)</span>

        <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">hour</span> <span class="o">+</span> <span class="n">UTC_local_corr</span><span class="p">)</span> <span class="o">%</span> <span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span>
            <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Hour of the Day&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Event Count&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="Catalog.plot_map">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.plot_map">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
        <span class="n">depth_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">depth_max</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span>
        <span class="n">network</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_uncertainties</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">depth_colorbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot epicenters on map.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        ax : matplotlib.pyplot.Axes, default to None</span>
<span class="sd">            If None, create a new `plt.Figure` and `plt.Axes` instances. If</span>
<span class="sd">            speficied by user, use the provided instance to plot.</span>
<span class="sd">        figsize : tuple of floats, default to (20, 10)</span>
<span class="sd">            Size, in inches, of the figure (width, height).</span>
<span class="sd">        depth_min : scalar float, default to 0</span>
<span class="sd">            Smallest depth, in km, in the depth colormap.</span>
<span class="sd">        depth_max : scalar float, default to 20</span>
<span class="sd">            Largest depth, in km, in the depth colormap.</span>
<span class="sd">        network : BPMF.dataset.Network, optional</span>
<span class="sd">            If provided, use information in `network` to plot the stations.</span>
<span class="sd">        plot_uncertainties : boolean, default to False</span>
<span class="sd">            If True, plot the location uncertainty ellipses.</span>
<span class="sd">        depth_colorbar : boolean, default to True</span>
<span class="sd">            If True, plot the depth colorbar on the left.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        fig : matplotlib.pyplot.Figure</span>
<span class="sd">            The figure with depth color-coded epicenters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">plotting_utils</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">Normalize</span>
        <span class="kn">from</span> <span class="nn">matplotlib.cm</span> <span class="kn">import</span> <span class="n">ScalarMappable</span>
        <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
        <span class="kn">from</span> <span class="nn">cartopy.crs</span> <span class="kn">import</span> <span class="n">PlateCarree</span>

        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cmap&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">colorcet</span> <span class="k">as</span> <span class="nn">cc</span>

                <span class="n">cmap</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">fire_r</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">cmap</span> <span class="o">=</span> <span class="s2">&quot;hot_r&quot;</span>
        <span class="n">data_coords</span> <span class="o">=</span> <span class="n">PlateCarree</span><span class="p">()</span>
        <span class="n">lat_margin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lat_margin&quot;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="n">lon_margin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lon_margin&quot;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="c1"># ------------------------------------------------</span>
        <span class="c1">#           Scattering plot kwargs</span>
        <span class="n">scatter_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;linewidths&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;linewidths&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;zorder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zorder&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># ------------------------------------------------</span>
        <span class="k">if</span> <span class="n">network</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">map_longitudes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span> <span class="o">-</span> <span class="n">lon_margin</span><span class="p">,</span>
                <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span> <span class="o">+</span> <span class="n">lon_margin</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">map_latitudes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span> <span class="o">-</span> <span class="n">lat_margin</span><span class="p">,</span>
                <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span> <span class="o">+</span> <span class="n">lat_margin</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">map_longitudes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">network</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">-</span> <span class="n">lon_margin</span><span class="p">,</span>
                <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">network</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">+</span> <span class="n">lon_margin</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">map_latitudes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">network</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">-</span> <span class="n">lat_margin</span><span class="p">,</span>
                <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">network</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">+</span> <span class="n">lat_margin</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="c1"># overwrite map extent if given</span>
        <span class="n">map_longitudes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lon_min&quot;</span><span class="p">,</span> <span class="n">map_longitudes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">map_longitudes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lon_max&quot;</span><span class="p">,</span> <span class="n">map_longitudes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">map_latitudes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lat_min&quot;</span><span class="p">,</span> <span class="n">map_latitudes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">map_latitudes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lat_max&quot;</span><span class="p">,</span> <span class="n">map_latitudes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plotting_utils</span><span class="o">.</span><span class="n">initialize_map</span><span class="p">(</span>
            <span class="n">map_longitudes</span><span class="p">,</span> <span class="n">map_latitudes</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="n">map_axis</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="c1"># plot epicenters</span>
        <span class="n">cNorm</span> <span class="o">=</span> <span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">depth_min</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">depth_max</span><span class="p">)</span>
        <span class="n">scalar_map</span> <span class="o">=</span> <span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
            <span class="n">c</span><span class="o">=</span><span class="n">scalar_map</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">),</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Earthquakes&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">scatter_kwargs</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">data_coords</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_uncertainties</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="s2">&quot;hmax_unc&quot;</span> <span class="ow">in</span> <span class="n">columns</span>
                <span class="ow">and</span> <span class="s2">&quot;hmin_unc&quot;</span> <span class="ow">in</span> <span class="n">columns</span>
                <span class="ow">and</span> <span class="s2">&quot;az_hmax_unc&quot;</span> <span class="ow">in</span> <span class="n">columns</span>
            <span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">)):</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="p">(</span>
                        <span class="n">longitude_ellipse</span><span class="p">,</span>
                        <span class="n">latitude_ellipse</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="n">plotting_utils</span><span class="o">.</span><span class="n">uncertainty_ellipse</span><span class="p">(</span>
                        <span class="n">row</span><span class="o">.</span><span class="n">hmax_unc</span><span class="p">,</span>
                        <span class="n">row</span><span class="o">.</span><span class="n">hmin_unc</span><span class="p">,</span>
                        <span class="n">row</span><span class="o">.</span><span class="n">az_hmax_unc</span><span class="p">,</span>
                        <span class="n">row</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
                        <span class="n">row</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">scalar_map</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">color</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">):</span>
                        <span class="c1"># white!</span>
                        <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;dimgrey&quot;</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">longitude_ellipse</span><span class="p">,</span>
                        <span class="n">latitude_ellipse</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                        <span class="n">transform</span><span class="o">=</span><span class="n">data_coords</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;If you want to plot the uncertainty ellipses,&quot;</span>
                    <span class="s2">&quot; self.catalog needs the following columns: &quot;</span>
                    <span class="s2">&quot;hmax_unc, hmin_unc, az_hmax_unc&quot;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">network</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="n">network</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
                <span class="n">network</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
                <span class="n">c</span><span class="o">=</span><span class="s2">&quot;magenta&quot;</span><span class="p">,</span>
                <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;v&quot;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Seismic stations&quot;</span><span class="p">,</span>
                <span class="n">s</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;markersize_station&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                <span class="n">transform</span><span class="o">=</span><span class="n">data_coords</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower right&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">depth_colorbar</span><span class="p">:</span>
            <span class="n">ax_divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">cax</span> <span class="o">=</span> <span class="n">ax_divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span>
                <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;2%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span> <span class="n">axes_class</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">Axes</span>
            <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scalar_map</span><span class="p">,</span> <span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Depth (km)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span></div>


<div class="viewcode-block" id="Catalog.plot_space_time">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.plot_space_time">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_space_time</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
        <span class="n">color_coded</span><span class="o">=</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span>
        <span class="n">y_axis</span><span class="o">=</span><span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the space-time event distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        ax: `plt.Axes`, default to None</span>
<span class="sd">            If None, create a new `plt.Figure` and `plt.Axes` instances. If</span>
<span class="sd">            speficied by user, use the provided instance to plot.</span>
<span class="sd">        figsize: tuple of floats, default to (20, 10)</span>
<span class="sd">            Size, in inches, of the figure (width, height).</span>
<span class="sd">        color_coded: string, default to &#39;longitude&#39;</span>
<span class="sd">            Can be either &#39;longitude&#39;, &#39;latitude&#39;, or &#39;depth&#39;. This is the</span>
<span class="sd">            attribute used to define the color scale of each dot.</span>
<span class="sd">        y_axis: string, default to &#39;latitude&#39;</span>
<span class="sd">            Can be either &#39;longitude&#39;, &#39;latitude&#39;, or &#39;depth&#39;. This is the</span>
<span class="sd">            attribute used to define the y-axis coordinates.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        fig : matplotlib.pyplot.Figure</span>
<span class="sd">            The figure with color coded latitudes or longitudes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">Normalize</span>
        <span class="kn">from</span> <span class="nn">matplotlib.cm</span> <span class="kn">import</span> <span class="n">ScalarMappable</span>
        <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>

        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cmap&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">colorcet</span> <span class="k">as</span> <span class="nn">cc</span>

                <span class="n">cmap</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">bjy</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">cmap</span> <span class="o">=</span> <span class="s2">&quot;viridis&quot;</span>
        <span class="c1"># ------------------------------------------------</span>
        <span class="c1">#           Scattering plot kwargs</span>
        <span class="n">scatter_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;linewidths&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;linewidths&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;zorder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zorder&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># ------------------------------------------------</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;figname&quot;</span><span class="p">,</span> <span class="s2">&quot;space_time&quot;</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
        <span class="n">cNorm</span> <span class="o">=</span> <span class="n">Normalize</span><span class="p">(</span>
            <span class="n">vmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="n">color_coded</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">vmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="n">color_coded</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">scalar_map</span> <span class="o">=</span> <span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">scalar_map</span><span class="o">.</span><span class="n">set_array</span><span class="p">([])</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">)</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> events&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Calendar Time&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">y_axis</span><span class="o">.</span><span class="n">capitalize</span><span class="p">())</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="n">y_axis</span><span class="p">],</span>
            <span class="n">color</span><span class="o">=</span><span class="n">scalar_map</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="n">color_coded</span><span class="p">]),</span>
            <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">scatter_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]))</span>

        <span class="n">ax_divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">ax_divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;2%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.08</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span>
            <span class="n">scalar_map</span><span class="p">,</span> <span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">color_coded</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div>
</div>



<div class="viewcode-block" id="Data">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Data">[docs]</a>
<span class="k">class</span> <span class="nc">Data</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Data class to manipulate waveforms and metadata.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">date</span><span class="p">,</span>
        <span class="n">where</span><span class="p">,</span>
        <span class="n">data_reader</span><span class="p">,</span>
        <span class="n">duration</span><span class="o">=</span><span class="mf">24.0</span> <span class="o">*</span> <span class="mf">3600.0</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        date: string</span>
<span class="sd">            Date of the requested day. Example: &#39;2016-01-23&#39;.</span>
<span class="sd">        where: string</span>
<span class="sd">            Path to root folder or data file itself (depending on the data</span>
<span class="sd">            reader you are using).</span>
<span class="sd">        data_reader: function</span>
<span class="sd">            Function that takes a path and optional key-word arguments to read</span>
<span class="sd">            data from this path and returns an `obspy.Stream` instance.</span>
<span class="sd">        duration: float, default to 24*3600</span>
<span class="sd">            Target duration, in seconds, of the waveform time series. Waveforms</span>
<span class="sd">            will be trimmed and zero-padded to match this duration.</span>
<span class="sd">        sampling_rate: float or int, default to None</span>
<span class="sd">            Sampling rate of the data. This variable should be left to None if</span>
<span class="sd">            this Data instance aims at dealing with raw data and multiple</span>
<span class="sd">            sampling rates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
        <span class="c1"># full path:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="n">where</span>
        <span class="c1"># data reader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_reader</span> <span class="o">=</span> <span class="n">data_reader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="c1"># fetch metadata</span>
        <span class="c1"># self._read_metadata()</span>
        <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span><span class="n">duration</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;sampling_rate&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You need to define the instance&#39;s sampling rate first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_time&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">time_range</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;ms&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span>

<div class="viewcode-block" id="Data.get_np_array">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Data.get_np_array">[docs]</a>
    <span class="k">def</span> <span class="nf">get_np_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stations</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
        <span class="n">priority</span><span class="o">=</span><span class="s2">&quot;HH&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Arguments go to `BPMF.utils.get_np_array`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You should call read_waveforms first.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">,</span>
            <span class="n">stations</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">priority</span><span class="p">,</span>
            <span class="n">component_aliases</span><span class="o">=</span><span class="n">component_aliases</span><span class="p">,</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Data.read_waveforms">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Data.read_waveforms">[docs]</a>
    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trim_traces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">reader_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the waveform time series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trim_traces : bool, optional</span>
<span class="sd">            If True, call `trim_waveforms` to make sure all traces have the same</span>
<span class="sd">            start time.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Additional parameters can be provided as keyword arguments `**reader_kwargs`</span>
<span class="sd">        which are passed to the `data_reader` method for waveform reading.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reader_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="n">reader_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;endtime&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_reader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">,</span> <span class="o">**</span><span class="n">reader_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trim_traces</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trim_waveforms</span><span class="p">()</span></div>


<div class="viewcode-block" id="Data.set_availability">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Data.set_availability">[docs]</a>
    <span class="k">def</span> <span class="nf">set_availability</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stations</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the data availability.</span>

<span class="sd">        A station is available if at least one station has non-zero data. The</span>
<span class="sd">        availability is then accessed via the property `self.availability`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stations : list of strings or numpy.ndarray</span>
<span class="sd">            Names of the stations on which we check availability. If None, use</span>
<span class="sd">            `self.stations`.</span>
<span class="sd">        components : list, optional</span>
<span class="sd">            List of component codes to consider for availability check,</span>
<span class="sd">            by default [&quot;N&quot;, &quot;E&quot;, &quot;Z&quot;]</span>
<span class="sd">        component_aliases : dict, optional</span>
<span class="sd">            Dictionary mapping component codes to their aliases,</span>
<span class="sd">            by default {&quot;N&quot;: [&quot;N&quot;, &quot;1&quot;], &quot;E&quot;: [&quot;E&quot;, &quot;2&quot;], &quot;Z&quot;: [&quot;Z&quot;]}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.read_waveforms` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">availability_per_sta</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">availability_per_cha</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">stations</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">components</span><span class="p">):</span>
            <span class="n">availability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stations</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">cp_alias</span> <span class="ow">in</span> <span class="n">component_aliases</span><span class="p">[</span><span class="n">cp</span><span class="p">]:</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">cp_alias</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">):</span>
                        <span class="n">availability</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">availability_per_cha</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span> <span class="o">=</span> <span class="n">availability</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">availability_per_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">availability_per_sta</span><span class="p">,</span> <span class="n">availability</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">availability</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability_per_sta</span></div>


<div class="viewcode-block" id="Data.trim_waveforms">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Data.trim_waveforms">[docs]</a>
    <span class="k">def</span> <span class="nf">trim_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trim waveforms.</span>

<span class="sd">        Adjusts the start and end times of waveforms to ensure all traces</span>
<span class="sd">        are synchronized.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        starttime : str or datetime, optional</span>
<span class="sd">            Start time to use for trimming the waveforms. If None,</span>
<span class="sd">            `self.date` is used as the start time. (default None)</span>
<span class="sd">        endtime : str or datetime, optional</span>
<span class="sd">            End time to use for trimming the waveforms. If None,</span>
<span class="sd">            `self.date` + `self.duration` is used as the end time. (default None)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You should call `read_waveforms` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">starttime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span>
        <span class="k">if</span> <span class="n">endtime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">endtime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Event">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event">[docs]</a>
<span class="k">class</span> <span class="nc">Event</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An Event class to describe *any* collection of waveforms.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">origin_time</span><span class="p">,</span>
        <span class="n">moveouts</span><span class="p">,</span>
        <span class="n">stations</span><span class="p">,</span>
        <span class="n">phases</span><span class="p">,</span>
        <span class="n">data_filename</span><span class="p">,</span>
        <span class="n">data_path</span><span class="p">,</span>
        <span class="n">latitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">longitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
        <span class="n">sampling_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
        <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_reader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize an Event instance with basic attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        origin_time : string</span>
<span class="sd">            Origin time, or detection time, of the event.</span>
<span class="sd">        moveouts : numpy.ndarray</span>
<span class="sd">            (n_stations, n_phases) float `numpy.ndarray`.</span>
<span class="sd">            Moveouts, in seconds, for each station and each phase.</span>
<span class="sd">        stations : list of strings</span>
<span class="sd">            List of station names corresponding to `moveouts`.</span>
<span class="sd">        phases : list of strings</span>
<span class="sd">            List of phase names corresponding to `moveouts`.</span>
<span class="sd">        data_filename : string</span>
<span class="sd">            Name of the data file.</span>
<span class="sd">        data_path : string</span>
<span class="sd">            Path to the data directory.</span>
<span class="sd">        latitude : float, optional</span>
<span class="sd">            Event latitude. Default is None.</span>
<span class="sd">        longitude : float, optional</span>
<span class="sd">            Event longitude. Default is None.</span>
<span class="sd">        depth : float, optional</span>
<span class="sd">            Event depth. Default is None.</span>
<span class="sd">        sampling_rate : float, optionak</span>
<span class="sd">            Sampling rate (Hz) of the waveforms. It should be different from</span>
<span class="sd">            None (default) only if you plan to read preprocessed data with a fixed</span>
<span class="sd">            sampling rate.</span>
<span class="sd">        components : list of strings, optional</span>
<span class="sd">            List of the components to use in reading and plotting methods.</span>
<span class="sd">            Default is `[&#39;N&#39;,&#39;E&#39;,&#39;Z&#39;]`.</span>
<span class="sd">        component_aliases : dictionary, optional</span>
<span class="sd">            Each entry of the dictionary is a list of strings.</span>
<span class="sd">            `component_aliases[comp]` is the list of all aliases used for</span>
<span class="sd">            the same component &#39;comp&#39;. For example, `component_aliases[&#39;N&#39;] =</span>
<span class="sd">            [&#39;N&#39;, &#39;1&#39;]` means that both the &#39;N&#39; and &#39;1&#39; channels will be mapped</span>
<span class="sd">            to the Event&#39;s &#39;N&#39; channel.</span>
<span class="sd">        id : string, optional</span>
<span class="sd">            Identifying label. Default is None, in which case the id is taken</span>
<span class="sd">            to be YYYYMMDD_HHMMSS.</span>
<span class="sd">        data_reader : function, optional</span>
<span class="sd">            Function that takes a path and optional key-word arguments to read</span>
<span class="sd">            data from this path and returns an `obspy.Stream` instance. If None,</span>
<span class="sd">            `data_reader` has to be specified when calling `read_waveforms`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">origin_time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span>  <span class="c1"># for compatibility with Data class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span> <span class="n">data_filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">stations</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">components</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span> <span class="o">=</span> <span class="n">component_aliases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">latitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span> <span class="o">=</span> <span class="n">longitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate</span>
        <span class="k">if</span> <span class="n">moveouts</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Integer data type detected for moveouts. Are you sure these&quot;</span>
                <span class="s2">&quot; are in seconds?&quot;</span>
            <span class="p">)</span>
        <span class="c1"># format moveouts in a Pandas data frame</span>
        <span class="n">mv_table</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">ph</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">):</span>
            <span class="n">mv_table</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">moveouts</span><span class="p">[:,</span> <span class="n">p</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">mv_table</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">_%H%M%S.</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_reader</span> <span class="o">=</span> <span class="n">data_reader</span>

<div class="viewcode-block" id="Event.read_from_file">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.read_from_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_file</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">INPUT_PATH</span><span class="p">,</span>
        <span class="n">hdf5_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_reader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize an Event instance from `filename`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        filename: string, default to None</span>
<span class="sd">            Name of the hdf5 file with the event&#39;s data. If None, then</span>
<span class="sd">            `hdf5_file` should be specified.</span>
<span class="sd">        db_path: string, default to `cfg.INPUT_PATH`</span>
<span class="sd">            Name of the directory where `filename` is located.</span>
<span class="sd">        gid: string, default to None</span>
<span class="sd">            If not None, this string is the hdf5&#39;s group name of the event.</span>
<span class="sd">        hdf5_file: `h5py.File`, default to None</span>
<span class="sd">            If not None, is an opened file pointing directly at the subfolder of</span>
<span class="sd">            interest.</span>
<span class="sd">        data_reader: function, default to None</span>
<span class="sd">            Function that takes a path and optional key-word arguments to read</span>
<span class="sd">            data from this path and returns an `obspy.Stream` instance. If None,</span>
<span class="sd">            `data_reader` has to be specified when calling `read_waveforms`.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        event: `Event` instance</span>
<span class="sd">            The `Event` instance defined by the data in `filename`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">,</span> <span class="s2">&quot;moveouts&quot;</span><span class="p">,</span> <span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="s2">&quot;phases&quot;</span><span class="p">]</span>
        <span class="n">optional_attr</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
            <span class="s2">&quot;longitude&quot;</span><span class="p">,</span>
            <span class="s2">&quot;depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sampling_rate&quot;</span><span class="p">,</span>
            <span class="s2">&quot;compoments&quot;</span><span class="p">,</span>
            <span class="s2">&quot;id&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">has_picks</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">has_arrivals</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">close_file</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent_file</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
            <span class="n">path_database</span> <span class="o">=</span> <span class="n">parent_file</span><span class="o">.</span><span class="n">filename</span>
            <span class="k">if</span> <span class="n">gid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># go to specified group</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">parent_file</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">parent_file</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># remember to close file at the end</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">hdf5_file</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">&quot;file&quot;</span><span class="p">):</span>
                <span class="n">path_database</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">filename</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">path_database</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">attr</span><span class="p">][()])</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;where&quot;</span><span class="p">][()])</span> <span class="o">==</span> <span class="nb">bytes</span><span class="p">:</span>
            <span class="c1"># if h5py.version &gt;= 3</span>
            <span class="n">data_path</span><span class="p">,</span> <span class="n">data_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;where&quot;</span><span class="p">][()]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># more recent versions of h5py seems to decode automatically</span>
            <span class="n">data_path</span><span class="p">,</span> <span class="n">data_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;where&quot;</span><span class="p">][()])</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">data_filename</span><span class="p">,</span> <span class="n">data_path</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">opt_attr</span> <span class="ow">in</span> <span class="n">optional_attr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">opt_attr</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">opt_attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">opt_attr</span><span class="p">][()]</span>
        <span class="n">aux_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s2">&quot;aux_data&quot;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">])</span> <span class="o">==</span> <span class="n">h5</span><span class="o">.</span><span class="n">Group</span><span class="p">:</span>
                    <span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">key2</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">]:</span>
                        <span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">key2</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">key2</span><span class="p">][()]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">][()]</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">==</span> <span class="nb">bytes</span><span class="p">:</span>
                        <span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;picks&quot;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;picks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">picks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;picks&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">][()]</span>
                <span class="k">if</span> <span class="n">picks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                    <span class="n">picks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;stations&quot;</span><span class="p">:</span>
                        <span class="n">picks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">picks</span><span class="p">)</span>
            <span class="n">picks</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">has_picks</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="s2">&quot;arrival_times&quot;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">arrival_times</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;arrival_times&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">arrival_times</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;arrival_times&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">][()]</span>
                <span class="k">if</span> <span class="n">arrival_times</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                    <span class="n">arrival_times</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arrival_times</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;stations&quot;</span><span class="p">:</span>
                        <span class="n">arrival_times</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">arrival_times</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">arrival_times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">arrival_times</span><span class="p">)</span>
            <span class="n">arrival_times</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">has_arrivals</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
            <span class="c1"># close the file</span>
            <span class="n">parent_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># ! the order of args is important !</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;data_reader&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_reader</span>
        <span class="n">event</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;cov_mat&quot;</span> <span class="ow">in</span> <span class="n">aux_data</span><span class="p">:</span>
            <span class="n">event</span><span class="o">.</span><span class="n">cov_mat</span> <span class="o">=</span> <span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;cov_mat&quot;</span><span class="p">]</span>
        <span class="n">event</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span><span class="n">aux_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">has_picks</span><span class="p">:</span>
            <span class="n">event</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="n">picks</span>
        <span class="k">if</span> <span class="n">has_arrivals</span><span class="p">:</span>
            <span class="n">event</span><span class="o">.</span><span class="n">arrival_times</span> <span class="o">=</span> <span class="n">arrival_times</span>
        <span class="k">if</span> <span class="n">gid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># keep trace that we read from a group</span>
            <span class="n">event</span><span class="o">.</span><span class="n">hdf5_gid</span> <span class="o">=</span> <span class="n">gid</span>
        <span class="n">event</span><span class="o">.</span><span class="n">path_database</span> <span class="o">=</span> <span class="n">path_database</span>
        <span class="k">return</span> <span class="n">event</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">availability</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability_per_sta</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">availability_per_sta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_availability_per_sta&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_sta</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;availability_per_sta&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;availability_per_sta&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.set_availability` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">availability_per_cha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_availability_per_cha&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_cha</span>
        <span class="n">availability</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="sa">f</span><span class="s2">&quot;availability_</span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
                <span class="n">availability</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">cp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span>
                    <span class="sa">f</span><span class="s2">&quot;availability_</span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.set_availability` first.&quot;</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">return</span> <span class="n">availability</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hmax_unc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_hmax_unc&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hmax_unc</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;hmax_unc&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;hmax_unc&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hor_ver_uncertainties</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hmax_unc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hmin_unc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_hmin_unc&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hmin_unc</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;hmin_unc&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;hmin_unc&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hor_ver_uncertainties</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hmin_unc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vmax_unc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_vmax_unc&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vmax_unc</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;vmax_unc&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;vmax_unc&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hor_ver_uncertainties</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vmax_unc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">az_hmax_unc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_az_hmax_unc&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmax_unc</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;az_hmax_unc&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;az_hmax_unc&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hor_ver_uncertainties</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmax_unc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">az_hmin_unc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_az_hmin_unc&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmin_unc</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;az_hmin_unc&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;az_hmin_unc&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hor_ver_uncertainties</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmin_unc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pl_vmax_unc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_pl_vmax_unc&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pl_vmax_unc</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;pl_vmax_unc&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;pl_vmax_unc&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hor_ver_uncertainties</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pl_vmax_unc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">location</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">snr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_snr&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snr</span>
        <span class="n">_snr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="sa">f</span><span class="s2">&quot;snr_</span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">:</span>
                    <span class="n">_snr</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="n">cp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;snr_</span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.compute_snr` first.&quot;</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">return</span> <span class="n">_snr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_receiver_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_source_receiver_dist&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_receiver_dist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;You need to set source_receiver_dist before.&quot;</span>
                <span class="s2">&quot; Call self.set_source_receiver_dist(network)&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_receiver_epicentral_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_source_receiver_epicentral_dist&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_receiver_epicentral_dist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;You need to set source_receiver_epicentral_dist before.&quot;</span>
                <span class="s2">&quot; Call self.set_source_receiver_dist(network)&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">waveforms_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return traces in numpy.ndarray.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="s2">&quot;HH&quot;</span><span class="p">,</span>
            <span class="n">component_aliases</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span><span class="p">,</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Event.compute_snr">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.compute_snr">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_snr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise_window_sec</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="o">**</span><span class="n">data_reader_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        noise_window_sec : float, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;availability_per_cha&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_availability</span><span class="p">()</span>
        <span class="n">data_reader_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;data_reader&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_reader</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">noise</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">noise_window_sec</span> <span class="o">*</span> <span class="n">noise</span><span class="o">.</span><span class="n">sr</span><span class="p">),</span>
            <span class="n">time_shifted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">offset_ot</span><span class="o">=</span><span class="n">noise_window_sec</span><span class="p">,</span>
            <span class="o">**</span><span class="n">data_reader_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">noise_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">noise_std</span><span class="p">[</span><span class="n">noise_std</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">signal_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">_snr</span> <span class="o">=</span> <span class="n">signal_std</span> <span class="o">/</span> <span class="n">noise_std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">noise</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">noise</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">_snr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;snr_</span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="n">sta</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snr</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span> <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snr</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
            <span class="p">}</span>
        <span class="p">)</span>

        <span class="k">del</span> <span class="n">noise</span></div>


<div class="viewcode-block" id="Event.get_np_array">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.get_np_array">[docs]</a>
    <span class="k">def</span> <span class="nf">get_np_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="s2">&quot;HH&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Arguments are passed to `BPMF.utils.get_np_array`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You should call read_waveforms first.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">,</span>
            <span class="n">stations</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">priority</span><span class="p">,</span>
            <span class="n">component_aliases</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span><span class="p">,</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Event.get_peak_amplitudes">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.get_peak_amplitudes">[docs]</a>
    <span class="k">def</span> <span class="nf">get_peak_amplitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get peak waveform amplitudes.</span>

<span class="sd">        The peak waveform amplitudes are typically used to compute</span>
<span class="sd">        amplitude-based local magnitudes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stations : list of strings</span>
<span class="sd">            Names of the stations to include in the output array. Define the order</span>
<span class="sd">            of the station axis.</span>
<span class="sd">        components : list of strings, default to [&#39;N&#39;,&#39;E&#39;,&#39;Z&#39;]</span>
<span class="sd">            Names of the components to include in the output array. Define the order</span>
<span class="sd">            of the component axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        peak_amplitudes : numpy.ndarray</span>
<span class="sd">            (num_stations, num_components) numpy.ndarray with the peak</span>
<span class="sd">            waveform amplitude on each channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">waveforms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">)</span>
        <span class="n">peak_amplitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">waveforms</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">peak_amplitudes</span></div>


<div class="viewcode-block" id="Event.hor_ver_uncertainties">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.hor_ver_uncertainties">[docs]</a>
    <span class="k">def</span> <span class="nf">hor_ver_uncertainties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;intersection&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the horizontal and vertical uncertainties on location.</span>

<span class="sd">        Returns the errors as given by the 68% confidence ellipsoid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : str, optional</span>
<span class="sd">            Specifies the mode for calculating the horizontal uncertainties.</span>
<span class="sd">            - If &#39;intersection&#39;, the horizontal uncertainties are the lengths</span>
<span class="sd">            of the semi-axes of the ellipse defined by the intersection between</span>
<span class="sd">            the confidence ellipsoid and the horizontal plane.</span>
<span class="sd">            - If &#39;projection&#39;, the horizontal uncertainties are the maximum and minimum</span>
<span class="sd">            spans of the confidence ellipsoid in the horizontal directions.</span>
<span class="sd">            (default &#39;intersection&#39;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        None</span>

<span class="sd">        New Attributes</span>
<span class="sd">        --------------</span>
<span class="sd">        _hmax_unc : float</span>
<span class="sd">            The maximum horizontal uncertainty in kilometers.</span>
<span class="sd">        _hmin_unc : float</span>
<span class="sd">            The minimum horizontal uncertainty in kilometers.</span>
<span class="sd">        _vmax_unc : float</span>
<span class="sd">            The maximum vertical uncertainty in kilometers.</span>
<span class="sd">        _az_hmax_unc : float</span>
<span class="sd">            The azimuth (angle from north) of the maximum horizontal uncertainty in degrees.</span>
<span class="sd">        _az_hmin_unc : float</span>
<span class="sd">            The azimuth (angle from north) of the minimum horizontal uncertainty in degrees.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The sum of _hmax_unc and _vmax_unc does not necessarily equal the</span>
<span class="sd">        maximum length of the uncertainty ellipsoid&#39;s semi-axis; the latter</span>
<span class="sd">        represents the longest semi-axis of the ellipsoid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cov_mat&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Class instance does not have a `cov_mat` attribute.&quot;</span><span class="p">)</span>
            <span class="c1"># these private attributes should be called via their property names</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hmax_unc</span> <span class="o">=</span> <span class="mf">15.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hmin_unc</span> <span class="o">=</span> <span class="mf">15.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vmax_unc</span> <span class="o">=</span> <span class="mf">15.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmax_unc</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmin_unc</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">return</span>
        <span class="c1"># X: west, Y: south, Z: downward</span>
        <span class="n">s_68_3df</span> <span class="o">=</span> <span class="mf">3.52</span>
        <span class="n">s_68_2df</span> <span class="o">=</span> <span class="mf">2.28</span>
        <span class="c1"># eigendecomposition of whole matrix</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span><span class="p">)</span>
        <span class="n">semi_axis_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_68_3df</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
        <span class="c1"># check the vertical components of all semi-axes:</span>
        <span class="n">vertical_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">semi_axis_length</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;intersection&quot;</span><span class="p">:</span>
            <span class="c1"># eigendecomposition of cov mat restricted to horizontal components</span>
            <span class="n">wh</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">semi_axis_length_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_68_2df</span> <span class="o">*</span> <span class="n">wh</span><span class="p">)</span>
            <span class="n">hmax_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">semi_axis_length_h</span><span class="p">)</span>
            <span class="n">hmin_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">semi_axis_length_h</span><span class="p">)</span>
            <span class="n">hmax_dir</span> <span class="o">=</span> <span class="n">vh</span><span class="p">[:,</span> <span class="n">wh</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
            <span class="n">hmin_dir</span> <span class="o">=</span> <span class="n">vh</span><span class="p">[:,</span> <span class="n">wh</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
            <span class="n">az_hmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">hmax_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">hmax_dir</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">az_hmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">hmin_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">hmin_dir</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;projection&quot;</span><span class="p">:</span>
            <span class="c1"># check the horizontal components of all semi-axes:</span>
            <span class="n">horizontal_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">semi_axis_length</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">hmax_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">horizontal_unc</span><span class="p">)</span>
            <span class="n">hmin_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">horizontal_unc</span><span class="p">)</span>
            <span class="n">hmax_dir</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">horizontal_unc</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
            <span class="n">hmin_dir</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">horizontal_unc</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
            <span class="n">az_hmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">hmax_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">hmax_dir</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">az_hmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">hmin_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">hmin_dir</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="c1"># these private attributes should be called via their property names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hmax_unc</span> <span class="o">=</span> <span class="n">hmax_unc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hmin_unc</span> <span class="o">=</span> <span class="n">hmin_unc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vmax_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vertical_unc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pl_vmax_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">vertical_unc</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pl_vmax_unc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pl_vmax_unc</span><span class="p">,</span> <span class="mf">180.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pl_vmax_unc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmax_unc</span> <span class="o">=</span> <span class="n">az_hmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmin_unc</span> <span class="o">=</span> <span class="n">az_hmin</span></div>


<div class="viewcode-block" id="Event.n_best_SNR_stations">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.n_best_SNR_stations">[docs]</a>
    <span class="k">def</span> <span class="nf">n_best_SNR_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust `self.stations` to the `n` best SNR stations.</span>

<span class="sd">        This function finds the `n` best stations based on signal-to-noise ratio (SNR)</span>
<span class="sd">        and modifies the `self.stations` attribute accordingly. The instance&#39;s properties</span>
<span class="sd">        will also change to reflect the new selection of stations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            The number of best SNR stations to select.</span>
<span class="sd">        available_stations : list of str, default None</span>
<span class="sd">            The list of stations from which to search for the closest stations. If</span>
<span class="sd">            provided, only stations in this list will be considered. This can be used</span>
<span class="sd">            to exclude stations that are known to lack data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># re-initialize the stations attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">index_pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">))</span>
        <span class="c1"># limit the index pool to available stations</span>
        <span class="k">if</span> <span class="n">available_stations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">availability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">availability</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability</span>
        <span class="n">index_pool</span> <span class="o">=</span> <span class="n">index_pool</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="n">average_snr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">best_SNR_stations</span> <span class="o">=</span> <span class="n">index_pool</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">average_snr</span><span class="p">[</span><span class="n">index_pool</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="c1"># make sure we return a n-vector</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_SNR_stations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_SNR_stations</span><span class="p">)</span>
            <span class="n">remaining_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">average_snr</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">best_SNR_stations</span>
            <span class="p">)</span>
            <span class="n">best_SNR_stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">best_SNR_stations</span><span class="p">,</span> <span class="n">remaining_indexes</span><span class="p">[:</span><span class="n">missing</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">[</span><span class="n">best_SNR_stations</span><span class="p">[:</span><span class="n">n</span><span class="p">]]</span></div>


<div class="viewcode-block" id="Event.n_closest_stations">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.n_closest_stations">[docs]</a>
    <span class="k">def</span> <span class="nf">n_closest_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust `self.stations` to the `n` closest stations.</span>

<span class="sd">        Finds the `n` closest stations based on distance and modifies `self.stations` accordingly.</span>
<span class="sd">        The instance&#39;s properties will also change to reflect the updated station selection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            The number of closest stations to fetch.</span>
<span class="sd">        available_stations : list of strings, optional</span>
<span class="sd">            The list of stations from which the closest stations are searched.</span>
<span class="sd">            If certain stations are known to lack data, they can be excluded</span>
<span class="sd">            from the closest stations selection. (default None)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;network_stations&quot;</span><span class="p">):</span>
            <span class="c1"># typically, an Event instance has no network_stations</span>
            <span class="c1"># attribute, but a Template instance does</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># re-initialize the stations attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">index_pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">))</span>
        <span class="c1"># limit the index pool to available stations</span>
        <span class="k">if</span> <span class="n">available_stations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">availability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">available_stations</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">availability</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability</span>
        <span class="n">station_pool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="n">closest_stations</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source_receiver_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station_pool</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># make sure we return a n-vector</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_stations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_stations</span><span class="p">)</span>
            <span class="n">closest_stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">closest_stations</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_receiver_dist</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">closest_stations</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;rows&quot;</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="n">missing</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">closest_stations</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Event.pick_PS_phases">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.pick_PS_phases">[docs]</a>
    <span class="k">def</span> <span class="nf">pick_PS_phases</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">,</span>
        <span class="n">threshold_P</span><span class="o">=</span><span class="mf">0.60</span><span class="p">,</span>
        <span class="n">threshold_S</span><span class="o">=</span><span class="mf">0.60</span><span class="p">,</span>
        <span class="n">offset_ot</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">BUFFER_EXTRACTED_EVENTS_SEC</span><span class="p">,</span>
        <span class="n">mini_batch_size</span><span class="o">=</span><span class="mi">126</span><span class="p">,</span>
        <span class="n">phase_on_comp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">},</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
        <span class="n">upsampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">downsampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">use_apriori_picks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">search_win_sec</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
        <span class="n">ml_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ml_model_name</span><span class="o">=</span><span class="s2">&quot;original&quot;</span><span class="p">,</span>
        <span class="n">keep_probability_time_series</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">phase_probability_time_series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use PhaseNet (Zhu et al., 2019) to pick P and S waves (Event class).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        duration : float</span>
<span class="sd">            Duration of the time window, in seconds, to process and search</span>
<span class="sd">            for P and S wave arrivals.</span>
<span class="sd">        threshold_P : float, optional</span>
<span class="sd">            Threshold on PhaseNet&#39;s probabilities to trigger the</span>
<span class="sd">            identification of a P-wave arrival. (default 0.60)</span>
<span class="sd">        threshold_S : float, optional</span>
<span class="sd">            Threshold on PhaseNet&#39;s probabilities to trigger the</span>
<span class="sd">            identification of an S-wave arrival. (default 0.60)</span>
<span class="sd">        offset_ot : float, optional</span>
<span class="sd">            Offset in seconds to apply to the origin time.</span>
<span class="sd">            (default cfg.BUFFER_EXTRACTED_EVENTS_SEC)</span>
<span class="sd">        mini_batch_size : int, optional</span>
<span class="sd">            Number of traces processed in a single batch by PhaseNet. (default 126)</span>
<span class="sd">        phase_on_comp : dict, optional</span>
<span class="sd">            Dictionary defining the seismic phase extracted on each component.</span>
<span class="sd">            For example, `phase_on_comp[&#39;N&#39;]` specifies the phase extracted on</span>
<span class="sd">            the north component.</span>
<span class="sd">            (default {&quot;N&quot;: &quot;S&quot;, &quot;1&quot;: &quot;S&quot;, &quot;E&quot;: &quot;S&quot;, &quot;2&quot;: &quot;S&quot;, &quot;Z&quot;: &quot;P&quot;})</span>
<span class="sd">        component_aliases : dict, optional</span>
<span class="sd">            Dictionary mapping each component to a list of strings representing</span>
<span class="sd">            aliases used for the same component. For example, `component_aliases[&#39;N&#39;] = [&#39;N&#39;, &#39;1&#39;]`</span>
<span class="sd">            means that both the &#39;N&#39; and &#39;1&#39; channels will be mapped to the</span>
<span class="sd">            Event&#39;s &#39;N&#39; channel.</span>
<span class="sd">            (default {&quot;N&quot;: [&quot;N&quot;, &quot;1&quot;], &quot;E&quot;: [&quot;E&quot;, &quot;2&quot;], &quot;Z&quot;: [&quot;Z&quot;]})</span>
<span class="sd">        upsampling : int, optional</span>
<span class="sd">            Upsampling factor applied before calling PhaseNet. (default 1)</span>
<span class="sd">        downsampling : int, optional</span>
<span class="sd">            Downsampling factor applied before calling PhaseNet. (default 1)</span>
<span class="sd">        use_apriori_picks : bool, optional</span>
<span class="sd">            Flag indicating whether to use apriori picks for refining</span>
<span class="sd">            the P and S wave picks. (default False)</span>
<span class="sd">        search_win_sec : float, optional</span>
<span class="sd">            Search window size, in seconds, used for refining</span>
<span class="sd">            the P and S wave picks. (default 2.0)</span>
<span class="sd">        ml_model : object, optional</span>
<span class="sd">            Pre-trained PhaseNet model object. If not provided,</span>
<span class="sd">            the default model will be loaded. (default None)</span>
<span class="sd">        ml_model_name : str, optional</span>
<span class="sd">            Name of the pre-trained PhaseNet model to load if `ml_model`</span>
<span class="sd">            is not provided. (default &quot;original&quot;)</span>
<span class="sd">        keep_probability_time_series : bool, optional</span>
<span class="sd">            If True, the phase probability time series are stored in a</span>
<span class="sd">            new class attribute, `self.probability_time_series`. (default True)</span>
<span class="sd">        phase_probability_time_series : `BPMF.dataset.WaveformTransform`, optional</span>
<span class="sd">            If different from None, the phase probabilities are not re-computed</span>
<span class="sd">            but, instead, are fetched from an existing</span>
<span class="sd">            `BPMF.dataset.WaveformTransform` instance. (default None)</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Extra keyword arguments passed to `Event.read_waveforms`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - PhaseNet must be used with 3-component data.</span>
<span class="sd">        - Results are stored in the object&#39;s attribute `self.picks`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">no_grad</span><span class="p">,</span> <span class="n">from_numpy</span>

        <span class="k">if</span> <span class="n">ml_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">seisbench.models</span> <span class="k">as</span> <span class="nn">sbm</span>

            <span class="n">ml_model</span> <span class="o">=</span> <span class="n">sbm</span><span class="o">.</span><span class="n">PhaseNet</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">ml_model_name</span><span class="p">)</span>
            <span class="n">ml_model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

        <span class="n">ml_p_index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ml_P_index&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ml_s_index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ml_S_index&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">phase_probability_time_series</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;read_waveforms&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="c1"># read waveforms in picking mode, i.e. with `time_shifted`=False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span>
                    <span class="n">duration</span><span class="p">,</span>
                    <span class="n">offset_ot</span><span class="o">=</span><span class="n">offset_ot</span><span class="p">,</span>
                    <span class="n">phase_on_comp</span><span class="o">=</span><span class="n">phase_on_comp</span><span class="p">,</span>
                    <span class="n">component_aliases</span><span class="o">=</span><span class="n">component_aliases</span><span class="p">,</span>
                    <span class="n">time_shifted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">data_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">upsampling</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">downsampling</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">resample_poly</span>

                <span class="n">data_arr</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="n">upsampling</span><span class="p">,</span> <span class="n">downsampling</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># momentarily update samping_rate</span>
                <span class="n">sampling_rate0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span> <span class="o">*</span> <span class="n">upsampling</span> <span class="o">/</span> <span class="n">downsampling</span>
            <span class="n">data_arr_n</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_batch</span><span class="p">(</span>
                <span class="n">data_arr</span><span class="p">,</span>
                <span class="n">normalization_window_sample</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;normalization_window_sample&quot;</span><span class="p">,</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="n">closest_pow2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">data_arr_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">closest_pow2</span> <span class="o">-</span> <span class="n">data_arr_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">diff</span> <span class="o">%</span> <span class="mi">2</span>
            <span class="n">data_arr_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                <span class="n">data_arr_n</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span>
            <span class="p">)</span>
            <span class="k">with</span> <span class="n">no_grad</span><span class="p">():</span>
                <span class="n">phase_proba</span> <span class="o">=</span> <span class="n">ml_model</span><span class="p">(</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">data_arr_n</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">())</span>
                <span class="n">phase_proba</span> <span class="o">=</span> <span class="n">phase_proba</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="c1"># trim edges</span>
            <span class="n">phase_proba</span> <span class="o">=</span> <span class="n">phase_proba</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">left</span><span class="p">:</span><span class="o">-</span><span class="n">right</span><span class="p">]</span>

            <span class="c1"># define traces variable for later</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span>

            <span class="k">if</span> <span class="n">keep_probability_time_series</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">probability_time_series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">phase_proba</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.0e-3</span><span class="p">:</span>
                    <span class="n">times</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="n">times</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;timedelta64[ms]&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">times</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e9</span> <span class="o">*</span> <span class="n">times</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;timedelta64[ns]&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">probability_times</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span> <span class="o">+</span> <span class="n">times</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">probability_time_series</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="s2">&quot;P&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase_proba</span><span class="p">[</span>
                        <span class="n">s</span><span class="p">,</span> <span class="n">ml_p_index</span><span class="p">,</span> <span class="p">:</span>
                    <span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">probability_time_series</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase_proba</span><span class="p">[</span>
                        <span class="n">s</span><span class="p">,</span> <span class="n">ml_s_index</span><span class="p">,</span> <span class="p">:</span>
                    <span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use the WaveformTransform instance in `phase_probability_time_series` to</span>
            <span class="c1"># retrieve the pre-computed probabilities at the times of the event</span>
            <span class="k">if</span> <span class="n">upsampling</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">downsampling</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># momentarily update samping_rate</span>
                <span class="n">sampling_rate0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span> <span class="o">*</span> <span class="n">upsampling</span> <span class="o">/</span> <span class="n">downsampling</span>

            <span class="n">phase_probabilities_event</span> <span class="o">=</span> <span class="n">phase_probability_time_series</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">-</span> <span class="n">offset_ot</span><span class="p">,</span>
                <span class="n">duration</span><span class="o">=</span><span class="n">duration</span><span class="p">,</span>
                <span class="n">stations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">phase_proba</span> <span class="o">=</span> <span class="n">phase_probabilities_event</span><span class="o">.</span><span class="n">transform_arr</span>
            <span class="k">if</span> <span class="n">keep_probability_time_series</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">probability_times</span> <span class="o">=</span> <span class="n">phase_probabilities_event</span><span class="o">.</span><span class="n">time</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">probability_time_series</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">phase_probabilities_event</span><span class="o">.</span><span class="n">data_frame_view</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="c1"># define traces variable for later</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="n">phase_probabilities_event</span><span class="o">.</span><span class="n">transform</span>
        <span class="c1"># find candidate picks and store them in pandas.DataFrame</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;P_probas&quot;</span><span class="p">,</span> <span class="s2">&quot;P_picks&quot;</span><span class="p">,</span> <span class="s2">&quot;P_unc&quot;</span><span class="p">,</span> <span class="s2">&quot;S_probas&quot;</span><span class="p">,</span> <span class="s2">&quot;S_picks&quot;</span><span class="p">,</span> <span class="s2">&quot;S_unc&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
            <span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;P_probas&quot;</span><span class="p">,</span> <span class="s2">&quot;P_picks&quot;</span><span class="p">,</span> <span class="s2">&quot;P_unc&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">find_picks</span><span class="p">(</span>
                <span class="n">phase_proba</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">ml_p_index</span><span class="p">,</span> <span class="p">:],</span> <span class="n">threshold_P</span>
            <span class="p">)</span>
            <span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;S_probas&quot;</span><span class="p">,</span> <span class="s2">&quot;S_picks&quot;</span><span class="p">,</span> <span class="s2">&quot;S_unc&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">find_picks</span><span class="p">(</span>
                <span class="n">phase_proba</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">ml_s_index</span><span class="p">,</span> <span class="p">:],</span> <span class="n">threshold_S</span>
            <span class="p">)</span>
        <span class="c1"># now, only keep the best P and S picks</span>
        <span class="k">if</span> <span class="n">use_apriori_picks</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;arrival_times&quot;</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s2">&quot;P&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
            <span class="n">prior_knowledge</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
            <span class="c1"># for sta in self.stations:</span>
            <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">prior_knowledge</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">prior_knowledge</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="n">ph</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span>
                        <span class="n">udt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_arrival_times&quot;</span><span class="p">])</span>
                        <span class="o">-</span> <span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span>
                        <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prior_knowledge</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># only used if use_apriori_picks is True</span>
        <span class="n">search_win_samp</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span><span class="n">search_win_sec</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
        <span class="c1"># keep best P- and S-wave pick on each 3-comp seismogram</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_picks</span><span class="p">(</span>
            <span class="n">picks</span><span class="p">,</span>
            <span class="n">prior_knowledge</span><span class="o">=</span><span class="n">prior_knowledge</span><span class="p">,</span>
            <span class="n">search_win_samp</span><span class="o">=</span><span class="n">search_win_samp</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># express picks in seconds and absolute times</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_unc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_unc&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_unc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_unc&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span>

        <span class="n">picks</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;P_picks&quot;</span><span class="p">:</span> <span class="s2">&quot;P_picks_sec&quot;</span><span class="p">,</span>
                <span class="s2">&quot;P_unc&quot;</span><span class="p">:</span> <span class="s2">&quot;P_unc_sec&quot;</span><span class="p">,</span>
                <span class="s2">&quot;S_picks&quot;</span><span class="p">:</span> <span class="s2">&quot;S_picks_sec&quot;</span><span class="p">,</span>
                <span class="s2">&quot;S_unc&quot;</span><span class="p">:</span> <span class="s2">&quot;S_unc_sec&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">picks</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">]):</span>
                    <span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">continue</span>
                <span class="n">abs_pick</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
                    <span class="o">+</span> <span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_pick</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="n">picks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;stations&quot;</span>
        <span class="c1"># self.picks.replace(0.0, np.nan, inplace=True)</span>
        <span class="k">if</span> <span class="n">upsampling</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">downsampling</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># reset the sampling rate to initial value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate0</span></div>


<div class="viewcode-block" id="Event.read_waveforms">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.read_waveforms">[docs]</a>
    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">,</span>
        <span class="n">phase_on_comp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">},</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
        <span class="n">offset_phase</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">},</span>
        <span class="n">time_shifted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">offset_ot</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">BUFFER_EXTRACTED_EVENTS_SEC</span><span class="p">,</span>
        <span class="n">data_reader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="o">**</span><span class="n">reader_kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read waveform data (Event class).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        duration : float</span>
<span class="sd">            Duration of the extracted time windows in seconds.</span>
<span class="sd">        phase_on_comp : dict, optional</span>
<span class="sd">            Dictionary defining the seismic phase extracted on each component.</span>
<span class="sd">            For example, `phase_on_comp[&#39;N&#39;]` specifies the phase extracted on the north component.</span>
<span class="sd">            (default {&quot;N&quot;: &quot;S&quot;, &quot;1&quot;: &quot;S&quot;, &quot;E&quot;: &quot;S&quot;, &quot;2&quot;: &quot;S&quot;, &quot;Z&quot;: &quot;P&quot;})</span>
<span class="sd">        component_aliases : dict, optional</span>
<span class="sd">            Dictionary mapping each component to a list of strings</span>
<span class="sd">            representing aliases used for the same component.</span>
<span class="sd">            For example, `component_aliases[&#39;N&#39;] = [&#39;N&#39;, &#39;1&#39;]` means that both the</span>
<span class="sd">            &#39;N&#39; and &#39;1&#39; channels will be mapped to the Event&#39;s &#39;N&#39; channel.</span>
<span class="sd">            (default {&quot;N&quot;: [&quot;N&quot;, &quot;1&quot;], &quot;E&quot;: [&quot;E&quot;, &quot;2&quot;], &quot;Z&quot;: [&quot;Z&quot;]})</span>
<span class="sd">        offset_phase : dict, optional</span>
<span class="sd">            Dictionary defining when the time window starts with respect to the pick.</span>
<span class="sd">            A positive offset means the window starts before the pick.</span>
<span class="sd">            Not used if `time_shifted` is False. (default {&quot;P&quot;: 1.0, &quot;S&quot;: 4.0})</span>
<span class="sd">        time_shifted : bool, optional</span>
<span class="sd">            If True (default), the moveouts are used to extract time windows</span>
<span class="sd">            from specific seismic phases. If False, windows are simply extracted</span>
<span class="sd">            with respect to the origin time.</span>
<span class="sd">        offset_ot : float, optional</span>
<span class="sd">            Only used if `time_shifted` is False.</span>
<span class="sd">            Time in seconds taken before `origin_time`.</span>
<span class="sd">            (default cfg.BUFFER_EXTRACTED_EVENTS_SEC)</span>
<span class="sd">        data_reader : function, optional</span>
<span class="sd">            Function that takes a path and optional keyword arguments to read</span>
<span class="sd">            data from this path and returns an `obspy.Stream` instance.</span>
<span class="sd">            If None (default), this function uses `self.data_reader` and</span>
<span class="sd">            returns None if `self.data_reader=None`.</span>
<span class="sd">        n_threads : int, optional</span>
<span class="sd">            Number of threads used to parallelize reading. Default is 1 (sequential reading).</span>
<span class="sd">        **reader_kwargs : dict, optional</span>
<span class="sd">            Extra keyword arguments passed to the `data_reader` function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This function populates the `self.traces` attribute with the waveform data.</span>
<span class="sd">        - The `duration` and `component_aliases` are stored as attributes in the instance.</span>
<span class="sd">        - The `phase_on_comp` and `offset_phase` information is stored</span>
<span class="sd">        as auxiliary data in the instance.</span>
<span class="sd">        - If `reader_kwargs` contains the &quot;attach_response&quot; key set to True,</span>
<span class="sd">        traces without instrument response information are removed from `self.traces`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">Stream</span>
        <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

        <span class="k">if</span> <span class="n">n_threads</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>

        <span class="k">if</span> <span class="n">data_reader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_reader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_reader</span>
        <span class="k">if</span> <span class="n">data_reader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You need to specify a data reader for the class instance.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_reader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_reader</span> <span class="o">=</span> <span class="n">data_reader</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">)</span>
        <span class="n">reading_task_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
                <span class="n">ph</span> <span class="o">=</span> <span class="n">phase_on_comp</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">time_shifted</span><span class="p">:</span>
                    <span class="n">pick</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span>
                        <span class="o">-</span> <span class="n">offset_phase</span><span class="p">[</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pick</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">-</span> <span class="n">offset_ot</span>
                <span class="k">for</span> <span class="n">cp_alias</span> <span class="ow">in</span> <span class="n">component_aliases</span><span class="p">[</span><span class="n">comp</span><span class="p">]:</span>
                    <span class="c1"># note: here, we</span>
                    <span class="n">reading_task_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">partial</span><span class="p">(</span>
                            <span class="n">data_reader</span><span class="p">,</span>
                            <span class="n">where</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">,</span>
                            <span class="n">stations</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span>
                            <span class="n">channels</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cp_alias</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="n">starttime</span><span class="o">=</span><span class="n">pick</span><span class="p">,</span>
                            <span class="n">endtime</span><span class="o">=</span><span class="n">pick</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">reader_kwargs</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="k">if</span> <span class="n">n_threads</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_threads</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]:</span>
                <span class="c1"># n_threads = None means use all CPUs</span>
                <span class="n">n_threads</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">n_threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                <span class="n">traces_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">reading_task_list</span><span class="p">[</span><span class="n">i</span><span class="p">](),</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reading_task_list</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">traces_</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">+=</span> <span class="n">tr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">reading_task_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">+=</span> <span class="n">task</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">reader_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;attach_response&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># remove traces for which we could not find the instrument response</span>
            <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;response&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">offset_phase</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;offset_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">offset_phase</span><span class="p">[</span><span class="n">ph</span><span class="p">]})</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">phase_on_comp</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;phase_on_comp</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">phase_on_comp</span><span class="p">[</span><span class="n">comp</span><span class="p">]})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">time_shifted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trim_waveforms</span><span class="p">(</span>
                <span class="n">starttime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">-</span> <span class="n">offset_ot</span><span class="p">,</span>
                <span class="n">endtime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">-</span> <span class="n">offset_ot</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Event.relocate">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.relocate">[docs]</a>
    <span class="k">def</span> <span class="nf">relocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">routine</span><span class="o">=</span><span class="s2">&quot;NLLoc&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper function for earthquake relocation using multiple methods.</span>

<span class="sd">        This function serves as an interface for the earthquake relocation process</span>
<span class="sd">        using different relocation routines. The routine to be used is specified</span>
<span class="sd">        by the `routine` parameter. All keyword arguments are passed to the</span>
<span class="sd">        corresponding routine.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        routine : str, optional</span>
<span class="sd">            Method used for the relocation. Available options are:</span>
<span class="sd">            - &#39;NLLoc&#39;: Calls the `relocate_NLLoc` method and requires the event</span>
<span class="sd">              object to have the `picks` attribute.</span>
<span class="sd">            - &#39;beam&#39;: Calls the `relocate_beam` method.</span>
<span class="sd">            Default is &#39;NLLoc&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The `relocate` function acts as a wrapper that allows for flexibility in</span>
<span class="sd">          choosing the relocation routine.</span>
<span class="sd">        - Depending on the specified `routine`, the function calls the corresponding</span>
<span class="sd">          relocation method with the provided arguments and keyword arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">routine</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;nlloc&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relocate_NLLoc</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">routine</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;beam&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relocate_beam</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Event.relocate_beam">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.relocate_beam">[docs]</a>
    <span class="k">def</span> <span class="nf">relocate_beam</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">beamformer</span><span class="p">,</span>
        <span class="n">duration</span><span class="o">=</span><span class="mf">60.0</span><span class="p">,</span>
        <span class="n">offset_ot</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">BUFFER_EXTRACTED_EVENTS_SEC</span><span class="p">,</span>
        <span class="n">phase_on_comp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">},</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
        <span class="n">waveform_features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">uncertainty_method</span><span class="o">=</span><span class="s2">&quot;spatial&quot;</span><span class="p">,</span>
        <span class="n">restricted_domain_side_km</span><span class="o">=</span><span class="mf">100.0</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use a Beamformer instance for backprojection to relocate the event.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        beamformer : BPMF.template_search.Beamformer</span>
<span class="sd">            Beamformer instance used for backprojection.</span>
<span class="sd">        duration : float, optional</span>
<span class="sd">            Duration, in seconds, of the extracted time windows. Default is 60.0 seconds.</span>
<span class="sd">        offset_ot : float, optional</span>
<span class="sd">            Time in seconds taken before the `origin_time`. Only used if `time_shifted` is False.</span>
<span class="sd">            Default is `cfg.BUFFER_EXTRACTED_EVENTS_SEC`.</span>
<span class="sd">        phase_on_comp : dict, optional</span>
<span class="sd">            Dictionary defining which seismic phase is extracted on each component.</span>
<span class="sd">            For example, `phase_on_comp[&#39;N&#39;]` gives the phase extracted on the north component.</span>
<span class="sd">            Default is `{&quot;N&quot;: &quot;S&quot;, &quot;1&quot;: &quot;S&quot;, &quot;E&quot;: &quot;S&quot;, &quot;2&quot;: &quot;S&quot;, &quot;Z&quot;: &quot;P&quot;}`.</span>
<span class="sd">        component_aliases : dict, optional</span>
<span class="sd">            Dictionary where each entry is a list of strings. `component_aliases[comp]`</span>
<span class="sd">            is the list of all aliases used for the same component &#39;comp&#39;. For example,</span>
<span class="sd">            `component_aliases[&#39;N&#39;] = [&#39;N&#39;, &#39;1&#39;]` means that both the &#39;N&#39; and &#39;1&#39; channels</span>
<span class="sd">            will be mapped to the Event&#39;s &#39;N&#39; channel. Default is `{&quot;N&quot;: [&quot;N&quot;, &quot;1&quot;],</span>
<span class="sd">            &quot;E&quot;: [&quot;E&quot;, &quot;2&quot;], &quot;Z&quot;: [&quot;Z&quot;]}`.</span>
<span class="sd">        waveform_features : numpy.ndarray, optional</span>
<span class="sd">            If not None, it must be a `(num_stations, num_channels, num_time_samples)`</span>
<span class="sd">            numpy.ndarray containing waveform features or characteristic functions</span>
<span class="sd">            that are backprojected onto the grid of theoretical seismic sources.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        restricted_domain_side_km : float, optional</span>
<span class="sd">            The location uncertainties are computed on the full 3D beam at the time when</span>
<span class="sd">            the 4D beam achieves its maximum over the `duration` seconds. To avoid having</span>
<span class="sd">            grid-size-dependent uncertainties, it is useful to truncate the domain around</span>
<span class="sd">            the location of the maximum beam. This parameter controls the size of the</span>
<span class="sd">            truncated domain. Default is 100.0 km.</span>
<span class="sd">        device : str, optional</span>
<span class="sd">            Device to be used for computation. Must be either &#39;cpu&#39; (default) or &#39;gpu&#39;.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The function updates the `origin_time`, `longitude`, `latitude`, and `depth`</span>
<span class="sd">          attributes of the event based on the maximum focusing of the beamformer.</span>
<span class="sd">        - Location uncertainties are estimated based on the computed likelihood,</span>
<span class="sd">          a restricted domain, and the location coordinates.</span>
<span class="sd">        - The estimated uncertainties can be accessed through the `Event`&#39;s</span>
<span class="sd">        properties `Event.hmax_unc`, `Event.hmin_unc`, `Event.vmax_unc`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.template_search</span> <span class="kn">import</span> <span class="n">Beamformer</span><span class="p">,</span> <span class="n">envelope</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;read_waveforms&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="n">waveform_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># read waveforms in picking mode, i.e. with `time_shifted`=False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span>
                <span class="n">duration</span><span class="p">,</span>
                <span class="n">offset_ot</span><span class="o">=</span><span class="n">offset_ot</span><span class="p">,</span>
                <span class="n">phase_on_comp</span><span class="o">=</span><span class="n">phase_on_comp</span><span class="p">,</span>
                <span class="n">component_aliases</span><span class="o">=</span><span class="n">component_aliases</span><span class="p">,</span>
                <span class="n">time_shifted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">waveform_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span>
                <span class="n">beamformer</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">norm</span><span class="p">[</span><span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">data_arr</span> <span class="o">/=</span> <span class="n">norm</span>
            <span class="n">waveform_features</span> <span class="o">=</span> <span class="n">envelope</span><span class="p">(</span><span class="n">data_arr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveform_features</span> <span class="o">=</span> <span class="n">waveform_features</span>
        <span class="c1"># print(waveform_features)</span>
        <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;out_of_bounds&quot;</span><span class="p">,</span> <span class="s2">&quot;flexible&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">uncertainty_method</span> <span class="o">==</span> <span class="s2">&quot;spatial&quot;</span><span class="p">:</span>
            <span class="n">reduce</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
        <span class="k">elif</span> <span class="n">uncertainty_method</span> <span class="o">==</span> <span class="s2">&quot;temporal&quot;</span><span class="p">:</span>
            <span class="n">reduce</span> <span class="o">=</span> <span class="s2">&quot;max&quot;</span>
        <span class="n">beamformer</span><span class="o">.</span><span class="n">backproject</span><span class="p">(</span>
            <span class="n">waveform_features</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">reduce</span><span class="o">=</span><span class="n">reduce</span><span class="p">,</span> <span class="n">out_of_bounds</span><span class="o">=</span><span class="n">out_of_bounds</span>
        <span class="p">)</span>
        <span class="c1"># find where the maximum focusing occurred</span>
        <span class="k">if</span> <span class="n">uncertainty_method</span> <span class="o">==</span> <span class="s2">&quot;spatial&quot;</span><span class="p">:</span>
            <span class="n">src_idx</span><span class="p">,</span> <span class="n">time_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span>
                <span class="n">beamformer</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">argmax</span><span class="p">(),</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">shape</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">uncertainty_method</span> <span class="o">==</span> <span class="s2">&quot;temporal&quot;</span><span class="p">:</span>
            <span class="n">time_idx</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">maxbeam</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
            <span class="n">src_idx</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">maxbeam_sources</span><span class="p">[</span><span class="n">time_idx</span><span class="p">]</span>
        <span class="c1"># update hypocenter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span> <span class="n">time_idx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">source_coordinates</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">src_idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">source_coordinates</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">src_idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">source_coordinates</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">src_idx</span><span class="p">]</span>
        <span class="c1"># estimate location uncertainty</span>
        <span class="k">if</span> <span class="n">uncertainty_method</span> <span class="o">==</span> <span class="s2">&quot;spatial&quot;</span><span class="p">:</span>
            <span class="c1"># 1) define a restricted domain</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">_rectangular_domain</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
                <span class="n">side_km</span><span class="o">=</span><span class="n">restricted_domain_side_km</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># 2) compute likelihood</span>
            <span class="n">likelihood</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">_likelihood</span><span class="p">(</span><span class="n">beamformer</span><span class="o">.</span><span class="n">beam</span><span class="p">[:,</span> <span class="n">time_idx</span><span class="p">])</span>
            <span class="n">likelihood_domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="k">elif</span> <span class="n">uncertainty_method</span> <span class="o">==</span> <span class="s2">&quot;temporal&quot;</span><span class="p">:</span>
            <span class="c1"># 1) likelihood is given by Gibbs distribution of maxbeam</span>
            <span class="n">effective_kT</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;effective_kT&quot;</span><span class="p">,</span> <span class="mf">0.33</span><span class="p">)</span>
            <span class="n">gibbs_cutoff</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gibbs_cutoff&quot;</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
            <span class="n">gibbs_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                <span class="o">-</span><span class="p">(</span><span class="n">beamformer</span><span class="o">.</span><span class="n">maxbeam</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">maxbeam</span><span class="p">)</span> <span class="o">/</span> <span class="n">effective_kT</span>
            <span class="p">)</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">maxbeam_sources</span><span class="p">[</span><span class="n">gibbs_weight</span> <span class="o">&gt;</span> <span class="n">gibbs_cutoff</span><span class="p">]</span>
            <span class="n">likelihood</span> <span class="o">=</span> <span class="n">gibbs_weight</span>
            <span class="n">likelihood_domain</span> <span class="o">=</span> <span class="n">gibbs_weight</span> <span class="o">&gt;</span> <span class="n">gibbs_cutoff</span>
        <span class="n">beamformer</span><span class="o">.</span><span class="n">likelihood</span> <span class="o">=</span> <span class="n">likelihood</span>
        <span class="c1"># 3) compute uncertainty</span>
        <span class="n">hunc</span><span class="p">,</span> <span class="n">vunc</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">_compute_location_uncertainty</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span>
            <span class="n">likelihood</span><span class="p">[</span><span class="n">likelihood_domain</span><span class="p">],</span>
            <span class="n">domain</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># 4) set attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hmax_unc</span> <span class="o">=</span> <span class="n">hunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hmin_unc</span> <span class="o">=</span> <span class="n">hunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmax_unc</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmin_unc</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vmax_unc</span> <span class="o">=</span> <span class="n">vunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;hmax_unc&quot;</span><span class="p">:</span> <span class="n">hunc</span><span class="p">,</span> <span class="s2">&quot;hmin_unc&quot;</span><span class="p">:</span> <span class="n">hunc</span><span class="p">,</span> <span class="s2">&quot;az_hmax_unc&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;vmax_unc&quot;</span><span class="p">:</span> <span class="n">vunc</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="c1"># fill arrival time attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">beamformer</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;P_tt_sec&quot;</span><span class="p">,</span>
                <span class="s2">&quot;P_abs_arrival_times&quot;</span><span class="p">,</span>
                <span class="s2">&quot;S_tt_sec&quot;</span><span class="p">,</span>
                <span class="s2">&quot;S_abs_arrival_times&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span>
        <span class="n">travel_times</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">moveouts</span><span class="p">[</span><span class="n">src_idx</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="n">beamformer</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="p">[</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">phases</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">beamformer</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">ph</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">beamformer</span><span class="o">.</span><span class="n">phases</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">travel_times</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_arrival_times&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span>
            <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Event.relocate_NLLoc">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.relocate_NLLoc">[docs]</a>
    <span class="k">def</span> <span class="nf">relocate_NLLoc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;EDT&quot;</span><span class="p">,</span>
        <span class="n">max_epicentral_dist_km_S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">cleanup_out_dir</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Relocate the event using NonLinLoc (NLLoc) based on the provided picks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stations : list of str, optional</span>
<span class="sd">            Names of the stations to include in the relocation process. If None,</span>
<span class="sd">            all stations in `self.stations` are used. Default is None.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Optimization algorithm used by NonLinLoc. Available options are:</span>
<span class="sd">            &#39;GAU_ANALYTIC&#39;, &#39;EDT&#39;, &#39;EDT_OT&#39;, &#39;EDT_OT_WT_ML&#39;. Refer to NonLinLoc&#39;s</span>
<span class="sd">            documentation for more details. Default is &#39;EDT&#39;.</span>
<span class="sd">        verbose : int, optional</span>
<span class="sd">            Verbosity level of NonLinLoc. If greater than 0, NonLinLoc&#39;s outputs</span>
<span class="sd">            are printed to the standard output. Default is 0.</span>
<span class="sd">        cleanup_out_dir : bool, optional</span>
<span class="sd">            If True, NLLoc&#39;s output files are deleted after reading the relevant</span>
<span class="sd">            information. Default is True.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments for `BPMF.NLLoc_utils.write_NLLoc_control`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The event&#39;s attributes, including the origin time and location, are updated.</span>
<span class="sd">        - The theoretical arrival times are attached to the event in `Event.arrival_times`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">subprocess</span>
        <span class="kn">import</span> <span class="nn">glob</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">NLLoc_utils</span>

        <span class="k">if</span> <span class="n">stations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span>
        <span class="c1"># create folder for input/output files</span>
        <span class="n">input_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_INPUT_PATH</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_OUTPUT_PATH</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">input_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">input_dir</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
        <span class="c1"># file names:</span>
        <span class="n">ctrl_fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="s2">&quot;.in&quot;</span><span class="p">)</span>
        <span class="n">out_basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="s2">&quot;_out&quot;</span><span class="p">)</span>
        <span class="n">obs_fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="s2">&quot;.obs&quot;</span><span class="p">)</span>
        <span class="c1"># exclude S picks on remote stations if requested</span>
        <span class="n">excluded_obs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_source_receiver_epicentral_dist&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">max_epicentral_dist_km_S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_receiver_epicentral_dist</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_receiver_epicentral_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span>
                    <span class="o">&gt;</span> <span class="n">max_epicentral_dist_km_S</span>
                <span class="p">):</span>
                    <span class="n">excluded_obs</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;S&quot;</span>
        <span class="c1"># write obs file</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_INPUT_PATH</span><span class="p">,</span> <span class="n">obs_fn</span><span class="p">)):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_INPUT_PATH</span><span class="p">,</span> <span class="n">obs_fn</span><span class="p">))</span>
        <span class="n">NLLoc_utils</span><span class="o">.</span><span class="n">write_NLLoc_obs</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="p">,</span>
            <span class="n">stations</span><span class="p">,</span>
            <span class="n">obs_fn</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># write control file</span>
        <span class="n">NLLoc_utils</span><span class="o">.</span><span class="n">write_NLLoc_control</span><span class="p">(</span>
            <span class="n">ctrl_fn</span><span class="p">,</span>
            <span class="n">out_basename</span><span class="p">,</span>
            <span class="n">obs_fn</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">excluded_obs</span><span class="o">=</span><span class="n">excluded_obs</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># run NLLoc</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;NLLoc </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_INPUT_PATH</span><span class="p">,</span><span class="w"> </span><span class="n">ctrl_fn</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&gt; </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">devnull</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># run NLLoc</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
                <span class="s2">&quot;NLLoc &quot;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_INPUT_PATH</span><span class="p">,</span> <span class="n">ctrl_fn</span><span class="p">),</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="c1"># read results</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out_fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span>
                <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_OUTPUT_PATH</span><span class="p">,</span> <span class="n">out_basename</span> <span class="o">+</span> <span class="s2">&quot;.[!s]*hyp&quot;</span><span class="p">)</span>
                <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># relocation failed</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)):</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">input_dir</span><span class="p">):</span>
                <span class="c1"># add this protection against unexpected</span>
                <span class="c1"># external change</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">input_dir</span><span class="p">)</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)):</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
                <span class="c1"># add this protection against unexpected</span>
                <span class="c1"># external change</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="n">hypocenter</span><span class="p">,</span> <span class="n">predicted_times</span> <span class="o">=</span> <span class="n">NLLoc_utils</span><span class="o">.</span><span class="n">read_NLLoc_outputs</span><span class="p">(</span>
            <span class="n">out_fn</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_OUTPUT_PATH</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">hypocenter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># problem when reading the output</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)):</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">input_dir</span><span class="p">):</span>
                <span class="c1"># add this protection against unexpected</span>
                <span class="c1"># external change</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">input_dir</span><span class="p">)</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)):</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
                <span class="c1"># add this protection against unexpected</span>
                <span class="c1"># external change</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="n">hypocenter</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">hypocenter</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">])</span>
        <span class="c1"># round seconds to reasonable precision to avoid producing</span>
        <span class="c1"># origin times that are in between samples</span>
        <span class="n">hypocenter</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">round_time</span><span class="p">(</span><span class="n">hypocenter</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># update event&#39;s attributes</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">hypocenter</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">hypocenter</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="c1"># add absolute arrival times to predicted_times</span>
        <span class="n">P_abs_arrivals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_times</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">S_abs_arrivals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_times</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predicted_times</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">P_abs_arrivals</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">predicted_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="s2">&quot;P_tt_sec&quot;</span><span class="p">]</span>
            <span class="n">S_abs_arrivals</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">predicted_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="s2">&quot;S_tt_sec&quot;</span><span class="p">]</span>
        <span class="n">predicted_times</span><span class="p">[</span><span class="s2">&quot;P_abs_arrival_times&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">P_abs_arrivals</span>
        <span class="n">predicted_times</span><span class="p">[</span><span class="s2">&quot;S_abs_arrival_times&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_abs_arrivals</span>
        <span class="c1"># attach the theoretical arrival times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span> <span class="o">=</span> <span class="n">predicted_times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">({</span><span class="s2">&quot;NLLoc_reloc&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">({</span><span class="s2">&quot;cov_mat&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span><span class="p">,</span> <span class="s2">&quot;tt_rms&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tt_rms</span><span class="p">})</span>
        <span class="c1"># clean the temporary control and pick files</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)):</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">input_dir</span><span class="p">):</span>
            <span class="c1"># add this protection against unexpected</span>
            <span class="c1"># external change</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">input_dir</span><span class="p">)</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cleanup_out_dir</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)):</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
                <span class="c1"># add this protection against unexpected</span>
                <span class="c1"># external change</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span></div>


<div class="viewcode-block" id="Event.remove_outlier_picks">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.remove_outlier_picks">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_outlier_picks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_diff_percent</span><span class="o">=</span><span class="mf">25.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove picks that are too far from the predicted arrival times.</span>

<span class="sd">        Picks that have a difference exceeding the specified threshold between the</span>
<span class="sd">        picked arrival time and the predicted arrival time are considered outliers</span>
<span class="sd">        and are removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_diff_percent : float, optional</span>
<span class="sd">            Maximum allowable difference, in percentage, between the picked and</span>
<span class="sd">            predicted arrival times. Picks with a difference greater than this</span>
<span class="sd">            threshold will be considered outliers and removed. Default is 25.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stations_outlier</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]):</span>
                    <span class="c1"># no valid pick, pass</span>
                    <span class="k">continue</span>
                <span class="n">pick</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]))</span>
                <span class="n">predicted</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_arrival_times&quot;</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">predicted_tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span><span class="p">]</span>
                <span class="c1"># use a minimum value for predicted_tt of a few samples</span>
                <span class="c1"># to avoid issues arising when using self.set_arrival_times_to_moveouts</span>
                <span class="c1"># because, by definition of a moveout, the min moveout is 0</span>
                <span class="n">predicted_tt</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">predicted_tt</span><span class="p">,</span> <span class="mi">5</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
                <span class="n">diff_percent</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mf">100.0</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">((</span><span class="n">pick</span> <span class="o">-</span> <span class="n">predicted</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span> <span class="o">/</span> <span class="n">predicted_tt</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">diff_percent</span> <span class="o">&gt;</span> <span class="n">max_diff_percent</span><span class="p">:</span>
                    <span class="n">stations_outlier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sta</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_probas&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>


<div class="viewcode-block" id="Event.remove_distant_stations">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.remove_distant_stations">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_distant_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_distance_km</span><span class="o">=</span><span class="mf">50.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove picks on stations that are further than a given distance.</span>

<span class="sd">        This function removes picks on stations that are located at a distance</span>
<span class="sd">        greater than the specified maximum distance. The distance between the source</span>
<span class="sd">        and each station is computed using the `source_receiver_dist` attribute.</span>
<span class="sd">        Picks on stations beyond the maximum distance are set to NaN.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_distance_km : float, optional</span>
<span class="sd">            Maximum distance, in kilometers, beyond which picks are considered to be</span>
<span class="sd">            on stations that are too distant. Picks on stations with a distance</span>
<span class="sd">            greater than this threshold will be set to NaN. Default is 50.0.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The function checks if the `source_receiver_dist` attribute is present in</span>
<span class="sd">          the object. If it is not available, an informative message is printed and</span>
<span class="sd">          the function returns.</span>
<span class="sd">        - For each station in `stations`, the distance between the source and the</span>
<span class="sd">          station is retrieved from the `source_receiver_dist` attribute.</span>
<span class="sd">        - If the distance of a station is greater than the specified maximum distance</span>
<span class="sd">          (`max_distance_km`), the picks associated with that station are set to NaN.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_receiver_dist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Call self.set_source_receiver_dist(network) before &quot;</span>
                <span class="s2">&quot;using self.remove_distant_stations.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_receiver_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_distance_km</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>


<div class="viewcode-block" id="Event.set_aux_data">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_aux_data">[docs]</a>
    <span class="k">def</span> <span class="nf">set_aux_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aux_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds any extra data to the Event instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        aux_data: dictionary</span>
<span class="sd">            Dictionary with any auxiliary data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">aux_data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux_data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span></div>


<div class="viewcode-block" id="Event.set_availability">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_availability">[docs]</a>
    <span class="k">def</span> <span class="nf">set_availability</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the data availability.</span>

<span class="sd">        A station is available if at least one station has non-zero data. The</span>
<span class="sd">        availability is then accessed via the property `self.availability`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        stations: list of strings or numpy.ndarray, default to None</span>
<span class="sd">            Names of the stations on which we check availability. If None, use</span>
<span class="sd">            `self.stations`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.read_waveforms` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_sta</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_cha</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">stations</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">components</span><span class="p">):</span>
            <span class="n">availability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stations</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">cp_alias</span> <span class="ow">in</span> <span class="n">component_aliases</span><span class="p">[</span><span class="n">cp</span><span class="p">]:</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">cp_alias</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">):</span>
                        <span class="n">availability</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_cha</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span> <span class="o">=</span> <span class="n">availability</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_sta</span><span class="p">,</span> <span class="n">availability</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;availability&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_sta</span><span class="p">,</span>
                <span class="s2">&quot;availability_per_sta&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_sta</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span>
            <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;availability_</span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_cha</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span> <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">components</span><span class="p">}</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Event.set_components">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_components">[docs]</a>
    <span class="k">def</span> <span class="nf">set_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">components</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the list of components.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        components: list of strings</span>
<span class="sd">            The names of the components on which the `Template` instance will</span>
<span class="sd">            work after this call to `self.set_components`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">components</span></div>


<div class="viewcode-block" id="Event.set_component_aliases">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_component_aliases">[docs]</a>
    <span class="k">def</span> <span class="nf">set_component_aliases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component_aliases</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set or modify the `component_aliases` attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        component_aliases: Dictionary</span>
<span class="sd">            Each entry of the dictionary is a list of strings.</span>
<span class="sd">            `component_aliases[comp]` is the list of all aliases used for</span>
<span class="sd">            the same component &#39;comp&#39;. For example, `component_aliases[&#39;N&#39;] =</span>
<span class="sd">            [&#39;N&#39;, &#39;1&#39;]` means that both the &#39;N&#39; and &#39;1&#39; channels will be mapped</span>
<span class="sd">            to the Event&#39;s &#39;N&#39; channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span> <span class="o">=</span> <span class="n">component_aliases</span></div>


<div class="viewcode-block" id="Event.set_arrival_times_from_moveouts">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_arrival_times_from_moveouts">[docs]</a>
    <span class="k">def</span> <span class="nf">set_arrival_times_from_moveouts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build arrival times assuming at = ot + mv.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Make sure origin_time + moveout points at the phase arrival!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_abs_arrival_times&quot;</span> <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
            <span class="n">ph</span> <span class="o">=</span> <span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">field1</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_arrival_times&quot;</span>
            <span class="n">field2</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span>
            <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="n">field1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="n">field2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">]</span></div>


<div class="viewcode-block" id="Event.set_moveouts_to_empirical_times">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_moveouts_to_empirical_times">[docs]</a>
    <span class="k">def</span> <span class="nf">set_moveouts_to_empirical_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set moveouts equal to picks, if available.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;picks&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Does not have a `picks` attribute.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># make sure picks are consistent with the current origin time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_picks</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">round_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                        <span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">round_time</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">],</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span>
                    <span class="p">)</span></div>


<div class="viewcode-block" id="Event.set_moveouts_to_theoretical_times">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_moveouts_to_theoretical_times">[docs]</a>
    <span class="k">def</span> <span class="nf">set_moveouts_to_theoretical_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set moveouts equal to theoretical arrival times, if available.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;arrival_times&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Does not have a `arrival_times` attribute.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># make sure travel times are consistent with the current origin time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_travel_times</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">round_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                        <span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">round_time</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span><span class="p">],</span>
                        <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">,</span>
                    <span class="p">)</span></div>


<div class="viewcode-block" id="Event.set_source_receiver_dist">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_source_receiver_dist">[docs]</a>
    <span class="k">def</span> <span class="nf">set_source_receiver_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set source-receiver distances using the provided `network`.</span>

<span class="sd">        This function calculates the hypocentral and epicentral distances between</span>
<span class="sd">        the event&#39;s source location and the stations in the given network. It</span>
<span class="sd">        stores the distances as attributes of the event object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        network : dataset.Network</span>
<span class="sd">            The `Network` instance containing the station coordinates to use in</span>
<span class="sd">            the source-receiver distance calculation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The function uses the `BPMF.utils.compute_distances` function to compute</span>
<span class="sd">          both hypocentral and epicentral distances between the event&#39;s source</span>
<span class="sd">          location and the stations in the network.</span>
<span class="sd">        - The computed distances can be accessed with the `Event`&#39;s properties</span>
<span class="sd">        `Event.source_receiver_dist` and `Event.source_receiver_epicentral_dist`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hypocentral_distances</span><span class="p">,</span> <span class="n">epicentral_distances</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">compute_distances</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">],</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">],</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">],</span>
            <span class="n">network</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
            <span class="n">network</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
            <span class="n">network</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span>
            <span class="n">return_epicentral_distances</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_receiver_dist</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">hypocentral_distances</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;source-receiver hypocentral distance (km)&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_receiver_epicentral_dist</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">epicentral_distances</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;source-receiver epicentral distance (km)&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;network_stations&quot;</span><span class="p">):</span>
            <span class="c1"># self.network_stations = self.stations.copy() # why this line?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">stations</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_receiver_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_receiver_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_receiver_epicentral_dist</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source_receiver_epicentral_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Event.trim_waveforms">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.trim_waveforms">[docs]</a>
    <span class="k">def</span> <span class="nf">trim_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trim waveforms to a specified time window.</span>

<span class="sd">        This function trims the waveforms in the event&#39;s `traces` attribute to the</span>
<span class="sd">        specified time window. It ensures that all traces have the same start time</span>
<span class="sd">        by adjusting the start time if necessary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        starttime : str or datetime, optional</span>
<span class="sd">            The start time of the desired time window. If None, the event&#39;s `date`</span>
<span class="sd">            attribute is used as the start time. Default is None.</span>
<span class="sd">        endtime : str or datetime, optional</span>
<span class="sd">            The end time of the desired time window. If None, the end time is set</span>
<span class="sd">            as `self.date` + `self.duration`, where `self.date` is the event&#39;s date</span>
<span class="sd">            attribute and `self.duration` is the event&#39;s duration attribute.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You should call `read_waveforms` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">starttime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span>
        <span class="k">if</span> <span class="n">endtime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span>
                <span class="n">starttime</span><span class="o">=</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">endtime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Event.update_picks">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.update_picks">[docs]</a>
    <span class="k">def</span> <span class="nf">update_picks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the picks with respect to the current origin time.</span>

<span class="sd">        This function updates the picks of each station with respect to the current</span>
<span class="sd">        origin time of the event. It computes the relative pick times by subtracting</span>
<span class="sd">        the origin time from the absolute pick times and update the</span>
<span class="sd">        `picks` attribute of the event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;picks&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Does not have a `picks` attribute.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]):</span>
                    <span class="k">continue</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span>
                    <span class="n">udt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">])</span>
                    <span class="o">-</span> <span class="n">udt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="p">)</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="Event.update_travel_times">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.update_travel_times">[docs]</a>
    <span class="k">def</span> <span class="nf">update_travel_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the travel times with respect to the current origin time.</span>

<span class="sd">        This function updates the travel times of each station and phase with respect</span>
<span class="sd">        to the current origin time of the event. It adjusts the propagation times</span>
<span class="sd">        by subtracting the origin time from the absolute times and update the</span>
<span class="sd">        `arrival_times` attribute of the event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;arrival_times&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Does not have an `arrival_times` attribute.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_abs_arrival_times&quot;</span><span class="p">]</span>
                <span class="p">)</span> <span class="o">-</span> <span class="n">udt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="p">)</span></div>


<div class="viewcode-block" id="Event.update_aux_data_database">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.update_aux_data_database">[docs]</a>
    <span class="k">def</span> <span class="nf">update_aux_data_database</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the auxiliary data in the database with new elements from `self.aux_data`.</span>

<span class="sd">        This function adds new elements from the `self.aux_data` attribute to the database</span>
<span class="sd">        located at `path_database`. If the element already exists in the database</span>
<span class="sd">        and `overwrite` is False, it skips the element. If `overwrite` is True, it</span>
<span class="sd">        overwrites the existing data in the database with the new data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If True, overwrite existing data in the database. If False (default),</span>
<span class="sd">            skip existing elements and do not modify the database.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If any error occurs during the process, the function removes the lock file and</span>
<span class="sd">          raises the exception.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Exception</span>
<span class="sd">            If an error occurs while updating the database, the function raises the</span>
<span class="sd">            exception after removing the lock file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;path_database&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It looks like you have created this Event instance from scratch...&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call Event.write instead.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">lock_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_database</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.lock&quot;</span>
        <span class="k">while</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">lock_file</span><span class="p">):</span>
            <span class="c1"># another process is already writing in this file</span>
            <span class="c1"># wait a bit a check again</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
        <span class="c1"># create empty lock file</span>
        <span class="nb">open</span><span class="p">(</span><span class="n">lock_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_database</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fdb</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;hdf5_gid&quot;</span><span class="p">):</span>
                    <span class="n">fdb</span> <span class="o">=</span> <span class="n">fdb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf5_gid</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fdb</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
                        <span class="c1"># already exists</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fdb</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">overwrite</span><span class="p">:</span>
                        <span class="c1"># overwrite it</span>
                        <span class="k">del</span> <span class="n">fdb</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">]</span>
                    <span class="n">fdb</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">lock_file</span><span class="p">)</span>
            <span class="k">raise</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="c1"># remove lock file</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">lock_file</span><span class="p">)</span></div>


<div class="viewcode-block" id="Event.zero_out_clipped_waveforms">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.zero_out_clipped_waveforms">[docs]</a>
    <span class="k">def</span> <span class="nf">zero_out_clipped_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kurtosis_threshold</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find waveforms with anomalous statistic and zero them out.</span>

<span class="sd">        This function identifies waveforms with a kurtosis value below the specified</span>
<span class="sd">        threshold as anomalous and zeros out their data. The kurtosis of a waveform</span>
<span class="sd">        is a measure of its statistical distribution, with a value of 0 indicating a</span>
<span class="sd">        Gaussian distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kurtosis_threshold : float, optional</span>
<span class="sd">            Threshold below which the kurtosis is considered anomalous. Waveforms</span>
<span class="sd">            with a kurtosis value lower than this threshold will have their data</span>
<span class="sd">            zeroed out. Default is -1.0.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This is an oversimplified technique to find clipped waveforms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">kurtosis</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kurtosis</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">kurtosis_threshold</span><span class="p">:</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>


    <span class="c1"># -----------------------------------------------------------</span>
    <span class="c1">#               write method</span>
    <span class="c1"># -----------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_write</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db_filename</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">OUTPUT_PATH</span><span class="p">,</span>
        <span class="n">save_waveforms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">hdf5_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `Event.write`.&quot;&quot;&quot;</span>
        <span class="n">output_where</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">db_filename</span><span class="p">)</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;origin_time&quot;</span><span class="p">,</span>
            <span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
            <span class="s2">&quot;longitude&quot;</span><span class="p">,</span>
            <span class="s2">&quot;depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;moveouts&quot;</span><span class="p">,</span>
            <span class="s2">&quot;stations&quot;</span><span class="p">,</span>
            <span class="s2">&quot;components&quot;</span><span class="p">,</span>
            <span class="s2">&quot;phases&quot;</span><span class="p">,</span>
            <span class="s2">&quot;where&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sampling_rate&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="c1"># moveouts&#39; indexes may have been re-ordered</span>
        <span class="c1"># because writing moveouts as an array will forget about the current</span>
        <span class="c1"># row indexes and assume that they are in the same order as</span>
        <span class="c1"># self.stations, it is critical to make sure this is true</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">hdf5_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdf5_file</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">output_where</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">gid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gid</span> <span class="ow">in</span> <span class="n">hdf5_file</span><span class="p">:</span>
                <span class="c1"># overwrite existing detection with same id</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found existing event </span><span class="si">{</span><span class="n">gid</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">output_where</span><span class="si">}</span><span class="s2">. Overwrite it.&quot;</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">hdf5_file</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span>
            <span class="n">hdf5_file</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">hdf5_file</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">hdf5_file</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">attr_</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;origin_time&quot;</span><span class="p">:</span>
                <span class="n">attr_</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">attr_</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr_</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">attr_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">attr_</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">attr_</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">kind</span>
            <span class="p">):</span>
                <span class="n">attr_</span> <span class="o">=</span> <span class="n">attr_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">attr_</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;aux_data&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="n">f</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">key2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                        <span class="n">f</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                            <span class="n">key2</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">key2</span><span class="p">]</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;picks&quot;</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;picks&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[</span><span class="s2">&quot;picks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span>
                    <span class="c1"># pandas datetime format</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S.</span><span class="si">%f</span><span class="s2"> %z&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;picks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;arrival_times&quot;</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;arrival_times&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[</span><span class="s2">&quot;arrival_times&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span>
                    <span class="c1"># pandas datetime format</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S.</span><span class="si">%f</span><span class="s2"> %z&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;arrival_times&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_waveforms</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;waveforms&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
                    <span class="n">sta</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span>
                    <span class="n">cha</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span>
                    <span class="k">if</span> <span class="n">sta</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">]:</span>
                        <span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">sta</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cha</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sta</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">cha</span><span class="si">}</span><span class="s2"> already exists!&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">cha</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;You are trying to save the waveforms whereas you did&quot;</span>
                    <span class="s2">&quot; not read them!&quot;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
            <span class="n">hdf5_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<div class="viewcode-block" id="Event.write">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.write">[docs]</a>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db_filename</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">OUTPUT_PATH</span><span class="p">,</span>
        <span class="n">save_waveforms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">hdf5_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the event information to an HDF5 file.</span>

<span class="sd">        This function writes the event information, including waveform data if</span>
<span class="sd">        specified, to an HDF5 file. The event information is stored in a specific</span>
<span class="sd">        group within the file. The function uses the `h5py` module to interact</span>
<span class="sd">        with the HDF5 file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        db_filename : str</span>
<span class="sd">            Name of the HDF5 file storing the event information.</span>
<span class="sd">        db_path : str, optional</span>
<span class="sd">            Path to the directory where the HDF5 file is located. Defaults to</span>
<span class="sd">            `cfg.OUTPUT_PATH`.</span>
<span class="sd">        save_waveforms : bool, optional</span>
<span class="sd">            If True, save the waveform data associated with the event in the HDF5</span>
<span class="sd">            file. Defaults to False.</span>
<span class="sd">        gid : str, optional</span>
<span class="sd">            Name of the HDF5 group where the event will be stored. If `gid` is None,</span>
<span class="sd">            the event is stored directly at the root of the HDF5 file. Defaults to</span>
<span class="sd">            None.</span>
<span class="sd">        hdf5_file : h5py.File, optional</span>
<span class="sd">            An opened HDF5 file object pointing directly to the subfolder of</span>
<span class="sd">            interest. If provided, the `db_path` parameter is ignored. Defaults to</span>
<span class="sd">            None.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The function uses the `read_write_waiting_list` function from the `utils`</span>
<span class="sd">          module to handle the writing operation in a thread-safe manner. The actual</span>
<span class="sd">          writing is performed by the `_write` method, which is called with the</span>
<span class="sd">          appropriate parameters.</span>
<span class="sd">        - The `read_write_waiting_list` function handles the synchronization and</span>
<span class="sd">          queueing of write operations to avoid conflicts when multiple processes</span>
<span class="sd">          try to write to the same file simultaneously. The function waits for a</span>
<span class="sd">          lock before executing the `func` partial function, which performs the</span>
<span class="sd">          actual writing operation. **BUT** the queueing is still not bullet-proof.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

        <span class="n">func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">,</span>
            <span class="n">db_path</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">save_waveforms</span><span class="o">=</span><span class="n">save_waveforms</span><span class="p">,</span>
            <span class="n">gid</span><span class="o">=</span><span class="n">gid</span><span class="p">,</span>
            <span class="n">hdf5_file</span><span class="o">=</span><span class="n">hdf5_file</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">read_write_waiting_list</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">db_filename</span><span class="p">))</span></div>


    <span class="c1"># -----------------------------------------------------------</span>
    <span class="c1">#            plotting method(s)</span>
    <span class="c1"># -----------------------------------------------------------</span>

<div class="viewcode-block" id="Event.plot">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
        <span class="n">gain</span><span class="o">=</span><span class="mf">1.0e6</span><span class="p">,</span>
        <span class="n">stations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;Velocity ($\mu$m/s)&quot;</span><span class="p">,</span>
        <span class="n">plot_picks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">plot_predicted_arrivals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">plot_probabilities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the waveforms of the Event instance.</span>

<span class="sd">        This function plots the waveforms associated with the Event instance. The</span>
<span class="sd">        waveforms are plotted as subplots, with each subplot representing a station</span>
<span class="sd">        and component combination. The start and end times of the waveforms are</span>
<span class="sd">        determined to set the x-axis limits of each subplot. The picks and theoretical</span>
<span class="sd">        arrival times associated with the Event are overlaid on the waveforms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            The figure size in inches, specified as a tuple (width, height). Defaults</span>
<span class="sd">            to (20, 15).</span>
<span class="sd">        gain : float, optional</span>
<span class="sd">            The gain factor applied to the waveform data before plotting. Defaults to</span>
<span class="sd">            1.0e6.</span>
<span class="sd">        stations : list of str, optional</span>
<span class="sd">            The list of station names for which to plot the waveforms. If None, all</span>
<span class="sd">            stations associated with the Event are plotted. Defaults to None.</span>
<span class="sd">        ylabel : str, optional</span>
<span class="sd">            The label for the y-axis. Defaults to r&quot;Velocity ($\mu$m/s).</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments that are passed to the matplotlib plot</span>
<span class="sd">            function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.figure.Figure</span>
<span class="sd">            The Figure instance produced by this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">matplotlib.dates</span> <span class="k">as</span> <span class="nn">mdates</span>

        <span class="k">if</span> <span class="n">stations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span>
        <span class="n">start_times</span><span class="p">,</span> <span class="n">end_times</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span>
            <span class="n">num</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;event_</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
            <span class="n">nrows</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">),</span>
            <span class="n">ncols</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">pick_colors</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="s2">&quot;C0&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="s2">&quot;C3&quot;</span><span class="p">}</span>
        <span class="n">predicted_arrival_colors</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="s2">&quot;C4&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="s2">&quot;C1&quot;</span><span class="p">}</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Event at </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">cp_alias</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span><span class="p">[</span><span class="n">cp</span><span class="p">]:</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">cp_alias</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># succesfully retrieved data</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">time_range</span><span class="p">(</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="o">+</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span>
                    <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;ms&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">start_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">end_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># channel-specific num_samples</span>
                <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="n">time</span><span class="p">[:</span><span class="n">num_samples</span><span class="p">],</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="n">num_samples</span><span class="p">]</span> <span class="o">*</span> <span class="n">gain</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">]:</span>
                    <span class="c1"># plot the P-/S-wave ML probabilities</span>
                    <span class="k">if</span> <span class="n">plot_probabilities</span><span class="p">:</span>
                        <span class="n">axb</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
                        <span class="n">ylim</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
                        <span class="n">axb</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.05</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mf">1.05</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">plot_probabilities</span>
                        <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;probability_time_series&quot;</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probability_time_series</span><span class="p">[</span><span class="n">ph</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="n">selection</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probability_times</span> <span class="o">&gt;=</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">probability_times</span> <span class="o">&lt;=</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="n">axb</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">probability_times</span><span class="p">[</span><span class="n">selection</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">probability_time_series</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="n">ph</span><span class="p">][</span><span class="n">selection</span><span class="p">],</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">pick_colors</span><span class="p">[</span><span class="n">ph</span><span class="p">],</span>
                            <span class="n">lw</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="c1"># plot the picks</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">plot_picks</span>
                        <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;picks&quot;</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ph_pick</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">])</span>
                        <span class="p">):</span>
                            <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">ph_pick</span><span class="p">),</span>
                                <span class="n">color</span><span class="o">=</span><span class="n">pick_colors</span><span class="p">[</span><span class="n">ph</span><span class="p">],</span>
                                <span class="n">lw</span><span class="o">=</span><span class="mf">1.00</span><span class="p">,</span>
                                <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_unc_sec&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="p">:</span>
                                <span class="n">unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_unc_sec&quot;</span><span class="p">]</span>
                                <span class="p">)[</span><span class="n">i</span><span class="p">]</span>
                                <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">fill_betweenx</span><span class="p">(</span>
                                    <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">(),</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">udt</span><span class="p">(</span><span class="n">ph_pick</span><span class="p">)</span> <span class="o">-</span> <span class="n">unc</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">),</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">udt</span><span class="p">(</span><span class="n">ph_pick</span><span class="p">)</span> <span class="o">+</span> <span class="n">unc</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">),</span>
                                    <span class="n">color</span><span class="o">=</span><span class="n">pick_colors</span><span class="p">[</span><span class="n">ph</span><span class="p">],</span>
                                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
                                <span class="p">)</span>
                    <span class="c1"># plot the theoretical arrival times</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">plot_predicted_arrivals</span>
                        <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;arrival_times&quot;</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="n">ph_pick</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_arrival_times&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span>
                            <span class="n">ph_pick</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">predicted_arrival_colors</span><span class="p">[</span><span class="n">ph</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.25</span>
                        <span class="p">)</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
                    <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sta</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">cp_alias</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">transAxes</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">flatten</span><span class="p">():</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">start_times</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">end_times</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span>
                <span class="n">mdates</span><span class="o">.</span><span class="n">ConciseDateFormatter</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_major_locator</span><span class="p">())</span>
            <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">top</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.06</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mf">0.98</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mf">0.06</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.40</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>
</div>



<div class="viewcode-block" id="Template">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template">[docs]</a>
<span class="k">class</span> <span class="nc">Template</span><span class="p">(</span><span class="n">Event</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for template events.</span>

<span class="sd">    The Template class is a subclass of the Event class and is specifically designed</span>
<span class="sd">    for template events. It inherits all the attributes and methods of the Event</span>
<span class="sd">    class and adds additional functionality specific to template events.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    origin_time : str or datetime</span>
<span class="sd">        The origin time of the template event. Can be specified as a string in</span>
<span class="sd">        ISO 8601 format or as a datetime object.</span>
<span class="sd">    moveouts : pandas.DataFrame</span>
<span class="sd">        The moveout table containing the travel time information for the template</span>
<span class="sd">        event. The moveouts table should have the following columns: &#39;Phase&#39;, &#39;Station&#39;,</span>
<span class="sd">        &#39;Distance&#39;, and &#39;TravelTime&#39;.</span>
<span class="sd">    stations : list of str</span>
<span class="sd">        The list of station names associated with the template event.</span>
<span class="sd">    phases : list of str</span>
<span class="sd">        The list of phase names associated with the template event.</span>
<span class="sd">    template_filename : str</span>
<span class="sd">        The filename of the template waveform file.</span>
<span class="sd">    template_path : str</span>
<span class="sd">        The path to the directory containing the template waveform file.</span>
<span class="sd">    latitude : float or None, optional</span>
<span class="sd">        The latitude of the template event in decimal degrees. If None, latitude</span>
<span class="sd">        information is not provided. Defaults to None.</span>
<span class="sd">    longitude : float or None, optional</span>
<span class="sd">        The longitude of the template event in decimal degrees. If None, longitude</span>
<span class="sd">        information is not provided. Defaults to None.</span>
<span class="sd">    depth : float or None, optional</span>
<span class="sd">        The depth of the template event in kilometers. If None, depth information</span>
<span class="sd">        is not provided. Defaults to None.</span>
<span class="sd">    sampling_rate : float or None, optional</span>
<span class="sd">        The sampling rate of the template waveforms in Hz. If None, the sampling</span>
<span class="sd">        rate is not provided. Defaults to None.</span>
<span class="sd">    components : list of str, optional</span>
<span class="sd">        The list of component names associated with the template waveforms.</span>
<span class="sd">        Defaults to [&#39;N&#39;, &#39;E&#39;, &#39;Z&#39;].</span>
<span class="sd">    id : str or None, optional</span>
<span class="sd">        The ID of the template event. If None, no ID is assigned. Defaults to None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">origin_time</span><span class="p">,</span>
        <span class="n">moveouts</span><span class="p">,</span>
        <span class="n">stations</span><span class="p">,</span>
        <span class="n">phases</span><span class="p">,</span>
        <span class="n">template_filename</span><span class="p">,</span>
        <span class="n">template_path</span><span class="p">,</span>
        <span class="n">latitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">longitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
        <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">origin_time</span><span class="p">,</span>
            <span class="n">moveouts</span><span class="p">,</span>
            <span class="n">stations</span><span class="p">,</span>
            <span class="n">phases</span><span class="p">,</span>
            <span class="n">template_filename</span><span class="p">,</span>
            <span class="n">template_path</span><span class="p">,</span>
            <span class="n">latitude</span><span class="o">=</span><span class="n">latitude</span><span class="p">,</span>
            <span class="n">longitude</span><span class="o">=</span><span class="n">longitude</span><span class="p">,</span>
            <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># network_stations is a copy of the original list of stations</span>
        <span class="c1"># self.stations may change if the user wants to use the template</span>
        <span class="c1"># on a subset of stations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="Template.init_from_event">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.init_from_event">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">init_from_event</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">attach_waveforms</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiate a Template object from an Event object.</span>

<span class="sd">        This class method creates a Template object based on an existing Event object.</span>
<span class="sd">        It converts the Event object into a Template object by transferring the relevant</span>
<span class="sd">        attributes and data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        event : Event instance</span>
<span class="sd">            The Event instance to convert to a Template instance.</span>
<span class="sd">        attach_waveforms : boolean, optional</span>
<span class="sd">            Specifies whether to attach the waveform data to the Template instance.</span>
<span class="sd">            If True, the waveform data is attached. If False, the waveform data is not</span>
<span class="sd">            attached. Defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        template : Template instance</span>
<span class="sd">            The Template instance based on the provided Event instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">db_path</span><span class="p">,</span> <span class="n">db_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
        <span class="n">template</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">event</span><span class="o">.</span><span class="n">origin_time</span><span class="p">,</span>
            <span class="n">event</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">event</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">event</span><span class="o">.</span><span class="n">phases</span><span class="p">,</span>
            <span class="n">db_filename</span><span class="p">,</span>
            <span class="n">db_path</span><span class="p">,</span>
            <span class="n">latitude</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
            <span class="n">longitude</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
            <span class="n">depth</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s2">&quot;picks&quot;</span><span class="p">):</span>
            <span class="n">template</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">picks</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s2">&quot;arrival_times&quot;</span><span class="p">):</span>
            <span class="n">template</span><span class="o">.</span><span class="n">arrival_times</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">arrival_times</span>
        <span class="n">aux_data_to_keep</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;offset_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">event</span><span class="o">.</span><span class="n">phases</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
            <span class="s2">&quot;tid&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cov_mat&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Mw&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Mw_err&quot;</span><span class="p">,</span>
            <span class="s2">&quot;hmax_unc&quot;</span><span class="p">,</span>
            <span class="s2">&quot;hmin_unc&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vmax_unc&quot;</span><span class="p">,</span>
            <span class="s2">&quot;az_hmax_unc&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">select</span> <span class="o">=</span> <span class="k">lambda</span> <span class="nb">str</span><span class="p">:</span> <span class="nb">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;phase_on_comp&quot;</span><span class="p">)</span>
        <span class="n">aux_data_to_keep</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">select</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">aux_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">select</span> <span class="o">=</span> <span class="k">lambda</span> <span class="nb">str</span><span class="p">:</span> <span class="nb">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;snr&quot;</span><span class="p">)</span>
        <span class="n">aux_data_to_keep</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">select</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">aux_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">aux_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">event</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">aux_data_to_keep</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">event</span><span class="o">.</span><span class="n">aux_data</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">attach_waveforms</span><span class="p">:</span>
            <span class="c1"># ----------------------------------</span>
            <span class="c1"># attach traces</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;You need to call `event.read_waveforms` before instanciating&quot;</span>
                    <span class="s2">&quot; a Template object with this Event instance.&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span>
            <span class="n">template</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">traces</span>
            <span class="n">template</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">n_samples</span>
            <span class="n">template</span><span class="o">.</span><span class="n">set_availability</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">template</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;n_samples&quot;</span><span class="p">]</span>
        <span class="c1"># ----------------------------------</span>
        <span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;n_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">n_samples</span>
        <span class="k">if</span> <span class="s2">&quot;cov_mat&quot;</span> <span class="ow">in</span> <span class="n">aux_data</span><span class="p">:</span>
            <span class="n">template</span><span class="o">.</span><span class="n">cov_mat</span> <span class="o">=</span> <span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;cov_mat&quot;</span><span class="p">]</span>
        <span class="n">template</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span><span class="n">aux_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">template</span></div>


<div class="viewcode-block" id="Template.read_from_file">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.read_from_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">INPUT_PATH</span><span class="p">,</span> <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a Template instance from a file.</span>

<span class="sd">        This class method reads a file and initializes a Template instance based on the</span>
<span class="sd">        content of the file. It utilizes the Event class method `read_from_file` to</span>
<span class="sd">        read the file and convert it into an Event instance. The Event instance is then</span>
<span class="sd">        converted into a Template instance using the `init_from_event` class method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            The name of the file to read and initialize the Template instance.</span>
<span class="sd">        db_path : str, optional</span>
<span class="sd">            The path to the directory containing the file. Defaults to cfg.INPUT_PATH.</span>
<span class="sd">        gid : str, optional</span>
<span class="sd">            The name of the hdf5 group where the file is stored. Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        template : Template instance</span>
<span class="sd">            The Template instance initialized from the specified file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">init_from_event</span><span class="p">(</span>
            <span class="n">Event</span><span class="o">.</span><span class="n">read_from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">db_path</span><span class="o">=</span><span class="n">db_path</span><span class="p">,</span> <span class="n">gid</span><span class="o">=</span><span class="n">gid</span><span class="p">),</span>
            <span class="n">attach_waveforms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">template</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;n_samples&quot;</span><span class="p">]</span>
        <span class="n">template</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;tid&quot;</span><span class="p">])</span>
        <span class="c1"># overwrite any path that was stored in aux_data, because what matters</span>
        <span class="c1"># for the template is only the file it was associated with</span>
        <span class="n">template</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">template</span></div>


    <span class="c1"># properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">template_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">moveouts_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a moveout array given self.components and phase_on_comp.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moveouts_win</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">][</span>
                <span class="p">[</span>
                    <span class="sa">f</span><span class="s1">&#39;moveouts_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;phase_on_comp</span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
                <span class="p">]</span>
            <span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">moveouts_win</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_moveouts_win&quot;</span><span class="p">):</span>
            <span class="c1"># this new moveout table store the moveouts of the</span>
            <span class="c1"># time windows rather than the phases</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_moveouts_win</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_moveouts_win</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;offset_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moveouts_win</span>

    <span class="c1"># methods</span>
<div class="viewcode-block" id="Template.distance">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.distance">[docs]</a>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the distance between the template and a given location.</span>

<span class="sd">        This function calculates the distance between the longitude, latitude, and depth</span>
<span class="sd">        of the template and the longitude, latitude, and depth of a target location using</span>
<span class="sd">        the `two_point_distance` function from the `utils` module.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        longitude : float</span>
<span class="sd">            The longitude of the target location.</span>
<span class="sd">        latitude : float</span>
<span class="sd">            The latitude of the target location.</span>
<span class="sd">        depth : float</span>
<span class="sd">            The depth of the target location in kilometers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        distance : float</span>
<span class="sd">            The distance, in kilometers, between the template and the target location.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">two_point_distance</span>

        <span class="k">return</span> <span class="n">two_point_distance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">depth</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Template.find_monochromatic_traces">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.find_monochromatic_traces">[docs]</a>
    <span class="k">def</span> <span class="nf">find_monochromatic_traces</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">autocorr_peak_threshold</span><span class="o">=</span><span class="mf">0.33</span><span class="p">,</span>
        <span class="n">num_peaks_criterion</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">taper_pct</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
        <span class="n">max_lag_samp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect traces in seismic waveforms with dominant monochromatic signals.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        autocorr_peak_threshold : float, optional</span>
<span class="sd">            Threshold for peak detection in the autocorrelation function.</span>
<span class="sd">            Default is 0.33.</span>
<span class="sd">        num_peaks_criterion : int, optional</span>
<span class="sd">            Minimum number of peaks required above the threshold for a trace</span>
<span class="sd">            to be considered monochromatic. Default is 5.</span>
<span class="sd">        taper_pct : float, optional</span>
<span class="sd">            Percentage of the signal to taper at both ends using a Tukey</span>
<span class="sd">            window function. Default is 5.0.</span>
<span class="sd">        max_lag_samp : int or None, optional</span>
<span class="sd">            Maximum lag samples to consider in the autocorrelation function.</span>
<span class="sd">            If None, uses the entire autocorrelation. Default is None.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If True, displays a warning about the experimental nature of</span>
<span class="sd">            the method. Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        monochromatic : pandas.DataFrame</span>
<span class="sd">            A DataFrame indicating whether each trace is monochromatic or not.</span>
<span class="sd">            Rows represent stations and columns represent components.</span>
<span class="sd">        num_peaks_above_threshold : pandas.DataFrame</span>
<span class="sd">            A DataFrame containing the number of peaks above the threshold</span>
<span class="sd">            for each trace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">find_peaks</span>
        <span class="kn">from</span> <span class="nn">scipy.signal.windows</span> <span class="kn">import</span> <span class="n">tukey</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;This is a highly experimental method!&quot;</span><span class="p">)</span>

        <span class="n">taper_window</span> <span class="o">=</span> <span class="n">tukey</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">taper_pct</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">)</span>

        <span class="n">num_peaks_above_threshold</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="p">)</span>
        <span class="n">monochromatic</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cha</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">x_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">taper_window</span><span class="p">)</span>
                <span class="n">autocorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">x_fft</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">x_fft</span><span class="p">))</span>
                <span class="c1"># re-order cross-corr (autocorr[len(autocorr)//2] is x-corr at lag 0, by construction)</span>
                <span class="c1"># autocorr = np.hstack( (autocorr[len(autocorr)//2:], autocorr[:len(autocorr)//2]) )</span>
                <span class="n">autocorr</span> <span class="o">=</span> <span class="n">autocorr</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">autocorr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">max_lag_samp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">autocorr</span> <span class="o">=</span> <span class="n">autocorr</span><span class="p">[:</span><span class="n">max_lag_samp</span><span class="p">]</span>
                    <span class="c1"># lag_0_index = len(autocorr) // 2</span>
                    <span class="c1"># autocorr = autocorr[lag_0_index - max_lag_samp : lag_0_index + max_lag_samp]</span>
                <span class="n">autocorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">autocorr</span> <span class="o">/</span> <span class="n">autocorr</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
                <span class="n">peaks</span><span class="p">,</span> <span class="n">peak_params</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">autocorr</span><span class="p">)</span>
                <span class="n">peak_values</span> <span class="o">=</span> <span class="n">autocorr</span><span class="p">[</span><span class="n">peaks</span><span class="p">]</span>
                <span class="n">num_peaks_above_threshold</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="n">cha</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">peak_values</span> <span class="o">&gt;</span> <span class="n">autocorr_peak_threshold</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">num_peaks_above_threshold</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="n">cha</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num_peaks_criterion</span><span class="p">:</span>
                    <span class="n">monochromatic</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="n">cha</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">monochromatic</span><span class="p">,</span> <span class="n">num_peaks_above_threshold</span></div>


<div class="viewcode-block" id="Template.read_waveforms">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.read_waveforms">[docs]</a>
    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the waveforms time series.</span>

<span class="sd">        This function reads the waveforms from the stored data file and initializes</span>
<span class="sd">        the `self.traces` attribute with the waveform data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stations : list of str, default None</span>
<span class="sd">            The list of station names for which to read the waveforms. If None, all</span>
<span class="sd">            stations in `self.stations` will be read.</span>
<span class="sd">        components : list of str, default None</span>
<span class="sd">            The list of component names for which to read the waveforms. If None,</span>
<span class="sd">            all components in `self.components` will be read.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The waveform data is stored in the `self.traces` attribute as an `obspy.Stream`</span>
<span class="sd">          object.</span>
<span class="sd">        - The `starttime` of each trace is set based on the origin time of the event</span>
<span class="sd">          and the moveout values stored in the `moveouts_win` attribute.</span>
<span class="sd">        - The `set_availability` method is called to update the availability of the</span>
<span class="sd">          waveforms for the selected stations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span>
        <span class="k">if</span> <span class="n">components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>

        <span class="k">def</span> <span class="nf">find_channel</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">cp</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">cp_alias</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span><span class="p">[</span><span class="n">cp</span><span class="p">]:</span>
                <span class="n">channel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">cp_alias</span><span class="p">),</span> <span class="n">keys</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;hdf5_gid&quot;</span><span class="p">):</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf5_gid</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sta</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">]:</span>
                    <span class="c1"># station not available</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
                    <span class="n">channel</span> <span class="o">=</span> <span class="n">find_channel</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">cp</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">Trace</span><span class="p">()</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">][</span><span class="n">channel</span><span class="p">][()]</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="o">=</span> <span class="n">sta</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>
                    <span class="n">ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;phase_on_comp</span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                    <span class="n">mv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts_win</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">mv</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">+=</span> <span class="n">tr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_availability</span><span class="p">(</span><span class="n">stations</span><span class="o">=</span><span class="n">stations</span><span class="p">)</span></div>


<div class="viewcode-block" id="Template.write">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.write">[docs]</a>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db_filename</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">OUTPUT_PATH</span><span class="p">,</span>
        <span class="n">save_waveforms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the Template instance to an HDF5 file.</span>

<span class="sd">        This function writes the Template instance to an HDF5 file specified by</span>
<span class="sd">        `db_filename` and `db_path`. It uses the `Event.write` method to handle the</span>
<span class="sd">        majority of the writing process.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        db_filename : str</span>
<span class="sd">            Name of the HDF5 file to store the Template instance.</span>
<span class="sd">        db_path : str, optional</span>
<span class="sd">            Path to the directory where the HDF5 file will be located. Defaults to</span>
<span class="sd">            `cfg.OUTPUT_PATH`.</span>
<span class="sd">        save_waveforms : bool, optional</span>
<span class="sd">            Flag indicating whether to save the waveforms in the HDF5 file. Defaults</span>
<span class="sd">            to True.</span>
<span class="sd">        gid : str, optional</span>
<span class="sd">            Name of the HDF5 group under which the Template instance will be stored.</span>
<span class="sd">            If None, the Template instance will be stored directly in the root of</span>
<span class="sd">            the HDF5 file. Defaults to None.</span>
<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            Flag indicating whether to overwrite an existing HDF5 file with the same</span>
<span class="sd">            name. If True, the existing file will be removed before writing. If False,</span>
<span class="sd">            the write operation will be skipped. Defaults to False.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The `write` function sets the `where` attribute of the Template instance</span>
<span class="sd">          to the full path of the HDF5 file.</span>
<span class="sd">        - If `overwrite` is True and an existing file with the same name already</span>
<span class="sd">          exists, it will be removed before writing the Template instance.</span>
<span class="sd">        - The majority of the writing process is handled by the `Event.write` method,</span>
<span class="sd">          which is called with appropriate arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">db_filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
        <span class="n">Event</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">db_filename</span><span class="p">,</span> <span class="n">db_path</span><span class="o">=</span><span class="n">db_path</span><span class="p">,</span> <span class="n">save_waveforms</span><span class="o">=</span><span class="n">save_waveforms</span><span class="p">,</span> <span class="n">gid</span><span class="o">=</span><span class="n">gid</span>
        <span class="p">)</span></div>


    <span class="c1"># ---------------------------------------------</span>
    <span class="c1">#  methods to investigate the detected events</span>
<div class="viewcode-block" id="Template.read_catalog">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.read_catalog">[docs]</a>
    <span class="k">def</span> <span class="nf">read_catalog</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_attributes</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">return_events</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">check_summary_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">compute_return_times</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a Catalog instance from detection data.</span>

<span class="sd">        This function builds a Catalog instance by reading detection data from a file</span>
<span class="sd">        specified by `filename` and `db_path`, or by checking for an existing summary</span>
<span class="sd">        file. It supports reading additional attributes specified by `extra_attributes`</span>
<span class="sd">        and provides options to control the behavior of filling missing values with</span>
<span class="sd">        `fill_value` and returning a list of Event instances with `return_events`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            Name of the detection file. If None, the standard file and folder naming</span>
<span class="sd">            convention will be used. Defaults to None.</span>
<span class="sd">        db_path : str, optional</span>
<span class="sd">            Name of the directory where the detection file is located. If None, the</span>
<span class="sd">            standard file and folder naming convention will be used. Defaults to None.</span>
<span class="sd">        gid : str, int, or float, optional</span>
<span class="sd">            If not None, this is the HDF5 group where the data will be read from.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        extra_attributes : list of str, optional</span>
<span class="sd">            Additional attributes to read in addition to the default attributes</span>
<span class="sd">            (&#39;longitude&#39;, &#39;latitude&#39;, &#39;depth&#39;, and &#39;origin_time&#39;). Defaults to an</span>
<span class="sd">            empty list.</span>
<span class="sd">        fill_value : str, int, or float, optional</span>
<span class="sd">            Default value to fill missing target attributes. Defaults to np.nan.</span>
<span class="sd">        return_events : bool, optional</span>
<span class="sd">            If True, a list of Event instances will be returned. This can only be</span>
<span class="sd">            True if check_summary_file is set to False. Defaults to False.</span>
<span class="sd">        check_summary_file : bool, optional</span>
<span class="sd">            If True, it checks if the summary HDF5 file already exists and reads from</span>
<span class="sd">            it using the standard naming convention. If False, it builds the catalog</span>
<span class="sd">            from the detection output. Defaults to True.</span>
<span class="sd">        compute_return_times : bool, optional</span>
<span class="sd">            If True, it computes inter-event times. Because events detected with the</span>
<span class="sd">            same template are co-located, these inter-event times can be called</span>
<span class="sd">            return times.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If `return_events` is set to True, `check_summary_file` must be set to False.</span>
<span class="sd">        - The `read_catalog` function first checks if the summary file exists.</span>
<span class="sd">        - The resulting Catalog instance is assigned to `self.catalog`, and additional</span>
<span class="sd">          attributes such as &#39;tid&#39; and &#39;event_id&#39; are set accordingly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">db_path_T</span><span class="p">,</span> <span class="n">filename_T</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_events</span> <span class="ow">and</span> <span class="n">check_summary_file</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;If `return_events` is True, `check_summary_file` has&quot;</span>
                <span class="s2">&quot; to be False. Change arguments.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">check_summary_file</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># try standard names</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path_T</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;summary_template</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="si">}</span><span class="s2">.h5&quot;</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="c1"># found an existing summary file</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;summary_template</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="si">}</span><span class="s2">.h5&quot;</span>
                    <span class="n">build_from_scratch</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># no existing summary file</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;detections_</span><span class="si">{</span><span class="n">filename_T</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">build_from_scratch</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path_T</span><span class="p">,</span> <span class="n">filename</span><span class="p">)):</span>
                <span class="c1"># use provided file</span>
                <span class="n">build_from_scratch</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">build_from_scratch</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># try standard name</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;detections_</span><span class="si">{</span><span class="n">filename_T</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">build_from_scratch</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">build_from_scratch</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">db_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># guess from standard convention</span>
                <span class="n">db_path</span> <span class="o">=</span> <span class="n">db_path_T</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;template&quot;</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;matched_filter&quot;</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span>
                <span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">Catalog</span><span class="o">.</span><span class="n">read_from_detection_file</span><span class="p">(</span>
                <span class="n">filename</span><span class="p">,</span>
                <span class="n">db_path</span><span class="o">=</span><span class="n">db_path</span><span class="p">,</span>
                <span class="n">gid</span><span class="o">=</span><span class="n">gid</span><span class="p">,</span>
                <span class="n">extra_attributes</span><span class="o">=</span><span class="n">extra_attributes</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">return_events</span><span class="o">=</span><span class="n">return_events</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">return_events</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span> <span class="o">=</span> <span class="n">output</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">,</span> <span class="n">events</span> <span class="o">=</span> <span class="n">output</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;tid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;event_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">))</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;event_id&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">catalog</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path_T</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;catalog&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">catalog</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;catalog&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">][()]</span>
                    <span class="k">if</span> <span class="n">catalog</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                        <span class="n">catalog</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
            <span class="n">extra_attributes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">catalog</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="s2">&quot;origin_time&quot;</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span> <span class="o">=</span> <span class="n">Catalog</span><span class="p">(</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">],</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">],</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">],</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">],</span>
                <span class="o">**</span><span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">catalog</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">extra_attributes</span><span class="p">},</span>
                <span class="n">event_ids</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">]))],</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">compute_return_times</span><span class="p">:</span>
            <span class="n">timestamps_sec</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span>
                <span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[ms]&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
                <span class="o">/</span> <span class="mf">1000.0</span>
            <span class="p">)</span>
            <span class="n">return_times_sec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">timestamps_sec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">timestamps_sec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;return_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">return_times_sec</span>
        <span class="k">if</span> <span class="n">return_events</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">events</span></div>


<div class="viewcode-block" id="Template.write_summary">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.write_summary">[docs]</a>
    <span class="k">def</span> <span class="nf">write_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">db_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the summary of template characteristics to an HDF5 file.</span>

<span class="sd">        This function writes the summary of template characteristics, e.g. the</span>
<span class="sd">        characteristics of the detected events, specified in the `attributes`</span>
<span class="sd">        dictionary to an HDF5 file specified by `filename` and `db_path`.</span>
<span class="sd">        It supports overwriting existing datasets or groups with `overwrite` option.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attributes : dict</span>
<span class="sd">            Dictionary containing scalars, numpy arrays, dictionaries, or pandas dataframes.</span>
<span class="sd">            The keys of the dictionary are used to name the dataset or group in the HDF5 file.</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            Name of the detection file. If None, the standard file and folder naming</span>
<span class="sd">            convention will be used. Defaults to None.</span>
<span class="sd">        db_path : str, optional</span>
<span class="sd">            Name of the directory where the detection file is located. If None, the</span>
<span class="sd">            standard file and folder naming convention will be used. Defaults to None.</span>
<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If True, existing datasets or groups will be overwritten. If False, they</span>
<span class="sd">            will be skipped. Defaults to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">db_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">db_path</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;summary_template</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="si">}</span><span class="s2">.h5&quot;</span>
        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">attributes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">f</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">key2</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">f</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">key2</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">key2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">])</span></div>


    <span class="c1"># ---------------------------------------------</span>
    <span class="c1"># plotting methods</span>
<div class="viewcode-block" id="Template.plot_detection">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.plot_detection">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_detection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">duration</span><span class="o">=</span><span class="mf">60.0</span><span class="p">,</span>
        <span class="n">phase_on_comp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">},</span>
        <span class="n">offset_ot</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the `idx`-th detection made with this template.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        idx : int</span>
<span class="sd">            Index of the detection to plot.</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            Name of the detection file. If None, use the standard file and folder naming</span>
<span class="sd">            convention. Defaults to None.</span>
<span class="sd">        db_path : str, optional</span>
<span class="sd">            Name of the directory where the detection file is located. If None, use the</span>
<span class="sd">            standard file and folder naming convention. Defaults to None.</span>
<span class="sd">        duration : float, optional</span>
<span class="sd">            Duration of the waveforms to plot, in seconds. Defaults to 60.0.</span>
<span class="sd">        phase_on_comp : dict, optional</span>
<span class="sd">            Dictionary specifying the phase associated with each component. The keys</span>
<span class="sd">            are component codes, and the values are phase codes. Defaults to</span>
<span class="sd">            {&quot;N&quot;: &quot;S&quot;, &quot;1&quot;: &quot;S&quot;, &quot;E&quot;: &quot;S&quot;, &quot;2&quot;: &quot;S&quot;, &quot;Z&quot;: &quot;P&quot;}.</span>
<span class="sd">        offset_ot : float, optional</span>
<span class="sd">            Offset in seconds to apply to the origin time of the event when retrieving</span>
<span class="sd">            the waveforms. Defaults to 10.0.</span>
<span class="sd">        **kwargs:</span>
<span class="sd">            Additional keyword arguments to be passed to the `Event.plot` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.figure.Figure</span>
<span class="sd">            Figure instance produced by this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `Template.read_waveforms` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">db_path_T</span><span class="p">,</span> <span class="n">filename_T</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># guess from standard convention</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;detections_</span><span class="si">{</span><span class="n">filename_T</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">db_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># guess from standard convention</span>
            <span class="n">db_path</span> <span class="o">=</span> <span class="n">db_path_T</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="s2">&quot;template&quot;</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;matched_filter&quot;</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span>
            <span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">event</span> <span class="o">=</span> <span class="n">Event</span><span class="o">.</span><span class="n">read_from_file</span><span class="p">(</span><span class="n">hdf5_file</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span>
        <span class="n">event</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">event</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span>
            <span class="n">duration</span><span class="p">,</span>
            <span class="n">offset_ot</span><span class="o">=</span><span class="n">offset_ot</span><span class="p">,</span>
            <span class="n">phase_on_comp</span><span class="o">=</span><span class="n">phase_on_comp</span><span class="p">,</span>
            <span class="n">time_shifted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">stations</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># stations = event.stations</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">get_axes</span><span class="p">()</span>
        <span class="n">cc</span><span class="p">,</span> <span class="n">n_channels</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">components</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">cp_alias</span> <span class="ow">in</span> <span class="n">event</span><span class="o">.</span><span class="n">component_aliases</span><span class="p">[</span><span class="n">cp</span><span class="p">]:</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">cp_alias</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># succesfully retrieved data</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ph</span> <span class="o">=</span> <span class="n">phase_on_comp</span><span class="p">[</span><span class="n">cp_alias</span><span class="p">]</span>
                <span class="n">starttime</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">event</span><span class="o">.</span><span class="n">origin_time</span>
                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts_win</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">endtime</span> <span class="o">=</span> <span class="n">starttime</span> <span class="o">+</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="o">*</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">time_range</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;ms&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">event_tr</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">cp_alias</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">idx1</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">moveouts_win</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                        <span class="o">+</span> <span class="n">offset_ot</span><span class="p">,</span>
                        <span class="n">sr</span><span class="o">=</span><span class="n">event_tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">idx2</span> <span class="o">=</span> <span class="n">idx1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span>
                    <span class="n">max_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">event_tr</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx1</span><span class="p">:</span><span class="n">idx2</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="s2">&quot;gain&quot;</span><span class="p">,</span> <span class="mf">1.0e6</span>
                    <span class="p">)</span>
                    <span class="n">cc_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">event_tr</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx1</span><span class="p">:</span><span class="n">idx2</span><span class="p">]</span> <span class="o">*</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">event_tr</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx1</span><span class="p">:</span><span class="n">idx2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cc_</span><span class="p">):</span>
                        <span class="n">cc</span> <span class="o">+=</span> <span class="n">cc_</span>
                        <span class="n">n_channels</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="c1"># trace not found</span>
                    <span class="n">max_amp</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">)</span>
                    <span class="n">max_amp</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">s</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="n">time</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">],</span>
                    <span class="n">utils</span><span class="o">.</span><span class="n">max_norm</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">])</span> <span class="o">*</span> <span class="n">max_amp</span><span class="p">,</span>
                    <span class="n">lw</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C3&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="n">cc</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_channels</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">_suptitle</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; CC=</span><span class="si">{</span><span class="n">cc</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="Template.plot_recurrence_times">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.plot_recurrence_times">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_recurrence_times</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annotate_axes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot recurrence times vs detection times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : plt.Axes, optional</span>
<span class="sd">            If not None, use this plt.Axes instance to plot the data.</span>
<span class="sd">        annotate_axes : bool, optional</span>
<span class="sd">            Whether to annotate the axes with labels. Defaults to True.</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            Figure size (width, height) in inches. Defaults to (20, 10).</span>
<span class="sd">        **kwargs:</span>
<span class="sd">            Additional keyword arguments to be passed to the plt.plot function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.figure.Figure</span>
<span class="sd">            Figure instance produced by this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;marker&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;ls&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;recurrence_times_tp</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;catalog&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `read_catalog` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">rt</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">origin_time</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">origin_time</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="s2">&quot;timedelta64[ns]&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="s2">&quot;float64&quot;</span>
        <span class="p">)</span> <span class="o">/</span> <span class="mf">1.0e9</span>  <span class="c1"># in sec</span>
        <span class="k">if</span> <span class="n">unique</span> <span class="ow">and</span> <span class="s2">&quot;unique_event&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">:</span>
            <span class="n">unique_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;unique_event&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">origin_time</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">unique_event</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="n">rt</span><span class="p">[</span><span class="n">unique_event</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">origin_time</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">rt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">annotate_axes</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Detection Time&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Recurrence Time (s)&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">semilogy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span></div>
</div>



<div class="viewcode-block" id="Family">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family">[docs]</a>
<span class="k">class</span> <span class="nc">Family</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An abstract class for several subclasses.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;network&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.set_network(network)` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">components</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;network&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.set_network(network)` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">stations</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">moveouts_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_moveouts_arr&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_moveouts_arr</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moveouts_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">waveforms_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_waveforms_arr&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_waveforms_arr</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waveforms_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_n_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">)</span>

<div class="viewcode-block" id="Family.get_moveouts_arr">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family.get_moveouts_arr">[docs]</a>
    <span class="k">def</span> <span class="nf">get_moveouts_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_moveouts_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_events</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_stations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_events</span><span class="p">):</span>
            <span class="n">ev_stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">stations</span>
            <span class="n">sta_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">station_indexes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ev_stations</span><span class="p">]</span>
            <span class="n">_moveouts_arr</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">sta_indexes</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">moveouts_arr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_moveouts_arr</span> <span class="o">=</span> <span class="n">_moveouts_arr</span></div>


<div class="viewcode-block" id="Family.get_waveforms_arr">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family.get_waveforms_arr">[docs]</a>
    <span class="k">def</span> <span class="nf">get_waveforms_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;read_waveforms&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">()</span>
        <span class="c1"># check the templates&#39; duration</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">ev</span><span class="o">.</span><span class="n">n_samples</span> <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Templates have different durations, we cannot return&quot;</span>
                <span class="s2">&quot; the template data in a single array.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waveforms_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">ev</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span><span class="n">stations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remember</span><span class="p">(</span><span class="s2">&quot;get_waveforms_arr&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Family.normalize">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family.normalize">[docs]</a>
    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;rms&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normalize the template waveforms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        method: string, default to &#39;rms&#39;</span>
<span class="sd">            Either &#39;rms&#39; (default) or &#39;max&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;rms&quot;</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">norm</span><span class="p">[</span><span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waveforms_arr</span> <span class="o">/=</span> <span class="n">norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remember</span><span class="p">(</span><span class="s2">&quot;normalize&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Family.read_waveforms">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family.read_waveforms">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="Family.set_network">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family.set_network">[docs]</a>
    <span class="k">def</span> <span class="nf">set_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update `self.network` to the new desired `network`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        network: `dataset.Network` instance</span>
<span class="sd">            The `Network` instance used to query consistent data accross all</span>
<span class="sd">            templates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updating the instance accordingly...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">action</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>
            <span class="n">func</span><span class="p">()</span></div>


<div class="viewcode-block" id="Family.set_source_receiver_dist">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family.set_source_receiver_dist">[docs]</a>
    <span class="k">def</span> <span class="nf">set_source_receiver_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the source-receiver distances for template.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">:</span>
            <span class="n">ev</span><span class="o">.</span><span class="n">set_source_receiver_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remember</span><span class="p">(</span><span class="s2">&quot;set_source_receiver_dist&quot;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_remember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Append `action` to the list of processes to remember.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        action: string</span>
<span class="sd">            Name of the class method that was called once and that has to be</span>
<span class="sd">            repeated every time `self.network` is updated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">action</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">action</span><span class="p">)</span></div>



<div class="viewcode-block" id="EventGroup">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.EventGroup">[docs]</a>
<span class="k">class</span> <span class="nc">EventGroup</span><span class="p">(</span><span class="n">Family</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for a group of events.</span>

<span class="sd">    Each event is represented by a `dataset.Event` instance.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    events : list</span>
<span class="sd">        List of `dataset.Event` instances constituting the group.</span>
<span class="sd">    network : `dataset.Network`</span>
<span class="sd">        The `Network` instance used to query consistent data across all events.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">network</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the EventGroup with a list of `dataset.Event` instances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        events : list of `dataset.Event` instances</span>
<span class="sd">            List of `dataset.Event` instances constituting the group.</span>
<span class="sd">        network : `dataset.Network` instance</span>
<span class="sd">            The `Network` instance used to query consistent data across all events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># alias to use the parent class&#39; methods</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>

    <span class="c1"># methods</span>
<div class="viewcode-block" id="EventGroup.read_waveforms">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.EventGroup.read_waveforms">[docs]</a>
    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">time_shifted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call `dataset.Event.read_waveform` with each event.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        duration : float</span>
<span class="sd">            Duration of the waveform to read, in seconds.</span>
<span class="sd">        time_shifted : bool, default False</span>
<span class="sd">            Whether to apply time shifting to the waveforms.</span>
<span class="sd">        progress : bool, default False</span>
<span class="sd">            Whether to display progress information during waveform reading.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments to pass to `dataset.Event.read_waveforms`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_shifted</span> <span class="o">=</span> <span class="n">time_shifted</span>
        <span class="n">disable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Reading event waveforms&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable</span><span class="p">):</span>
            <span class="n">ev</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span><span class="n">duration</span><span class="p">,</span> <span class="n">time_shifted</span><span class="o">=</span><span class="n">time_shifted</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remember</span><span class="p">(</span><span class="s2">&quot;read_waveforms&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EventGroup.SVDWF_stack">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.EventGroup.SVDWF_stack">[docs]</a>
    <span class="k">def</span> <span class="nf">SVDWF_stack</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">freqmin</span><span class="p">,</span>
        <span class="n">freqmax</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">,</span>
        <span class="n">expl_var</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
        <span class="n">max_singular_values</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">wiener_filter_colsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply Singular Value Decomposition Waveform Filtering (SVDWF) and stack the waveforms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freqmin : float</span>
<span class="sd">            Minimum frequency in Hz for the bandpass filter.</span>
<span class="sd">        freqmax : float</span>
<span class="sd">            Maximum frequency in Hz for the bandpass filter.</span>
<span class="sd">        sampling_rate : float</span>
<span class="sd">            Sampling rate in Hz of the waveforms.</span>
<span class="sd">        expl_var : float, default 0.4</span>
<span class="sd">            Explained variance ratio threshold for retaining singular values.</span>
<span class="sd">        max_singular_values : int, default 5</span>
<span class="sd">            Maximum number of singular values to retain during SVDWF.</span>
<span class="sd">        wiener_filter_colsize : int, default None</span>
<span class="sd">            Size of the column blocks used for the Wiener filter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See: Moreau, L., Stehly, L., Bou, P., Lu, Y., Larose, E., &amp; Campillo, M. (2017).</span>
<span class="sd">        Improving ambient noise correlation functions with an SVD-based Wiener filter.</span>
<span class="sd">        Geophysical Journal International, 211(1), 418-426.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)):</span>
                <span class="n">filtered_data</span><span class="p">[:,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">SVDWF</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">[:,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:],</span>
                    <span class="n">max_singular_values</span><span class="o">=</span><span class="n">max_singular_values</span><span class="p">,</span>
                    <span class="n">expl_var</span><span class="o">=</span><span class="n">expl_var</span><span class="p">,</span>
                    <span class="n">freqmin</span><span class="o">=</span><span class="n">freqmin</span><span class="p">,</span>
                    <span class="n">freqmax</span><span class="o">=</span><span class="n">freqmax</span><span class="p">,</span>
                    <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
                    <span class="n">wiener_filter_colsize</span><span class="o">=</span><span class="n">wiener_filter_colsize</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">[:,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;Problem with station </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{:d}</span><span class="s2">), component </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{:d}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">c</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="n">stacked_waveforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">stacked_waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">norm</span><span class="p">[</span><span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">stacked_waveforms</span> <span class="o">/=</span> <span class="n">norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_data</span> <span class="o">=</span> <span class="n">filtered_data</span>
        <span class="c1"># create a stream with a fake origin time to track future</span>
        <span class="c1"># changes in reference time better</span>
        <span class="n">stacked_traces</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
        <span class="n">reference_time</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">):</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">Trace</span><span class="p">()</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="o">=</span> <span class="n">sta</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">component</span> <span class="o">=</span> <span class="n">cp</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">stacked_waveforms</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_shifted</span><span class="p">:</span>
                    <span class="n">ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;phase_on_comp</span><span class="si">{</span><span class="n">cp</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">reference_time</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="n">reference_time</span>
                <span class="n">stacked_traces</span> <span class="o">+=</span> <span class="n">tr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">(</span>
            <span class="n">stacked_traces</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">phases</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
            <span class="n">filtered_data</span><span class="o">=</span><span class="n">filtered_data</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># fetch auxiliary data</span>
        <span class="n">select</span> <span class="o">=</span> <span class="k">lambda</span> <span class="nb">str</span><span class="p">:</span> <span class="nb">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;phase_on_comp&quot;</span><span class="p">)</span>
        <span class="n">aux_data_to_keep</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">select</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">aux_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">aux_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">aux_data_to_keep</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">aux_data</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span><span class="n">aux_data</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="TemplateGroup">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup">[docs]</a>
<span class="k">class</span> <span class="nc">TemplateGroup</span><span class="p">(</span><span class="n">Family</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for a group of templates.</span>

<span class="sd">    Each template is represented by a `dataset.Template` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">templates</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">source_receiver_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the TemplateGroup instance with a list of `dataset.Template` instances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        templates : list of `dataset.Template` instances</span>
<span class="sd">            The list of templates constituting the group.</span>
<span class="sd">        network : `dataset.Network` instance</span>
<span class="sd">            The `Network` instance used to query consistent data across all templates.</span>
<span class="sd">        source_receiver_dist : bool, optional</span>
<span class="sd">            If True, compute the source-receiver distances on all templates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">templates</span> <span class="o">=</span> <span class="n">templates</span>
        <span class="c1"># self._events = self.templates # alias to use the base class methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
        <span class="c1"># self.n_templates = len(self.templates)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">tid</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="c1"># convenient map between template id and the template index in</span>
        <span class="c1"># the self.templates list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tindexes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;tid_to_tindex&quot;</span>
        <span class="p">)</span>
        <span class="c1"># keep track of the attributes that need updating</span>
        <span class="c1"># when self.network changes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># compute source-receiver distances if requested</span>
        <span class="k">if</span> <span class="n">source_receiver_dist</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_source_receiver_dist</span><span class="p">()</span>

<div class="viewcode-block" id="TemplateGroup.read_from_files">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.read_from_files">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_files</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">gids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the TemplateGroup instance given a list of filenames.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filenames : list of str</span>
<span class="sd">            List of full file paths from which to instantiate the list</span>
<span class="sd">            of `dataset.Template` objects.</span>
<span class="sd">        network : `dataset.Network` instance</span>
<span class="sd">            The `Network` instance used to query consistent data across all templates.</span>
<span class="sd">        gids : list of str, optional</span>
<span class="sd">            If provided, this should be a list of group IDs where the</span>
<span class="sd">            template data is stored in their HDF5 files.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        template_group : TemplateGroup instance</span>
<span class="sd">            The initialized TemplateGroup instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">templates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filenames</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">gids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="n">gids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">db_path</span><span class="p">,</span> <span class="n">db_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">templates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Template</span><span class="o">.</span><span class="n">read_from_file</span><span class="p">(</span><span class="n">db_filename</span><span class="p">,</span> <span class="n">db_path</span><span class="o">=</span><span class="n">db_path</span><span class="p">,</span> <span class="n">gid</span><span class="o">=</span><span class="n">gid</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">network</span><span class="p">)</span></div>


    <span class="c1"># properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># alias to use the parent class&#39; methods</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dir_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_dir_errors&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_dir_errors</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dir_errors</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ellipsoid_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_ellipsoid_dist&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_ellipsoid_dist</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ellipsoid_dist</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intertemplate_cc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_cc&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_intertemplate_cc</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intertemplate_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_dist&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_intertemplate_dist</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_dist</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">network_to_template_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_network_to_template_map&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_network_to_template_map</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network_to_template_map</span>

    <span class="c1"># methods</span>
<div class="viewcode-block" id="TemplateGroup.box">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.box">[docs]</a>
    <span class="k">def</span> <span class="nf">box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon_min</span><span class="p">,</span> <span class="n">lon_max</span><span class="p">,</span> <span class="n">lat_min</span><span class="p">,</span> <span class="n">lat_max</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keep templates inside the requested geographic bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon_min : float</span>
<span class="sd">            Minimum longitude in decimal degrees.</span>
<span class="sd">        lon_max : float</span>
<span class="sd">            Maximum longitude in decimal degrees.</span>
<span class="sd">        lat_min : float</span>
<span class="sd">            Minimum latitude in decimal degrees.</span>
<span class="sd">        lat_max : float</span>
<span class="sd">            Maximum latitude in decimal degrees.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If True, perform the operation in-place by modifying the existing TemplateGroup.</span>
<span class="sd">            If False, create and return a new TemplateGroup with the filtered templates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        template_group : TemplateGroup instance</span>
<span class="sd">            The TemplateGroup instance containing templates within the specified geographic bounds.</span>
<span class="sd">            This is returned only when inplace=False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">templates_inside</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">longitude</span> <span class="o">&gt;=</span> <span class="n">lon_min</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">longitude</span> <span class="o">&lt;=</span> <span class="n">lon_max</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">latitude</span> <span class="o">&gt;=</span> <span class="n">lat_min</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">latitude</span> <span class="o">&lt;=</span> <span class="n">lat_max</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">templates_inside</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span> <span class="o">=</span> <span class="n">templates_inside</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">tid</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tindexes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;tid_to_tindex&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_dist&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tids</span>
                <span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_dir_errors&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dir_errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dir_errors</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_ellipsoid_dist&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ellipsoid_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ellipsoid_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_cc&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tids</span>
                <span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_waveforms_arr&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_waveforms_arr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_template_group</span> <span class="o">=</span> <span class="n">TemplateGroup</span><span class="p">(</span><span class="n">templates_inside</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">)</span>
            <span class="n">new_tids</span> <span class="o">=</span> <span class="n">new_template_group</span><span class="o">.</span><span class="n">tids</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_dist&quot;</span><span class="p">):</span>
                <span class="n">new_template_group</span><span class="o">.</span><span class="n">_intertemplate_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">new_tids</span><span class="p">,</span> <span class="n">new_tids</span>
                <span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_dir_errors&quot;</span><span class="p">):</span>
                <span class="n">new_template_group</span><span class="o">.</span><span class="n">_dir_errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dir_errors</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">new_tids</span><span class="p">,</span> <span class="n">new_tids</span>
                <span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_ellipsoid_dist&quot;</span><span class="p">):</span>
                <span class="n">new_template_group</span><span class="o">.</span><span class="n">_ellipsoid_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ellipsoid_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">new_tids</span><span class="p">,</span> <span class="n">new_tids</span>
                <span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_cc&quot;</span><span class="p">):</span>
                <span class="n">new_template_group</span><span class="o">.</span><span class="n">_intertemplate_cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">new_tids</span><span class="p">,</span> <span class="n">new_tids</span>
                <span class="p">]</span>
            <span class="k">return</span> <span class="n">new_template_group</span></div>


<div class="viewcode-block" id="TemplateGroup.compute_intertemplate_dist">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.compute_intertemplate_dist">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_intertemplate_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the template-pairwise distances in kilometers.</span>

<span class="sd">        This method calculates the distances between all pairs of templates in the TemplateGroup.</span>
<span class="sd">        The distances are computed based on the longitude, latitude, and depth of each template.</span>

<span class="sd">        The computed distances are then read at the `self.intertemplate_dist` property</span>
<span class="sd">        of the TemplateGroup instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            The computed distances can be accessed at the `self.intertemplate_dist`</span>
<span class="sd">            property of the TemplateGroup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">longitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">longitude</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="n">latitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">latitude</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="n">depths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">depth</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="n">_intertemplate_dist</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">compute_distances</span><span class="p">(</span>
            <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">depths</span><span class="p">,</span> <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">depths</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_dist</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">_intertemplate_dist</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TemplateGroup.compute_dir_errors">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.compute_dir_errors">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_dir_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the length of the uncertainty ellipsoid in the inter-template direction.</span>

<span class="sd">        This method calculates the length of the uncertainty ellipsoid in the</span>
<span class="sd">        inter-template direction for each pair of templates in the TemplateGroup.</span>
<span class="sd">        The inter-template direction is defined as the direction linking two templates.</span>
<span class="sd">        The length of the uncertainty ellipsoid is computed based on the covariance</span>
<span class="sd">        matrix of each template.</span>

<span class="sd">        The computed errors can be read at the `self.dir_errors` property of</span>
<span class="sd">        the TemplateGroup. It is a pandas DataFrame with dimensions</span>
<span class="sd">        (n_templates, n_templates), where each entry represents the length of</span>
<span class="sd">        the uncertainty ellipsoid in kilometers.</span>

<span class="sd">        Example: `self.dir_errors.loc[tid1, tid2]` is the width of template `tid1`&#39;s</span>
<span class="sd">        uncertainty ellipsoid in the direction of template `tid2`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            The computed errors can be read at the `self.dir_errors` property</span>
<span class="sd">            of the TemplateGroup instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">cartopy</span> <span class="kn">import</span> <span class="n">crs</span>

        <span class="c1"># X: west, Y: south, Z: downward</span>
        <span class="n">s_68_3df</span> <span class="o">=</span> <span class="mf">3.52</span>
        <span class="n">s_90_3df</span> <span class="o">=</span> <span class="mf">6.251</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing the inter-template directional errors...&quot;</span><span class="p">)</span>
        <span class="n">longitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">longitude</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="n">latitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">latitude</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="n">depths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">depth</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="c1"># ----------------------------------------------</span>
        <span class="c1">#      Define the projection used to</span>
        <span class="c1">#      work in a cartesian space</span>
        <span class="c1"># ----------------------------------------------</span>
        <span class="n">data_coords</span> <span class="o">=</span> <span class="n">crs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">()</span>
        <span class="n">projection</span> <span class="o">=</span> <span class="n">crs</span><span class="o">.</span><span class="n">Mercator</span><span class="p">(</span>
            <span class="n">central_longitude</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">longitudes</span><span class="p">),</span>
            <span class="n">min_latitude</span><span class="o">=</span><span class="n">latitudes</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
            <span class="n">max_latitude</span><span class="o">=</span><span class="n">latitudes</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="n">XY</span> <span class="o">=</span> <span class="n">projection</span><span class="o">.</span><span class="n">transform_points</span><span class="p">(</span><span class="n">data_coords</span><span class="p">,</span> <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">)</span>
        <span class="n">cartesian_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">depths</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># compute the directional errors</span>
        <span class="n">_dir_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">):</span>
            <span class="n">unit_direction</span> <span class="o">=</span> <span class="n">cartesian_coords</span> <span class="o">-</span> <span class="n">cartesian_coords</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">unit_direction</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">unit_direction</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span>
                <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span>
            <span class="p">]</span>
            <span class="c1"># this operation produced NaNs for i=t</span>
            <span class="n">unit_direction</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">unit_direction</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="s2">&quot;cov_mat&quot;</span><span class="p">):</span>
                <span class="c1"># compute the length of the covariance ellipsoid</span>
                <span class="c1"># in the direction that links the two earthquakes</span>
                <span class="n">cov_dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">cov_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">unit_direction</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">unit_direction</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># covariance is unit of [distance**2], therefore we need the sqrt:</span>
                <span class="n">_dir_errors</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_68_3df</span> <span class="o">*</span> <span class="n">cov_dir</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># use default large error</span>
                <span class="n">_dir_errors</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">15.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dir_errors</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">_dir_errors</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TemplateGroup.compute_ellipsoid_dist">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.compute_ellipsoid_dist">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_ellipsoid_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the separation between uncertainty ellipsoids in the inter-template direction.</span>

<span class="sd">        This method calculates the separation between the uncertainty</span>
<span class="sd">        ellipsoids in the inter-template direction for each pair of templates</span>
<span class="sd">        in the TemplateGroup instance. The separation is computed as the difference</span>
<span class="sd">        between the inter-template distances and the directional errors. It can</span>
<span class="sd">        be negative if the uncertainty ellipsoids overlap.</span>

<span class="sd">        The computed separations can be read at the `self.ellipsoid_dist`</span>
<span class="sd">        property of the TemplateGroup instance. It is a pandas DataFrame with</span>
<span class="sd">        dimensions (n_templates, n_templates), where each entry represents</span>
<span class="sd">        the separation between the uncertainty ellipsoids in kilometers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            The computed separations can be read at the `self.ellipsoid_dist`</span>
<span class="sd">            property of the TemplateGroup instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ellipsoid_dist</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intertemplate_dist</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir_errors</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir_errors</span><span class="o">.</span><span class="n">T</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TemplateGroup.compute_intertemplate_cc">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.compute_intertemplate_cc">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_intertemplate_cc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">distance_threshold</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
        <span class="n">n_stations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">max_lag</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">save_cc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">compute_from_scratch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span>
        <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_filename</span><span class="o">=</span><span class="s2">&quot;intertp_cc.h5&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the pairwise template cross-correlations (CCs).</span>

<span class="sd">        This method computes the pairwise cross-correlations (CCs) between</span>
<span class="sd">        templates in the TemplateGroup.</span>

<span class="sd">        The CCs measure the similarity between the waveforms of different templates.</span>
<span class="sd">        CCs are computed only for template pairs that are separated by less than</span>
<span class="sd">        `distance_threhold`. The number of closest stations to include and the maximum</span>
<span class="sd">        lag for searching the maximum CC are configurable parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        distance_threshold : float, default to 5.0</span>
<span class="sd">            The distance threshold, in kilometers, between two uncertainty</span>
<span class="sd">            ellipsoids under which the CC is computed.</span>
<span class="sd">        n_stations : int, default to 10</span>
<span class="sd">            The number of closest stations to each template that are used in</span>
<span class="sd">            the computation of the average CC.</span>
<span class="sd">        max_lag : int, default to 10</span>
<span class="sd">            The maximum lag, in samples, allowed when searching for the maximum</span>
<span class="sd">            CC on each channel. This parameter accounts for small discrepancies</span>
<span class="sd">            in windowing that could occur for two templates highly similar but</span>
<span class="sd">            associated with slightly different locations.</span>
<span class="sd">        save_cc : bool, default to False</span>
<span class="sd">            If True, save the inter-template CCs in the same folder as the first</span>
<span class="sd">            template (`self.templates[0]`) with filename &#39;output_filename&#39;.</span>
<span class="sd">        compute_from_scratch : bool, default to False</span>
<span class="sd">            If True, force the computation of the inter-template CCs from scratch.</span>
<span class="sd">            This is useful when the user knows that the computation is faster than</span>
<span class="sd">            reading a potentially large file.</span>
<span class="sd">        device : str, default to &#39;cpu&#39;</span>
<span class="sd">            The device to use for the computation. Can be either &#39;cpu&#39; or &#39;gpu&#39;.</span>
<span class="sd">        progress : bool, default to False</span>
<span class="sd">            If True, print a progress bar using `tqdm`.</span>
<span class="sd">        output_filename : str, default to &#39;intertp_cc.h5&#39;</span>
<span class="sd">            The filename to use when saving the inter-template CCs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            The computed inter-template CCs can be read at the `self.intertemplate_cc`</span>
<span class="sd">            property of the TemplateGroup instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">fast_matched_filter</span> <span class="k">as</span> <span class="nn">fmf</span>  <span class="c1"># clearly need some optimization</span>

        <span class="n">disable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>

        <span class="c1"># try reading the inter-template CC from db</span>
        <span class="n">db_path</span><span class="p">,</span> <span class="n">db_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
        <span class="n">cc_fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">output_filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">compute_from_scratch</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">cc_fn</span><span class="p">):</span>
            <span class="n">_intertemplate_cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_intertp_cc</span><span class="p">(</span><span class="n">cc_fn</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">_intertemplate_cc</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>
                <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span>
            <span class="p">):</span>
                <span class="c1"># all current templates are contained in intertp_cc</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span> <span class="o">=</span> <span class="n">_intertemplate_cc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read inter-template CCs from </span><span class="si">{</span><span class="n">cc_fn</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">compute_from_scratch</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compute_from_scratch</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">compute_from_scratch</span><span class="p">:</span>
            <span class="c1"># compute from scratch</span>
            <span class="c1"># self.n_closest_stations(n_stations)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing the similarity matrix...&quot;</span><span class="p">)</span>
            <span class="c1"># format arrays for FMF</span>
            <span class="n">data_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">template_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">:</span><span class="o">-</span><span class="n">max_lag</span><span class="p">]</span>
            <span class="n">moveouts_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">intertp_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
            <span class="p">)</span>
            <span class="n">n_network_stations</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="n">moveouts_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="c1"># use FMF on one template at a time against all others</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">template</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Inter-tp CC&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable</span>
            <span class="p">):</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">template_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="c1"># select the `n_stations` closest stations</span>
                <span class="c1"># apply similar approach than Event.n_closest_stations</span>
                <span class="n">station_pool</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">network_stations</span><span class="p">[</span><span class="n">template</span><span class="o">.</span><span class="n">availability</span><span class="p">]</span>
                <span class="n">closest_stations</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">template</span><span class="o">.</span><span class="n">source_receiver_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station_pool</span><span class="p">]</span>
                    <span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="n">n_stations</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># make sure we return a n_stations-vector</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_stations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_stations</span><span class="p">:</span>
                    <span class="n">missing</span> <span class="o">=</span> <span class="n">n_stations</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_stations</span><span class="p">)</span>
                    <span class="n">closest_stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">closest_stations</span><span class="p">,</span>
                            <span class="n">template</span><span class="o">.</span><span class="n">source_receiver_dist</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
                                <span class="n">closest_stations</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;rows&quot;</span>
                            <span class="p">)</span>
                            <span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
                            <span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="n">missing</span><span class="p">],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">network_stations</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">closest_stations</span><span class="p">:</span>
                        <span class="n">weights</span><span class="p">[:,</span> <span class="n">s</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span>
                            <span class="n">template</span><span class="o">.</span><span class="n">availability_per_cha</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                        <span class="p">)</span>
                <span class="n">weights</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">above_thrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ellipsoid_dist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">[</span><span class="n">t</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">distance_threshold</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">above_thrs</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">cc</span> <span class="o">=</span> <span class="n">fmf</span><span class="o">.</span><span class="n">matched_filter</span><span class="p">(</span>
                    <span class="n">template_arr</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                    <span class="n">moveouts_arr</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                    <span class="n">data_arr</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                    <span class="mi">1</span><span class="p">,</span>
                    <span class="n">arch</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                    <span class="n">network_sum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">check_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">intertp_cc</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">keep</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="c1"># make the CC matrix symmetric by averaging the lower</span>
            <span class="c1"># and upper triangles</span>
            <span class="n">_intertemplate_cc</span> <span class="o">=</span> <span class="p">(</span><span class="n">intertp_cc</span> <span class="o">+</span> <span class="n">intertp_cc</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">_intertemplate_cc</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">compute_from_scratch</span> <span class="ow">and</span> <span class="n">save_cc</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving inter-tp CC to </span><span class="si">{</span><span class="n">cc_fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_intertp_cc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span><span class="p">,</span> <span class="n">cc_fn</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_save_intertp_cc</span><span class="p">(</span><span class="n">intertp_cc</span><span class="p">,</span> <span class="n">fullpath</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the inter-template correlation coefficients to a file.</span>

<span class="sd">        This method saves the inter-template correlation coefficients computed</span>
<span class="sd">        by the `compute_intertemplate_cc` method to a specified file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        intertp_cc : pd.DataFrame</span>
<span class="sd">            The inter-template correlation coefficients computed by the</span>
<span class="sd">            `compute_intertemplate_cc` method.</span>
<span class="sd">        fullpath : str</span>
<span class="sd">            The full path to the output file where the correlation coefficients</span>
<span class="sd">            will be saved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;tids&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">intertp_cc</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;intertp_cc&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">intertp_cc</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_intertp_cc</span><span class="p">(</span><span class="n">fullpath</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read inter-template correlation coefficients from file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        fullpath : string</span>
<span class="sd">            Full path to output file.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        intertp_cc : pd.DataFrame</span>
<span class="sd">            The inter-template CC in a pd.DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">tids</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;tids&quot;</span><span class="p">][()]</span>
            <span class="n">intertp_cc</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;intertp_cc&quot;</span><span class="p">][()]</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">tids</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">tids</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">intertp_cc</span><span class="p">)</span>

<div class="viewcode-block" id="TemplateGroup.read_waveforms">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.read_waveforms">[docs]</a>
    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read waveforms for all templates in the TemplateGroup.</span>

<span class="sd">        This method calls `template.read_waveforms` for each `Template`</span>
<span class="sd">        instance in `self.templates`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_threads : int, optional</span>
<span class="sd">            The number of threads to use for parallel execution. If set to 1</span>
<span class="sd">            (default), the waveforms will be read sequentially. If set to a</span>
<span class="sd">            value greater than 1, the waveforms will be read in parallel using</span>
<span class="sd">            multiple threads. If set to 0, None, or &quot;all&quot;, the method will use all</span>
<span class="sd">            available CPUs for parallel execution.</span>
<span class="sd">        progress : bool, optional</span>
<span class="sd">            If True, a progress bar will be displayed during the waveform reading process.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">disable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_threads</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>

            <span class="c1"># cannot use tqdm with parallel execution</span>
            <span class="n">disable</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">n_threads</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]:</span>
                <span class="c1"># n_threads = None means use all CPUs</span>
                <span class="n">n_threads</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">n_threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                <span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">tp</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span>
                        <span class="n">stations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span>
                    <span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Reading waveforms&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable</span><span class="p">):</span>
                <span class="n">tp</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span><span class="n">stations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remember</span><span class="p">(</span><span class="s2">&quot;read_waveforms&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="TemplateGroup.set_network_to_template_map">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.set_network_to_template_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_network_to_template_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the map between network arrays and template data.</span>

<span class="sd">        Template data are broadcasted to fit the dimensions of the network</span>
<span class="sd">        arrays. This method computes the `network_to_template_map` that tells</span>
<span class="sd">        which stations and channels are used on each template.</span>
<span class="sd">        For example:</span>
<span class="sd">        `network_to_template_map[t, s, c] = False`</span>
<span class="sd">        means that station s and channel c are not used on template t.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_network_to_template_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_stations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># 1) find the non-zero channels</span>
        <span class="n">_network_to_template_map</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="c1"># 2) only keep the stations that were selected on each template</span>
        <span class="n">selected_stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_network_to_template_map</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">tp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">):</span>
            <span class="n">valid_sta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">station_indexes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">stations</span><span class="p">]</span>
            <span class="n">selected_stations</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">valid_sta</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">_network_to_template_map</span> <span class="o">=</span> <span class="n">_network_to_template_map</span> <span class="o">&amp;</span> <span class="n">selected_stations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_network_to_template_map</span> <span class="o">=</span> <span class="n">_network_to_template_map</span></div>


<div class="viewcode-block" id="TemplateGroup.n_best_SNR_stations">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.n_best_SNR_stations">[docs]</a>
    <span class="k">def</span> <span class="nf">n_best_SNR_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust `self.stations` on each template to the `n` best SNR stations.</span>

<span class="sd">        This method calls `template.n_best_SNR_stations` for each Template</span>
<span class="sd">        instance in `self.templates`. For each template, it finds the `n` best</span>
<span class="sd">        SNR stations and modify `template.stations` accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            The `n` best SNR stations.</span>
<span class="sd">        available_stations : list of str, optional</span>
<span class="sd">            The list of stations from which we search the closest stations.</span>
<span class="sd">            If some stations are known to lack data, the user</span>
<span class="sd">            may choose to not include these in the best SNR stations.</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">:</span>
            <span class="n">tp</span><span class="o">.</span><span class="n">n_best_SNR_stations</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">=</span><span class="n">available_stations</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_network_to_template_map&quot;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network_to_template_map</span></div>


<div class="viewcode-block" id="TemplateGroup.n_closest_stations">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.n_closest_stations">[docs]</a>
    <span class="k">def</span> <span class="nf">n_closest_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust `self.stations` on each template to the `n` closest stations.</span>

<span class="sd">        This method calls `template.n_closest_stations` for each Template</span>
<span class="sd">        instance in `self.templates`. For each template, it finds the `n`</span>
<span class="sd">        closest stations and modify `template.stations` accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            The `n` closest stations.</span>
<span class="sd">        available_stations : list of str, optional</span>
<span class="sd">            The list of stations from which we search the closest stations.</span>
<span class="sd">            If some stations are known to lack data, the user</span>
<span class="sd">            may choose to not include these in the closest stations.</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">:</span>
            <span class="n">tp</span><span class="o">.</span><span class="n">n_closest_stations</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">=</span><span class="n">available_stations</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_network_to_template_map&quot;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network_to_template_map</span></div>


<div class="viewcode-block" id="TemplateGroup.read_catalog">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.read_catalog">[docs]</a>
    <span class="k">def</span> <span class="nf">read_catalog</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">extra_attributes</span><span class="o">=</span><span class="p">[],</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a catalog from all templates&#39; detections.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extra_attributes : list of str, optional</span>
<span class="sd">            Additional attributes to read in addition to the default attributes of</span>
<span class="sd">            &#39;longitude&#39;, &#39;latitude&#39;, &#39;depth&#39;, and &#39;origin_time&#39;.</span>
<span class="sd">        fill_value : str, int, or float, optional</span>
<span class="sd">            Default value to use if the target attribute does not exist in a template&#39;s</span>
<span class="sd">            detections.</span>
<span class="sd">        progress : bool, optional</span>
<span class="sd">            If True, display a progress bar during the operation.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to be passed to the `read_catalog`</span>
<span class="sd">            method of each template.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method reads the detection information from each template in the TemplateGroup</span>
<span class="sd">        and builds a catalog that contains the combined detections from all templates.</span>

<span class="sd">        The resulting catalog will include the default attributes of &#39;longitude&#39;, &#39;latitude&#39;,</span>
<span class="sd">        &#39;depth&#39;, and &#39;origin_time&#39;, as well as any additional attributes specified in</span>
<span class="sd">        the `extra_attributes` parameter.</span>

<span class="sd">        If a template does not have a specific attribute in its detections, it will be assigned</span>
<span class="sd">        the `fill_value` for that attribute.</span>

<span class="sd">        The `progress` parameter controls whether a progress bar is displayed during the operation.</span>
<span class="sd">        Setting it to True provides visual feedback on the progress of reading the catalogs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">disable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Reading catalog&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="s2">&quot;catalog&quot;</span><span class="p">):</span>
                <span class="n">template</span><span class="o">.</span><span class="n">read_catalog</span><span class="p">(</span>
                    <span class="n">extra_attributes</span><span class="o">=</span><span class="n">extra_attributes</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
        <span class="c1"># concatenate all catalogs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span> <span class="o">=</span> <span class="n">Catalog</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">template</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span> <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">],</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TemplateGroup.remove_multiples">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.remove_multiples">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_multiples</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_closest_stations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">dt_criterion</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
        <span class="n">distance_criterion</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">speed_criterion</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
        <span class="n">similarity_criterion</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search for events detected by multiple templates and flag them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_closest_stations : int, optional</span>
<span class="sd">            The number of stations closest to each template used in the calculation</span>
<span class="sd">            of the average cross-correlation (cc).</span>
<span class="sd">        dt_criterion : float, optional</span>
<span class="sd">            The time interval, in seconds, under which two events are examined for redundancy.</span>
<span class="sd">        distance_criterion : float, optional</span>
<span class="sd">            The distance threshold, in kilometers, between two uncertainty ellipsoids</span>
<span class="sd">            under which two events are examined for redundancy.</span>
<span class="sd">        speed_criterion : float, optional</span>
<span class="sd">            The speed criterion, in km/s, below which the inter-event time and inter-event</span>
<span class="sd">            distance can be explained by errors in origin times and a reasonable P-wave speed.</span>
<span class="sd">        similarity_criterion : float, optional</span>
<span class="sd">            The template similarity threshold, in terms of average cc, over which two events</span>
<span class="sd">            are examined for redundancy. The default value of -1 means that similarity is not</span>
<span class="sd">            taken into account.</span>
<span class="sd">        progress : bool, optional</span>
<span class="sd">            If True, print progress bar with `tqdm`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method creates a new entry in each Template instance&#39;s catalog where</span>
<span class="sd">        unique events are flagged:</span>
<span class="sd">        `self.templates[i].catalog.catalog[&#39;unique_events&#39;]`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">disable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;catalog&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_catalog</span><span class="p">(</span><span class="n">extra_attributes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cc&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[ms]&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
            <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;origin_time_sec&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;interevent_time_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time_sec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time_sec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># alias:</span>
        <span class="n">catalog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span>
        <span class="k">if</span> <span class="n">similarity_criterion</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_cc&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_intertemplate_cc</span><span class="p">(</span>
                    <span class="n">distance_threshold</span><span class="o">=</span><span class="n">distance_criterion</span><span class="p">,</span>
                    <span class="n">n_stations</span><span class="o">=</span><span class="n">n_closest_stations</span><span class="p">,</span>
                    <span class="n">max_lag</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_lag&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                    <span class="n">device</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;device&quot;</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="c1"># -----------------------------------</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">give_time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Searching for events detected by multiple templates&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;All events occurring within </span><span class="si">{:.1f}</span><span class="s2"> sec, with uncertainty &quot;</span>
            <span class="s2">&quot;ellipsoids closer than </span><span class="si">{:.1f}</span><span class="s2"> km will and &quot;</span>
            <span class="s2">&quot;inter-template CC larger than </span><span class="si">{:.2f}</span><span class="s2"> be considered the same&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">dt_criterion</span><span class="p">,</span> <span class="n">distance_criterion</span><span class="p">,</span> <span class="n">similarity_criterion</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">n_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">)</span>
        <span class="n">index_pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_events</span><span class="p">)</span>
        <span class="c1"># dt_criterion = np.timedelta64(int(1000.0 * dt_criterion), &quot;ms&quot;)</span>
        <span class="n">unique_event</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_events</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_events</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Removing multiples&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">unique_event</span><span class="p">[</span><span class="n">n1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">tid1</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;tid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span>
            <span class="c1"># apply the time criterion</span>
            <span class="c1"># ---------- version 4 ------------</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">n2</span> <span class="o">&lt;</span> <span class="n">n_events</span><span class="p">:</span>
                <span class="n">dt_n1n2</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;interevent_time_sec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">temporal_neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">n1</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">dt_n1n2</span> <span class="o">&lt;</span> <span class="n">dt_criterion</span><span class="p">:</span>
                <span class="n">temporal_neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
                <span class="n">n2</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="o">&gt;=</span> <span class="n">n_events</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">dt_n1n2</span> <span class="o">+=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;interevent_time_sec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span>
            <span class="n">temporal_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">temporal_neighbors</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temporal_neighbors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># did not find any temporal neighbors</span>
                <span class="k">continue</span>
            <span class="c1"># remove events that were already flagged as non unique</span>
            <span class="n">temporal_neighbors</span> <span class="o">=</span> <span class="n">temporal_neighbors</span><span class="p">[</span><span class="n">unique_event</span><span class="p">[</span><span class="n">temporal_neighbors</span><span class="p">]]</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">temporal_neighbors</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># get template ids of all events that passed the time criterion</span>
            <span class="n">tids_candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;tid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
            <span class="c1"># apply the spatial criterion to the distance between</span>
            <span class="c1"># uncertainty ellipsoids</span>
            <span class="n">ellips_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ellipsoid_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tid1</span><span class="p">,</span> <span class="n">tids_candidates</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">time_diff</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time_sec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">candidates</span><span class="p">]</span>
                <span class="o">-</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time_sec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="c1"># if the time difference were to be entirely due to errors in</span>
            <span class="c1"># origin times, what would be wave speed explaining the location</span>
            <span class="c1"># differences?</span>
            <span class="c1"># time_diff = 0 is the time_diff between n1 and n1</span>
            <span class="n">time_diff</span><span class="p">[</span><span class="n">time_diff</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">speed_diff</span> <span class="o">=</span> <span class="n">ellips_dist</span> <span class="o">/</span> <span class="n">time_diff</span>
            <span class="k">if</span> <span class="n">similarity_criterion</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
                <span class="n">similarities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intertemplate_cc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tid1</span><span class="p">,</span> <span class="n">tids_candidates</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">multiples</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="p">(</span><span class="n">ellips_dist</span> <span class="o">&lt;</span> <span class="n">distance_criterion</span><span class="p">)</span>
                            <span class="c1"># | (speed_diff &lt; speed_criterion)</span>
                        <span class="p">)</span>
                        <span class="o">&amp;</span> <span class="p">(</span><span class="n">similarities</span> <span class="o">&gt;=</span> <span class="n">similarity_criterion</span><span class="p">)</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">multiples</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ellips_dist</span> <span class="o">&lt;</span> <span class="n">distance_criterion</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">multiples</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_event</span><span class="p">[</span><span class="n">multiples</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># find best CC and keep it</span>
                <span class="n">ccs</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;cc&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multiples</span><span class="p">]</span>
                <span class="n">best_cc</span> <span class="o">=</span> <span class="n">multiples</span><span class="p">[</span><span class="n">ccs</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
                <span class="n">unique_event</span><span class="p">[</span><span class="n">best_cc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">give_time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s to flag the multiples&quot;</span><span class="p">)</span>
        <span class="c1"># -------------------------------------------</span>
        <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;unique_event&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_event</span>
        <span class="k">for</span> <span class="n">tid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">:</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tindexes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span>
            <span class="n">cat_indexes</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;tid&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">tid</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;unique_event&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="n">cat_indexes</span><span class="p">,</span> <span class="s2">&quot;unique_event&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cat_indexes</span><span class="p">,</span> <span class="s2">&quot;unique_event&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span></div>


    <span class="c1"># plotting routines</span>
<div class="viewcode-block" id="TemplateGroup.plot_detection">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.plot_detection">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the idx-th event in `self.catalog.catalog`.</span>

<span class="sd">        This method identifies which template detected the idx-th event</span>
<span class="sd">        and calls `template.plot_detection` with the appropriate arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        idx : int</span>
<span class="sd">            Event index in `self.catalog.catalog`.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------</span>
<span class="sd">        fig : matplotlib.pyplot.Figure</span>
<span class="sd">            The figure showing the detected event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tid</span><span class="p">,</span> <span class="n">evidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tindexes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">tid</span><span class="p">)]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Plotting:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">plot_detection</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">evidx</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="TemplateGroup.plot_recurrence_times">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.plot_recurrence_times">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_recurrence_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot recurrence times vs detection times, template-wise.</span>

<span class="sd">        This method calls `template.plot_recurrence_times` for every</span>
<span class="sd">        Template instance in `self.templates`. Thus, the recurrence time</span>
<span class="sd">        is defined template-wise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        figsize : tuple of floats, optional</span>
<span class="sd">            Size in inches of the figure (width, height).</span>
<span class="sd">            Defaults to (15, 7).</span>
<span class="sd">        progress : boolean, optional</span>
<span class="sd">            If True, print progress bar with `tqdm`. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">disable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s2">&quot;recurrence_times&quot;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Plotting rec. times&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable</span>
        <span class="p">):</span>
            <span class="n">template</span><span class="o">.</span><span class="n">plot_recurrence_times</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">annotate_axes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Detection Time&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Recurrence Time (s)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">semilogy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span></div>
</div>



<div class="viewcode-block" id="Stack">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Stack">[docs]</a>
<span class="k">class</span> <span class="nc">Stack</span><span class="p">(</span><span class="n">Event</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A modification of the Event class for stacked events.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stacked_traces</span><span class="p">,</span>
        <span class="n">moveouts</span><span class="p">,</span>
        <span class="n">stations</span><span class="p">,</span>
        <span class="n">phases</span><span class="p">,</span>
        <span class="n">latitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">longitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
        <span class="n">sampling_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
        <span class="n">aux_data</span><span class="o">=</span><span class="p">{},</span>
        <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">filtered_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize an Event instance with basic attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stacked_traces : obspy.Stream</span>
<span class="sd">            Traces with the stacked waveforms.</span>
<span class="sd">        moveouts : numpy.ndarray</span>
<span class="sd">            Moveouts, in seconds, for each station and each phase.</span>
<span class="sd">            Shape: (n_stations, n_phases)</span>
<span class="sd">        stations : list of str</span>
<span class="sd">            List of station names corresponding to `moveouts`.</span>
<span class="sd">        phases : list of str</span>
<span class="sd">            List of phase names corresponding to `moveouts`.</span>
<span class="sd">        latitude : float, optional</span>
<span class="sd">            Event latitude.</span>
<span class="sd">        longitude : float, optional</span>
<span class="sd">            Event longitude.</span>
<span class="sd">        depth : float, optional</span>
<span class="sd">            Event depth.</span>
<span class="sd">        sampling_rate : float, optional</span>
<span class="sd">            Sampling rate (Hz) of the waveforms. It should be different from None</span>
<span class="sd">            only if you plan on reading preprocessed data with a fixed sampling rate.</span>
<span class="sd">        components : list of str, optional</span>
<span class="sd">            List of the components to use in reading and plotting methods.</span>
<span class="sd">            Default: [&#39;N&#39;, &#39;E&#39;, &#39;Z&#39;]</span>
<span class="sd">        component_aliases : dict, optional</span>
<span class="sd">            Each entry of the dictionary is a list of strings.</span>
<span class="sd">            `component_aliases[comp]` is the list of all aliases used for the same</span>
<span class="sd">            component &#39;comp&#39;. For example, `component_aliases[&#39;N&#39;] = [&#39;N&#39;, &#39;1&#39;]`</span>
<span class="sd">            means that both the &#39;N&#39; and &#39;1&#39; channels will be mapped to the Event&#39;s</span>
<span class="sd">            &#39;N&#39; channel.</span>
<span class="sd">        aux_data : dict, optional</span>
<span class="sd">            Dictionary with auxiliary data. Note that aux_data[&#39;phase_on_comp{cp}&#39;]</span>
<span class="sd">            is necessary to call `self.read_waveforms`.</span>
<span class="sd">        id : str, optional</span>
<span class="sd">            Identifying label.</span>
<span class="sd">        filtered_data : numpy.ndarray, optional</span>
<span class="sd">            The event waveforms filtered by the SVDWF technique.</span>
<span class="sd">            Shape: (n_events, n_stations, n_components, n_samples)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacked_traces</span> <span class="o">=</span> <span class="n">stacked_traces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_data</span> <span class="o">=</span> <span class="n">filtered_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span>  <span class="c1"># for compatibility with Data class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">stations</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">components</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span> <span class="o">=</span> <span class="n">component_aliases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">latitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span> <span class="o">=</span> <span class="n">longitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate</span>
        <span class="k">if</span> <span class="n">moveouts</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Integer data type detected for moveouts. Are you sure these&quot;</span>
                <span class="s2">&quot; are in seconds?&quot;</span>
            <span class="p">)</span>
        <span class="c1"># format moveouts in a Pandas data frame</span>
        <span class="n">mv_table</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">ph</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">):</span>
            <span class="n">mv_table</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">moveouts</span><span class="p">[:,</span> <span class="n">p</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">mv_table</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">_%H%M%S&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>

<div class="viewcode-block" id="Stack.read_waveforms">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Stack.read_waveforms">[docs]</a>
    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">,</span>
        <span class="n">phase_on_comp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">},</span>
        <span class="n">offset_phase</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">},</span>
        <span class="n">time_shifted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">offset_ot</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">BUFFER_EXTRACTED_EVENTS_SEC</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read waveform data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        duration : float</span>
<span class="sd">            Duration, in seconds, of the extracted time windows.</span>
<span class="sd">        phase_on_comp : dict, optional</span>
<span class="sd">            Dictionary defining which seismic phase is extracted on each component.</span>
<span class="sd">            For example, `phase_on_comp[&#39;N&#39;]` gives the phase that is extracted on the</span>
<span class="sd">            north component.</span>
<span class="sd">        offset_phase : dict, optional</span>
<span class="sd">            Dictionary defining when the time window starts with respect to the pick.</span>
<span class="sd">            A positive offset means the window starts before the pick. Not used if</span>
<span class="sd">            `time_shifted` is False.</span>
<span class="sd">        time_shifted : bool, optional</span>
<span class="sd">            If True, the moveouts are used to extract time windows from specific seismic</span>
<span class="sd">            phases. If False, windows are simply extracted with respect to the origin time.</span>
<span class="sd">        offset_ot : float, optional</span>
<span class="sd">            Only used if `time_shifted` is False. Time, in seconds, taken before `origin_time`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The waveforms are read from `self.stacked_waveforms` and are formatted as</span>
<span class="sd">        obspy.Stream instances that populate the `self.traces` attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span><span class="n">duration</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">):</span>
                <span class="n">ph</span> <span class="o">=</span> <span class="n">phase_on_comp</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">time_shifted</span><span class="p">:</span>
                    <span class="n">mv</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">offset_ot</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span>
                        <span class="o">-</span> <span class="n">offset_phase</span><span class="p">[</span><span class="n">ph</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mv</span> <span class="o">=</span> <span class="n">offset_ot</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stacked_traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">cp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="o">.</span><span class="n">slice</span><span class="p">(</span>
                        <span class="n">starttime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">mv</span><span class="p">,</span>
                        <span class="n">endtime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">mv</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span>
                    <span class="n">starttime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">mv</span><span class="p">,</span>
                    <span class="n">endtime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">mv</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span>
                    <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">+=</span> <span class="n">tr</span>
        <span class="n">aux_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;offset_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">offset_phase</span><span class="p">[</span><span class="n">ph</span><span class="p">]</span> <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">offset_phase</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span><span class="n">aux_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_availability</span><span class="p">(</span><span class="n">stations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">)</span></div>


<div class="viewcode-block" id="Stack.pick_PS_phases_family_mode">
<a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Stack.pick_PS_phases_family_mode">[docs]</a>
    <span class="k">def</span> <span class="nf">pick_PS_phases_family_mode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">,</span>
        <span class="n">threshold_P</span><span class="o">=</span><span class="mf">0.60</span><span class="p">,</span>
        <span class="n">threshold_S</span><span class="o">=</span><span class="mf">0.60</span><span class="p">,</span>
        <span class="n">mini_batch_size</span><span class="o">=</span><span class="mi">126</span><span class="p">,</span>
        <span class="n">phase_on_comp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">},</span>
        <span class="n">upsampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">downsampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">ml_model_name</span><span class="o">=</span><span class="s2">&quot;original&quot;</span><span class="p">,</span>
        <span class="n">ml_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use PhaseNet (Zhu et al., 2019) to pick P and S waves.</span>

<span class="sd">        This method picks P- and S-wave arrivals on every 3-component seismogram</span>
<span class="sd">        in `self.filtered_data`. Thus, potentially many picks can be found on every</span>
<span class="sd">        station and all of them returned in `self.picks`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        duration : float</span>
<span class="sd">            Duration, in seconds, of the time window to process to search</span>
<span class="sd">            for P and S wave arrivals.</span>
<span class="sd">        threshold_P : float, optional</span>
<span class="sd">            Threshold on PhaseNet&#39;s probabilities to trigger the identification</span>
<span class="sd">            of a P-wave arrival. Default: 0.60</span>
<span class="sd">        threshold_S : float, optional</span>
<span class="sd">            Threshold on PhaseNet&#39;s probabilities to trigger the identification</span>
<span class="sd">            of an S-wave arrival. Default: 0.60</span>
<span class="sd">        mini_batch_size : int, optional</span>
<span class="sd">            Number of traces processed in a single batch by PhaseNet.</span>
<span class="sd">            This shouldn&#39;t have to be tuned. Default: 126</span>
<span class="sd">        phase_on_comp : dict, optional</span>
<span class="sd">            Dictionary defining which seismic phase is extracted on each component.</span>
<span class="sd">            For example, `phase_on_comp[&#39;N&#39;]` gives the phase that is extracted on</span>
<span class="sd">            the north component.</span>
<span class="sd">        upsampling : int, optional</span>
<span class="sd">            Upsampling factor applied before calling PhaseNet. Default: 1</span>
<span class="sd">        downsampling : int, optional</span>
<span class="sd">            Downsampling factor applied before calling PhaseNet. Default: 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - PhaseNet must be used with 3-comp data.</span>
<span class="sd">        - If `self.filtered_data` does not exist, `self.pick_PS_phases` is used</span>
<span class="sd">        on the stacked traces.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">no_grad</span><span class="p">,</span> <span class="n">from_numpy</span>

        <span class="k">if</span> <span class="n">ml_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">seisbench.models</span> <span class="k">as</span> <span class="nn">sbm</span>

            <span class="n">ml_model</span> <span class="o">=</span> <span class="n">sbm</span><span class="o">.</span><span class="n">PhaseNet</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">ml_model_name</span><span class="p">)</span>
            <span class="n">ml_model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

        <span class="n">ml_p_index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ml_P_index&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ml_s_index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ml_S_index&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;read_waveforms&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="c1"># read waveforms in &quot;picking&quot; mode</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span>
                <span class="n">duration</span><span class="p">,</span>
                <span class="n">offset_ot</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="n">phase_on_comp</span><span class="o">=</span><span class="n">phase_on_comp</span><span class="p">,</span>
                <span class="n">time_shifted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">data_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">data_arr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_data</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">upsampling</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">downsampling</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">resample_poly</span>

                <span class="n">data_arr</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="n">upsampling</span><span class="p">,</span> <span class="n">downsampling</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># momentarily update samping_rate</span>
                <span class="n">sampling_rate0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span> <span class="o">*</span> <span class="n">upsampling</span> <span class="o">/</span> <span class="n">downsampling</span>
            <span class="n">num_events</span><span class="p">,</span> <span class="n">num_stations</span> <span class="o">=</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">num_traces</span> <span class="o">=</span> <span class="n">num_events</span> <span class="o">*</span> <span class="n">num_stations</span>
            <span class="n">data_arr_n</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_batch</span><span class="p">(</span>
                <span class="n">data_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_traces</span><span class="p">,</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">closest_pow2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">data_arr_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">closest_pow2</span> <span class="o">-</span> <span class="n">data_arr_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">diff</span> <span class="o">%</span> <span class="mi">2</span>
            <span class="n">data_arr_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                <span class="n">data_arr_n</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span>
            <span class="p">)</span>
            <span class="k">with</span> <span class="n">no_grad</span><span class="p">():</span>
                <span class="n">ml_probas</span> <span class="o">=</span> <span class="n">ml_model</span><span class="p">(</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">data_arr_n</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">())</span>
                <span class="n">ml_probas</span> <span class="o">=</span> <span class="n">ml_probas</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="c1"># find picks and sotre in dictionaries</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">],</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">],</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_events</span><span class="p">):</span>
                    <span class="n">tr_idx</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">num_events</span> <span class="o">+</span> <span class="n">n</span>
                    <span class="n">P_proba</span><span class="p">,</span> <span class="n">P_pick</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">trigger_picks</span><span class="p">(</span>
                        <span class="n">ml_probas</span><span class="p">[</span><span class="n">tr_idx</span><span class="p">,</span> <span class="n">ml_p_index</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="o">-</span><span class="n">right</span><span class="p">],</span>
                        <span class="n">threshold_P</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P_proba</span><span class="p">)</span>
                    <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P_pick</span><span class="p">)</span>
                    <span class="n">S_proba</span><span class="p">,</span> <span class="n">S_pick</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">trigger_picks</span><span class="p">(</span>
                        <span class="n">ml_probas</span><span class="p">[</span><span class="n">tr_idx</span><span class="p">,</span> <span class="n">ml_s_index</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="o">-</span><span class="n">right</span><span class="p">],</span>
                        <span class="n">threshold_S</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_proba</span><span class="p">)</span>
                    <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_pick</span><span class="p">)</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]))</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]))</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]))</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]))</span>

            <span class="c1"># format picks in pandas DataFrame</span>
            <span class="n">pandas_picks</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">]:</span>
                <span class="n">rel_picks_sec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
                <span class="n">proba_picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
                <span class="n">abs_picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_picks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">rel_picks_sec</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span>
                        <span class="p">)</span>
                        <span class="n">proba_picks</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">])</span>
                        <span class="n">abs_picks</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
                                    <span class="o">+</span> <span class="n">rel_pick</span><span class="p">,</span>
                                    <span class="s2">&quot;ms&quot;</span><span class="p">,</span>
                                <span class="p">)</span>
                                <span class="k">for</span> <span class="n">rel_pick</span> <span class="ow">in</span> <span class="n">rel_picks_sec</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                <span class="n">pandas_picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_picks_sec</span>
                <span class="n">pandas_picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_probas&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">proba_picks</span>
                <span class="n">pandas_picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_picks</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pandas_picks</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># self.picks.replace(0.0, np.nan, inplace=True)</span>
            <span class="k">if</span> <span class="n">upsampling</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">downsampling</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># reset the sampling rate to initial value</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Stack</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">pick_PS_phases</span><span class="p">(</span>
                <span class="n">duration</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="n">threshold_P</span><span class="o">=</span><span class="n">threshold_P</span><span class="p">,</span>
                <span class="n">threshold_S</span><span class="o">=</span><span class="n">threshold_S</span><span class="p">,</span>
                <span class="n">read_waveforms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Eric Beauce, William B. Frank.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>