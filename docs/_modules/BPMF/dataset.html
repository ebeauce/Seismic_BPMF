<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BPMF.dataset &mdash; BPMF 2.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            BPMF
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../updates.html">Updates</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BPMF</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">BPMF.dataset</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for BPMF.dataset</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">h5py</span> <span class="k">as</span> <span class="nn">h5</span>

<span class="kn">from</span> <span class="nn">.config</span> <span class="kn">import</span> <span class="n">cfg</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span>

<span class="kn">import</span> <span class="nn">obspy</span> <span class="k">as</span> <span class="nn">obs</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">UTCDateTime</span> <span class="k">as</span> <span class="n">udt</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span> <span class="k">as</span> <span class="n">give_time</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>


<div class="viewcode-block" id="Network"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network">[docs]</a><span class="k">class</span> <span class="nc">Network</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Station metadata.</span>

<span class="sd">    Contains station metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network_file</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        network_file: string</span>
<span class="sd">            Name of the station metadata file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NETWORK_PATH</span><span class="p">,</span> <span class="n">network_file</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;stations&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">station_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">networks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;networks&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">latitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">longitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;depth_km&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elevation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;elevation_m&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="Network.box"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network.box">[docs]</a>    <span class="k">def</span> <span class="nf">box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat_min</span><span class="p">,</span> <span class="n">lat_max</span><span class="p">,</span> <span class="n">lon_min</span><span class="p">,</span> <span class="n">lon_max</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Geographical selection of sub-network.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        lat_min: scalar, float</span>
<span class="sd">            Minimum latitude of the box.</span>
<span class="sd">        lat_max: scalar, float</span>
<span class="sd">            Maximum latitude of the box.</span>
<span class="sd">        lon_min: scalar, float</span>
<span class="sd">            Minimum longitude of the box.</span>
<span class="sd">        lon_max: scalar, float</span>
<span class="sd">            Maximum longitude of the box.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------------</span>
<span class="sd">        subnet: Network instance</span>
<span class="sd">            The Network instance restricted to the relevant stations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">&gt;</span> <span class="n">lat_min</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">&lt;</span> <span class="n">lat_max</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span> <span class="o">&gt;</span> <span class="n">lon_min</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span> <span class="o">&lt;</span> <span class="n">lon_max</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">new_stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">[</span><span class="n">selection</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="n">subnet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="n">new_stations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;keep&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subnet</span></div>

<div class="viewcode-block" id="Network.datelist"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network.datelist">[docs]</a>    <span class="k">def</span> <span class="nf">datelist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_date</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_date</span><span class="p">))</span></div>

<div class="viewcode-block" id="Network.read"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the metadata from the file at self.where</span>

<span class="sd">        Note: This function can be modified to match the user&#39;s</span>
<span class="sd">        data convention.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fin</span><span class="p">:</span>
            <span class="n">line1</span> <span class="o">=</span> <span class="n">fin</span><span class="o">.</span><span class="n">readline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_date</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">line1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">end_date</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">line1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">line2</span> <span class="o">=</span> <span class="n">fin</span><span class="o">.</span><span class="n">readline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">line2</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;station_code&quot;</span><span class="p">:</span> <span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="s2">&quot;network_code&quot;</span><span class="p">:</span> <span class="s2">&quot;networks&quot;</span><span class="p">},</span>
            <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;depth_km&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;elevation_m&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1000.0</span>  <span class="c1"># depth in km</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.stations_idx"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network.stations_idx">[docs]</a>    <span class="k">def</span> <span class="nf">stations_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stations</span><span class="p">):</span>
        <span class="c1"># if not isinstance(stations, list) and not isinstance(stations, np.ndarray):</span>
        <span class="c1">#    stations = [stations]</span>
        <span class="c1"># idx = []</span>
        <span class="c1"># for station in stations:</span>
        <span class="c1">#    idx.append(self.stations.index(station))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">station_indexes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">stations</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">idx</span></div>

<div class="viewcode-block" id="Network.subset"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network.subset">[docs]</a>    <span class="k">def</span> <span class="nf">subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;keep&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        stations: list or array of strings</span>
<span class="sd">            Stations to keep or discard, depending on the method.</span>
<span class="sd">        components: list or array of strings</span>
<span class="sd">            Components to keep or discard, depending on the method.</span>
<span class="sd">        method: string, default to &#39;keep&#39;</span>
<span class="sd">            Should be &#39;keep&#39; or &#39;discard&#39;.</span>
<span class="sd">            If &#39;keep&#39;, the stations and components provided to</span>
<span class="sd">            this function are what will be left in the subnetwork.</span>
<span class="sd">            If &#39;discard&#39;, the stations and components provided to</span>
<span class="sd">            this function are what won&#39;t be featured in the</span>
<span class="sd">            subnetwork.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        subnetwork</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">subnetwork</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="n">stations</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="p">[</span><span class="n">stations</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">components</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">components</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;discard&quot;</span><span class="p">:</span>
            <span class="n">subnetwork</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;rows&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">subnetwork</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
                    <span class="n">subnetwork</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> not a network component&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">station</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;keep&quot;</span><span class="p">:</span>
            <span class="n">subnetwork</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">subnetwork</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">stations</span><span class="p">]</span>
            <span class="n">subnetwork</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">components</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;method should be &quot;keep&quot; or &quot;discard&quot;!&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="n">subnetwork</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interstation_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the distance between all station pairs.&quot;&quot;&quot;</span>
        <span class="c1"># should update code to reuse utils.compute_distamces</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_interstation_distances&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interstation_distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stations</span>
        <span class="p">):</span>
            <span class="c1"># was already computed and the size of the network was unchanged</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interstation_distances</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">cartopy.geodesic</span> <span class="kn">import</span> <span class="n">Geodesic</span>

            <span class="n">G</span> <span class="o">=</span> <span class="n">Geodesic</span><span class="p">()</span>

            <span class="n">intersta_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">)):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">[</span><span class="n">s</span><span class="p">]]]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="c1"># d is in m, convert it to km</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1000.0</span>
                <span class="n">intersta_dist</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># return distance in km</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interstation_distances</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">intersta_dist</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interstation_distances</span>

    <span class="c1"># plotting method</span>
<div class="viewcode-block" id="Network.plot_map"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Network.plot_map">[docs]</a>    <span class="k">def</span> <span class="nf">plot_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot stations on map.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        ax: `plt.Axes`, default to None</span>
<span class="sd">            If None, create a new `plt.Figure` and `plt.Axes` instances. If</span>
<span class="sd">            speficied by user, use the provided instance to plot.</span>
<span class="sd">        figsize: tuple of floats, default to (20, 10)</span>
<span class="sd">            Size, in inches, of the figure (width, height).</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        fig: `plt.Figure`</span>
<span class="sd">            The map with seismic stations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">plotting_utils</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">cartopy.crs</span> <span class="kn">import</span> <span class="n">PlateCarree</span>

        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cmap&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">colorcet</span> <span class="k">as</span> <span class="nn">cc</span>

                <span class="n">cmap</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">fire_r</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">cmap</span> <span class="o">=</span> <span class="s2">&quot;hot_r&quot;</span>
        <span class="n">data_coords</span> <span class="o">=</span> <span class="n">PlateCarree</span><span class="p">()</span>
        <span class="n">lat_margin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lat_margin&quot;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="n">lon_margin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lon_margin&quot;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="c1"># ------------------------------------------------</span>
        <span class="c1">#           Scattering plot kwargs</span>
        <span class="n">scatter_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;linewidths&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;linewidths&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;zorder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zorder&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># ------------------------------------------------</span>
        <span class="n">map_longitudes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span> <span class="o">-</span> <span class="n">lon_margin</span><span class="p">,</span>
            <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span> <span class="o">+</span> <span class="n">lon_margin</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">map_latitudes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span> <span class="o">-</span> <span class="n">lat_margin</span><span class="p">,</span>
            <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span> <span class="o">+</span> <span class="n">lat_margin</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">seismic_stations</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;longitude&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
            <span class="s2">&quot;latitude&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
            <span class="s2">&quot;stations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plotting_utils</span><span class="o">.</span><span class="n">initialize_map</span><span class="p">(</span>
            <span class="n">map_longitudes</span><span class="p">,</span>
            <span class="n">map_latitudes</span><span class="p">,</span>
            <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
            <span class="n">map_axis</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">seismic_stations</span><span class="o">=</span><span class="n">seismic_stations</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="Catalog"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog">[docs]</a><span class="k">class</span> <span class="nc">Catalog</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class for catalog data, and basic plotting.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">depths</span><span class="p">,</span> <span class="n">origin_times</span><span class="p">,</span> <span class="n">event_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a catalog attribute as a pandas.DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        longitudes: List or numpy.ndarray of floats</span>
<span class="sd">            Event longitudes.</span>
<span class="sd">        latitudes: List or numpy.ndarray of floats</span>
<span class="sd">            Event latitudes.</span>
<span class="sd">        depths: List or numpy.ndarray of floats</span>
<span class="sd">            Event depths.</span>
<span class="sd">        origin_times: List or numpy.ndarray of strings or datetimes</span>
<span class="sd">            Event origin times.</span>
<span class="sd">        event_ids: List or numpy.ndarray, default to None</span>
<span class="sd">            If not None, is used to define named indexes of the rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">catalog</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">longitudes</span>
        <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">latitudes</span>
        <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">depths</span>
        <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">origin_times</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;datetime64[ms]&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">catalog</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">event_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;event_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">event_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">catalog</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">event_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;event_id&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;origin_time&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">latitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">longitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">origin_time</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">)</span>

<div class="viewcode-block" id="Catalog.concatenate"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.concatenate">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">catalogs</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build catalog from list of `pandas.DataFrame`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        catalogs: list of `pandas.DataFrame`</span>
<span class="sd">            List of `pandas.DataFrame` with consistent columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">catalogs</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="n">ignore_index</span><span class="p">)</span>
        <span class="n">cat</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;origin_time&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="s2">&quot;origin_time&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">cat</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
            <span class="n">cat</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
            <span class="n">cat</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span>
            <span class="n">cat</span><span class="o">.</span><span class="n">origin_time</span><span class="p">,</span>
            <span class="o">**</span><span class="n">cat</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">base</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Catalog.read_from_events"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.read_from_events">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_events</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">extra_attributes</span><span class="o">=</span><span class="p">[],</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build catalog from list of `Event` instances.&quot;&quot;&quot;</span>
        <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">depths</span><span class="p">,</span> <span class="n">origin_times</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">extra_attr</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># initialize empty lists for extra requested attributes</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">extra_attributes</span><span class="p">:</span>
            <span class="n">extra_attr</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">longitudes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span>
            <span class="n">latitudes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>
            <span class="n">depths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">depth</span><span class="p">)</span>
            <span class="n">origin_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">origin_time</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">extra_attributes</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                    <span class="n">extra_attr</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">event</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
                    <span class="c1"># check if attribute is in aux_data</span>
                    <span class="n">extra_attr</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># attribute was not found, fill with default value</span>
                    <span class="n">extra_attr</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">depths</span><span class="p">,</span> <span class="n">origin_times</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_attr</span><span class="p">)</span></div>

<div class="viewcode-block" id="Catalog.read_from_dataframe"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.read_from_dataframe">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_dataframe</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a Catalog instance from a `pandas.DataFrame` instance.&quot;&quot;&quot;</span>
        <span class="n">catalog</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">],</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">],</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">],</span>
            <span class="n">dataframe</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">],</span>
            <span class="o">**</span><span class="n">dataframe</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="s2">&quot;origin_time&quot;</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">catalog</span></div>

<div class="viewcode-block" id="Catalog.read_from_detection_file"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.read_from_detection_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_detection_file</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">OUTPUT_PATH</span><span class="p">,</span>
        <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_attributes</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">return_events</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read all detected events and build catalog.&quot;&quot;&quot;</span>
        <span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">gid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Event</span><span class="o">.</span><span class="n">read_from_file</span><span class="p">(</span><span class="n">hdf5_file</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Error while trying to read the detected events &quot;</span>
                <span class="s2">&quot;(perhaps there are none).&quot;</span>
            <span class="p">)</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="n">return_events</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">read_from_events</span><span class="p">(</span>
                    <span class="n">events</span><span class="p">,</span> <span class="n">extra_attributes</span><span class="o">=</span><span class="n">extra_attributes</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
                <span class="p">),</span>
                <span class="n">events</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">read_from_events</span><span class="p">(</span>
                <span class="n">events</span><span class="p">,</span> <span class="n">extra_attributes</span><span class="o">=</span><span class="n">extra_attributes</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
            <span class="p">)</span></div>

    <span class="c1"># ---------------------------------------------------------</span>
    <span class="c1">#                  Plotting methods</span>
    <span class="c1"># ---------------------------------------------------------</span>
<div class="viewcode-block" id="Catalog.plot_time_statistics"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.plot_time_statistics">[docs]</a>    <span class="k">def</span> <span class="nf">plot_time_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">UTC_local_corr</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the histograms of time of the day and day of the week.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        figsize: tuple of floats, default to (16, 7)</span>
<span class="sd">            Size, in inches, of the figure (width, height).</span>
<span class="sd">        UTC_local_corr : float, optional</span>
<span class="sd">            Apply UTC to local time correction such that:</span>
<span class="sd">                `local_hour = UTC_hour + UTC_local_corr`</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------</span>
<span class="sd">        fig: `plt.Figure`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span>
            <span class="n">num</span><span class="o">=</span><span class="s2">&quot;time_statistics&quot;</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">dayofweek</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="s2">&quot;Mon&quot;</span><span class="p">,</span> <span class="s2">&quot;Tues&quot;</span><span class="p">,</span> <span class="s2">&quot;Wed&quot;</span><span class="p">,</span> <span class="s2">&quot;Thurs&quot;</span><span class="p">,</span> <span class="s2">&quot;Fri&quot;</span><span class="p">,</span> <span class="s2">&quot;Sat&quot;</span><span class="p">,</span> <span class="s2">&quot;Sun&quot;</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Day of the Week&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Event Count&quot;</span><span class="p">)</span>

        <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">hour</span> <span class="o">+</span> <span class="n">UTC_local_corr</span><span class="p">)</span><span class="o">%</span><span class="mi">24</span><span class="p">)</span>\
                <span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Hour of the Day&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Event Count&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="Catalog.plot_map"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.plot_map">[docs]</a>    <span class="k">def</span> <span class="nf">plot_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
        <span class="n">depth_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">depth_max</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span>
        <span class="n">network</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_uncertainties</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">depth_colorbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot epicenters on map.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        ax : matplotlib.pyplot.Axes, default to None</span>
<span class="sd">            If None, create a new `plt.Figure` and `plt.Axes` instances. If</span>
<span class="sd">            speficied by user, use the provided instance to plot.</span>
<span class="sd">        figsize : tuple of floats, default to (20, 10)</span>
<span class="sd">            Size, in inches, of the figure (width, height).</span>
<span class="sd">        depth_min : scalar float, default to 0</span>
<span class="sd">            Smallest depth, in km, in the depth colormap.</span>
<span class="sd">        depth_max : scalar float, default to 20</span>
<span class="sd">            Largest depth, in km, in the depth colormap.</span>
<span class="sd">        network : BPMF.dataset.Network, optional</span>
<span class="sd">            If provided, use information in `network` to plot the stations.</span>
<span class="sd">        plot_uncertainties : boolean, default to False</span>
<span class="sd">            If True, plot the location uncertainty ellipses.</span>
<span class="sd">        depth_colorbar : boolean, default to True</span>
<span class="sd">            If True, plot the depth colorbar on the left.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        fig: matplotlib.pyplot.Figure</span>
<span class="sd">            The figure with depth color-coded epicenters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">plotting_utils</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">Normalize</span>
        <span class="kn">from</span> <span class="nn">matplotlib.cm</span> <span class="kn">import</span> <span class="n">ScalarMappable</span>
        <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
        <span class="kn">from</span> <span class="nn">cartopy.crs</span> <span class="kn">import</span> <span class="n">PlateCarree</span>

        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cmap&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">colorcet</span> <span class="k">as</span> <span class="nn">cc</span>

                <span class="n">cmap</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">fire_r</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">cmap</span> <span class="o">=</span> <span class="s2">&quot;hot_r&quot;</span>
        <span class="n">data_coords</span> <span class="o">=</span> <span class="n">PlateCarree</span><span class="p">()</span>
        <span class="n">lat_margin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lat_margin&quot;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="n">lon_margin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lon_margin&quot;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="c1"># ------------------------------------------------</span>
        <span class="c1">#           Scattering plot kwargs</span>
        <span class="n">scatter_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;linewidths&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;linewidths&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;zorder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zorder&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># ------------------------------------------------</span>
        <span class="k">if</span> <span class="n">network</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">map_longitudes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span> <span class="o">-</span> <span class="n">lon_margin</span><span class="p">,</span>
                <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span> <span class="o">+</span> <span class="n">lon_margin</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">map_latitudes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span> <span class="o">-</span> <span class="n">lat_margin</span><span class="p">,</span>
                <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span> <span class="o">+</span> <span class="n">lat_margin</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">map_longitudes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">network</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">-</span> <span class="n">lon_margin</span><span class="p">,</span>
                <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">network</span><span class="o">.</span><span class="n">longitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">+</span> <span class="n">lon_margin</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">map_latitudes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">network</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">-</span> <span class="n">lat_margin</span><span class="p">,</span>
                <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">network</span><span class="o">.</span><span class="n">latitude</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">+</span> <span class="n">lat_margin</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plotting_utils</span><span class="o">.</span><span class="n">initialize_map</span><span class="p">(</span>
            <span class="n">map_longitudes</span><span class="p">,</span> <span class="n">map_latitudes</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="n">map_axis</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="c1"># plot epicenters</span>
        <span class="n">cNorm</span> <span class="o">=</span> <span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">depth_min</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">depth_max</span><span class="p">)</span>
        <span class="n">scalar_map</span> <span class="o">=</span> <span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
            <span class="n">c</span><span class="o">=</span><span class="n">scalar_map</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">),</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Earthquakes&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">scatter_kwargs</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">data_coords</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_uncertainties</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="s2">&quot;hmax_unc&quot;</span> <span class="ow">in</span> <span class="n">columns</span>
                <span class="ow">and</span> <span class="s2">&quot;hmin_unc&quot;</span> <span class="ow">in</span> <span class="n">columns</span>
                <span class="ow">and</span> <span class="s2">&quot;az_hmax_unc&quot;</span> <span class="ow">in</span> <span class="n">columns</span>
            <span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">)):</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">longitude_ellipse</span><span class="p">,</span> <span class="n">latitude_ellipse</span> <span class="o">=</span> <span class="n">plotting_utils</span><span class="o">.</span><span class="n">uncertainty_ellipse</span><span class="p">(</span>
                        <span class="n">row</span><span class="o">.</span><span class="n">hmax_unc</span><span class="p">,</span>
                        <span class="n">row</span><span class="o">.</span><span class="n">hmin_unc</span><span class="p">,</span>
                        <span class="n">row</span><span class="o">.</span><span class="n">az_hmax_unc</span><span class="p">,</span>
                        <span class="n">row</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
                        <span class="n">row</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">scalar_map</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">color</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">):</span>
                        <span class="c1"># white!</span>
                        <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;dimgrey&quot;</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">longitude_ellipse</span><span class="p">,</span>
                        <span class="n">latitude_ellipse</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                        <span class="n">transform</span><span class="o">=</span><span class="n">data_coords</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;If you want to plot the uncertainty ellipses,&quot;</span>
                    <span class="s2">&quot; self.catalog needs the following columns: &quot;</span>
                    <span class="s2">&quot;hmax_unc, hmin_unc, az_hmax_unc&quot;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">network</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="n">network</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
                <span class="n">network</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
                <span class="n">c</span><span class="o">=</span><span class="s2">&quot;magenta&quot;</span><span class="p">,</span>
                <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;v&quot;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Seismic stations&quot;</span><span class="p">,</span>
                <span class="n">s</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;markersize_station&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                <span class="n">transform</span><span class="o">=</span><span class="n">data_coords</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower right&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">depth_colorbar</span><span class="p">:</span>
            <span class="n">ax_divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">cax</span> <span class="o">=</span> <span class="n">ax_divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;2%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span> <span class="n">axes_class</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scalar_map</span><span class="p">,</span> <span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Depth (km)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span></div>

<div class="viewcode-block" id="Catalog.plot_space_time"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Catalog.plot_space_time">[docs]</a>    <span class="k">def</span> <span class="nf">plot_space_time</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
        <span class="n">color_coded</span><span class="o">=</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span>
        <span class="n">y_axis</span><span class="o">=</span><span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the space-time event distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        ax: `plt.Axes`, default to None</span>
<span class="sd">            If None, create a new `plt.Figure` and `plt.Axes` instances. If</span>
<span class="sd">            speficied by user, use the provided instance to plot.</span>
<span class="sd">        figsize: tuple of floats, default to (20, 10)</span>
<span class="sd">            Size, in inches, of the figure (width, height).</span>
<span class="sd">        color_coded: string, default to &#39;longitude&#39;</span>
<span class="sd">            Can be either &#39;longitude&#39;, &#39;latitude&#39;, or &#39;depth&#39;. This is the</span>
<span class="sd">            attribute used to define the color scale of each dot.</span>
<span class="sd">        y_axis: string, default to &#39;latitude&#39;</span>
<span class="sd">            Can be either &#39;longitude&#39;, &#39;latitude&#39;, or &#39;depth&#39;. This is the</span>
<span class="sd">            attribute used to define the y-axis coordinates.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        fig: `plt.Figure`</span>
<span class="sd">            The figure with color coded latitudes or longitudes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">Normalize</span>
        <span class="kn">from</span> <span class="nn">matplotlib.cm</span> <span class="kn">import</span> <span class="n">ScalarMappable</span>
        <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>

        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cmap&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">colorcet</span> <span class="k">as</span> <span class="nn">cc</span>

                <span class="n">cmap</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">bjy</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">cmap</span> <span class="o">=</span> <span class="s2">&quot;viridis&quot;</span>
        <span class="c1"># ------------------------------------------------</span>
        <span class="c1">#           Scattering plot kwargs</span>
        <span class="n">scatter_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;linewidths&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;linewidths&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;s&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">scatter_kwargs</span><span class="p">[</span><span class="s2">&quot;zorder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zorder&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># ------------------------------------------------</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;figname&quot;</span><span class="p">,</span> <span class="s2">&quot;space_time&quot;</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
        <span class="n">cNorm</span> <span class="o">=</span> <span class="n">Normalize</span><span class="p">(</span>
            <span class="n">vmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="n">color_coded</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">vmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="n">color_coded</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">scalar_map</span> <span class="o">=</span> <span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">scalar_map</span><span class="o">.</span><span class="n">set_array</span><span class="p">([])</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">)</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> events&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Calendar Time&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">y_axis</span><span class="o">.</span><span class="n">capitalize</span><span class="p">())</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="n">y_axis</span><span class="p">],</span>
            <span class="n">color</span><span class="o">=</span><span class="n">scalar_map</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="n">color_coded</span><span class="p">]),</span>
            <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">scatter_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]))</span>

        <span class="n">ax_divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">ax_divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;2%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.08</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span>
            <span class="n">scalar_map</span><span class="p">,</span> <span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">color_coded</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div></div>


<div class="viewcode-block" id="Data"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Data">[docs]</a><span class="k">class</span> <span class="nc">Data</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Data class to manipulate waveforms and metadata.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">date</span><span class="p">,</span>
        <span class="n">where</span><span class="p">,</span>
        <span class="n">data_reader</span><span class="p">,</span>
        <span class="n">duration</span><span class="o">=</span><span class="mf">24.0</span> <span class="o">*</span> <span class="mf">3600.0</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        date: string</span>
<span class="sd">            Date of the requested day. Example: &#39;2016-01-23&#39;.</span>
<span class="sd">        where: string</span>
<span class="sd">            Path to root folder or data file itself (depending on the data</span>
<span class="sd">            reader you are using).</span>
<span class="sd">        data_reader: function</span>
<span class="sd">            Function that takes a path and optional key-word arguments to read</span>
<span class="sd">            data from this path and returns an `obspy.Stream` instance.</span>
<span class="sd">        duration: float, default to 24*3600</span>
<span class="sd">            Target duration, in seconds, of the waveform time series. Waveforms</span>
<span class="sd">            will be trimmed and zero-padded to match this duration.</span>
<span class="sd">        sampling_rate: float or int, default to None</span>
<span class="sd">            Sampling rate of the data. This variable should be left to None if</span>
<span class="sd">            this Data instance aims at dealing with raw data and multiple</span>
<span class="sd">            sampling rates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
        <span class="c1"># full path:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="n">where</span>
        <span class="c1"># data reader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_reader</span> <span class="o">=</span> <span class="n">data_reader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="c1"># fetch metadata</span>
        <span class="c1"># self._read_metadata()</span>
        <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span><span class="n">duration</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;sampling_rate&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You need to define the instance&#39;s sampling rate first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_time&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">time_range</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;ms&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span>

<div class="viewcode-block" id="Data.get_np_array"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Data.get_np_array">[docs]</a>    <span class="k">def</span> <span class="nf">get_np_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stations</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
        <span class="n">priority</span><span class="o">=</span><span class="s2">&quot;HH&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You should call read_waveforms first.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">,</span>
            <span class="n">stations</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">priority</span><span class="p">,</span>
            <span class="n">component_aliases</span><span class="o">=</span><span class="n">component_aliases</span><span class="p">,</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Data.read_waveforms"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Data.read_waveforms">[docs]</a>    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trim_traces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">reader_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the waveform time series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        trim_traces: boolean, default to True</span>
<span class="sd">            If True, call `trim_waveforms` to make sure all traces have the same</span>
<span class="sd">            start time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reader_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
        <span class="n">reader_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;endtime&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_reader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">,</span> <span class="o">**</span><span class="n">reader_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trim_traces</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trim_waveforms</span><span class="p">()</span></div>

<div class="viewcode-block" id="Data.set_availability"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Data.set_availability">[docs]</a>    <span class="k">def</span> <span class="nf">set_availability</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stations</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the data availability.</span>

<span class="sd">        A station is available if at least one station has non-zero data. The</span>
<span class="sd">        availability is then accessed via the property `self.availability`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        stations: list of strings or numpy.ndarray</span>
<span class="sd">            Names of the stations on which we check availability. If None, use</span>
<span class="sd">            `self.stations`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.read_waveforms` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">availability_per_sta</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">availability_per_cha</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">stations</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">components</span><span class="p">):</span>
            <span class="n">availability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stations</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">cp_alias</span> <span class="ow">in</span> <span class="n">component_aliases</span><span class="p">[</span><span class="n">cp</span><span class="p">]:</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">cp_alias</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">):</span>
                        <span class="n">availability</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">availability_per_cha</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span> <span class="o">=</span> <span class="n">availability</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">availability_per_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">availability_per_sta</span><span class="p">,</span> <span class="n">availability</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">availability</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability_per_sta</span></div>

<div class="viewcode-block" id="Data.trim_waveforms"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Data.trim_waveforms">[docs]</a>    <span class="k">def</span> <span class="nf">trim_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Trim waveforms.</span>

<span class="sd">        Start times might differ of one sample on different traces. Use this</span>
<span class="sd">        method to make sure all traces have the same start time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        starttime: string or datetime, default to None</span>
<span class="sd">            If None, use `self.date` as the start time.</span>
<span class="sd">        endtime: string or datetime, default to None</span>
<span class="sd">            If None, use `self.date` + `self.duration` as the end time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You should call `read_waveforms` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">starttime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span>
        <span class="k">if</span> <span class="n">endtime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">endtime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Event"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event">[docs]</a><span class="k">class</span> <span class="nc">Event</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An Event class to describe *any* collection of waveforms.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">origin_time</span><span class="p">,</span>
        <span class="n">moveouts</span><span class="p">,</span>
        <span class="n">stations</span><span class="p">,</span>
        <span class="n">phases</span><span class="p">,</span>
        <span class="n">data_filename</span><span class="p">,</span>
        <span class="n">data_path</span><span class="p">,</span>
        <span class="n">latitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">longitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
        <span class="n">sampling_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
        <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_reader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize an Event instance with basic attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        origin_time: string</span>
<span class="sd">            Origin time, or detection time, of the event. Phase picks are</span>
<span class="sd">            defined by origin_time + moveout.</span>
<span class="sd">        moveouts: (n_stations, n_phases) float numpy.ndarray</span>
<span class="sd">            Moveouts, in seconds, for each station and each phase.</span>
<span class="sd">        stations: List of strings</span>
<span class="sd">            List of station names corresponding to `moveouts`.</span>
<span class="sd">        phases: List of strings</span>
<span class="sd">            List of phase names corresponding to `moveouts`.</span>
<span class="sd">        data_filename: string</span>
<span class="sd">            Name of the data file.</span>
<span class="sd">        data_path: string</span>
<span class="sd">            Path to the data directory.</span>
<span class="sd">        latitude: scalar float, default to None</span>
<span class="sd">            Event latitude.</span>
<span class="sd">        longitude: scalar float, default to None</span>
<span class="sd">            Event longitude.</span>
<span class="sd">        depth: scalar float, default to None</span>
<span class="sd">            Event depth.</span>
<span class="sd">        sampling_rate: scalar float, default to None</span>
<span class="sd">            Sampling rate (Hz) of the waveforms. It should be different from</span>
<span class="sd">            None only if you plan on reading preprocessed data with a fixed</span>
<span class="sd">            sampling rate.</span>
<span class="sd">        components: List of strings, default to [&#39;N&#39;,&#39;E&#39;,&#39;Z&#39;]</span>
<span class="sd">            List of the components to use in reading and plotting methods.</span>
<span class="sd">        component_aliases: Dictionary, optional</span>
<span class="sd">            Each entry of the dictionary is a list of strings.</span>
<span class="sd">            `component_aliases[comp]` is the list of all aliases used for</span>
<span class="sd">            the same component &#39;comp&#39;. For example, `component_aliases[&#39;N&#39;] =</span>
<span class="sd">            [&#39;N&#39;, &#39;1&#39;]` means that both the &#39;N&#39; and &#39;1&#39; channels will be mapped</span>
<span class="sd">            to the Event&#39;s &#39;N&#39; channel.</span>
<span class="sd">        id: string, default to None</span>
<span class="sd">            Identifying label.</span>
<span class="sd">        data_reader: function, default to None</span>
<span class="sd">            Function that takes a path and optional key-word arguments to read</span>
<span class="sd">            data from this path and returns an `obspy.Stream` instance. If None,</span>
<span class="sd">            `data_reader` has to be specified when calling `read_waveforms`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">origin_time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span>  <span class="c1"># for compatibility with Data class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span> <span class="n">data_filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">stations</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">components</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span> <span class="o">=</span> <span class="n">component_aliases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">latitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span> <span class="o">=</span> <span class="n">longitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate</span>
        <span class="k">if</span> <span class="n">moveouts</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Integer data type detected for moveouts. Are you sure these&quot;</span>
                <span class="s2">&quot; are in seconds?&quot;</span>
            <span class="p">)</span>
        <span class="c1"># format moveouts in a Pandas data frame</span>
        <span class="n">mv_table</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">ph</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">):</span>
            <span class="n">mv_table</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">moveouts</span><span class="p">[:,</span> <span class="n">p</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">mv_table</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">_%H%M%S&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_reader</span> <span class="o">=</span> <span class="n">data_reader</span>

<div class="viewcode-block" id="Event.read_from_file"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.read_from_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_file</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">INPUT_PATH</span><span class="p">,</span>
        <span class="n">hdf5_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_reader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize an Event instance from `filename`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        filename: string, default to None</span>
<span class="sd">            Name of the hdf5 file with the event&#39;s data. If None, then</span>
<span class="sd">            `hdf5_file` should be specified.</span>
<span class="sd">        db_path: string, default to `cfg.INPUT_PATH`</span>
<span class="sd">            Name of the directory where `filename` is located.</span>
<span class="sd">        gid: string, default to None</span>
<span class="sd">            If not None, this string is the hdf5&#39;s group name of the event.</span>
<span class="sd">        hdf5_file: `h5py.File`, default to None</span>
<span class="sd">            If not None, is an opened file pointing directly at the subfolder of</span>
<span class="sd">            interest.</span>
<span class="sd">        data_reader: function, default to None</span>
<span class="sd">            Function that takes a path and optional key-word arguments to read</span>
<span class="sd">            data from this path and returns an `obspy.Stream` instance. If None,</span>
<span class="sd">            `data_reader` has to be specified when calling `read_waveforms`.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        event: `Event` instance</span>
<span class="sd">            The `Event` instance defined by the data in `filename`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">,</span> <span class="s2">&quot;moveouts&quot;</span><span class="p">,</span> <span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="s2">&quot;phases&quot;</span><span class="p">]</span>
        <span class="n">optional_attr</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
            <span class="s2">&quot;longitude&quot;</span><span class="p">,</span>
            <span class="s2">&quot;depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sampling_rate&quot;</span><span class="p">,</span>
            <span class="s2">&quot;compoments&quot;</span><span class="p">,</span>
            <span class="s2">&quot;id&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">has_picks</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">has_arrivals</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">close_file</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent_file</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
            <span class="n">path_database</span> <span class="o">=</span> <span class="n">parent_file</span><span class="o">.</span><span class="n">filename</span>
            <span class="k">if</span> <span class="n">gid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># go to specified group</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">parent_file</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">parent_file</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># remember to close file at the end</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">hdf5_file</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">&quot;file&quot;</span><span class="p">):</span>
                <span class="n">path_database</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">filename</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">path_database</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">attr</span><span class="p">][()])</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;where&quot;</span><span class="p">][()])</span> <span class="o">==</span> <span class="nb">bytes</span><span class="p">:</span>
            <span class="c1"># if h5py.version &gt;= 3</span>
            <span class="n">data_path</span><span class="p">,</span> <span class="n">data_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;where&quot;</span><span class="p">][()]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># more recent versions of h5py seems to decode automatically</span>
            <span class="n">data_path</span><span class="p">,</span> <span class="n">data_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;where&quot;</span><span class="p">][()])</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">data_filename</span><span class="p">,</span> <span class="n">data_path</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">opt_attr</span> <span class="ow">in</span> <span class="n">optional_attr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">opt_attr</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">opt_attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">opt_attr</span><span class="p">][()]</span>
        <span class="n">aux_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s2">&quot;aux_data&quot;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">][()]</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">==</span> <span class="nb">bytes</span><span class="p">:</span>
                    <span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;picks&quot;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;picks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">picks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;picks&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">][()]</span>
                <span class="k">if</span> <span class="n">picks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                    <span class="n">picks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;stations&quot;</span><span class="p">:</span>
                        <span class="n">picks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">picks</span><span class="p">)</span>
            <span class="n">picks</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">has_picks</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="s2">&quot;arrival_times&quot;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">arrival_times</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;arrival_times&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">arrival_times</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;arrival_times&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">][()]</span>
                <span class="k">if</span> <span class="n">arrival_times</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                    <span class="n">arrival_times</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arrival_times</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;stations&quot;</span><span class="p">:</span>
                        <span class="n">arrival_times</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">arrival_times</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">arrival_times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">arrival_times</span><span class="p">)</span>
            <span class="n">arrival_times</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">has_arrivals</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
            <span class="c1"># close the file</span>
            <span class="n">parent_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># ! the order of args is important !</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;data_reader&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_reader</span>
        <span class="n">event</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;cov_mat&quot;</span> <span class="ow">in</span> <span class="n">aux_data</span><span class="p">:</span>
            <span class="n">event</span><span class="o">.</span><span class="n">cov_mat</span> <span class="o">=</span> <span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;cov_mat&quot;</span><span class="p">]</span>
        <span class="n">event</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span><span class="n">aux_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">has_picks</span><span class="p">:</span>
            <span class="n">event</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="n">picks</span>
        <span class="k">if</span> <span class="n">has_arrivals</span><span class="p">:</span>
            <span class="n">event</span><span class="o">.</span><span class="n">arrival_times</span> <span class="o">=</span> <span class="n">arrival_times</span>
        <span class="k">if</span> <span class="n">gid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># keep trace that we read from a group</span>
            <span class="n">event</span><span class="o">.</span><span class="n">hdf5_gid</span> <span class="o">=</span> <span class="n">gid</span>
        <span class="n">event</span><span class="o">.</span><span class="n">path_database</span> <span class="o">=</span> <span class="n">path_database</span>
        <span class="k">return</span> <span class="n">event</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">availability</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;availability&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;availability&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.set_availability` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">availability_per_sta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_availability_per_sta&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_sta</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;availability_per_sta&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;availability_per_sta&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.set_availability` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">availability_per_cha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_availability_per_cha&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_cha</span>
        <span class="n">availability</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="sa">f</span><span class="s2">&quot;availability_</span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
                <span class="n">availability</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">cp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span>
                    <span class="sa">f</span><span class="s2">&quot;availability_</span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.set_availability` first.&quot;</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">return</span> <span class="n">availability</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hmax_unc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_hmax_unc&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hmax_unc</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;hmax_unc&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;hmax_unc&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hor_ver_uncertainties</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hmax_unc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hmin_unc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_hmin_unc&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hmin_unc</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;hmin_unc&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;hmin_unc&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hor_ver_uncertainties</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hmin_unc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vmax_unc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_vmax_unc&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vmax_unc</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;vmax_unc&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;vmax_unc&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hor_ver_uncertainties</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vmax_unc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">az_hmax_unc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_az_hmax_unc&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmax_unc</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;az_hmax_unc&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;az_hmax_unc&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hor_ver_uncertainties</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmax_unc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">az_hmin_unc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_az_hmin_unc&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmin_unc</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;az_hmin_unc&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;az_hmin_unc&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hor_ver_uncertainties</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmin_unc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pl_vmax_unc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_pl_vmax_unc&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pl_vmax_unc</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;pl_vmax_unc&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;pl_vmax_unc&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hor_ver_uncertainties</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pl_vmax_unc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source_receiver_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_source_receiver_dist&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_receiver_dist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;You need to set source_receiver_dist before.&quot;</span>
                <span class="s2">&quot; Call self.set_source_receiver_dist(network)&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>

<div class="viewcode-block" id="Event.get_np_array"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.get_np_array">[docs]</a>    <span class="k">def</span> <span class="nf">get_np_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="s2">&quot;HH&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You should call read_waveforms first.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">,</span>
            <span class="n">stations</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">priority</span><span class="p">,</span>
            <span class="n">component_aliases</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span><span class="p">,</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Event.get_peak_amplitudes"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.get_peak_amplitudes">[docs]</a>    <span class="k">def</span> <span class="nf">get_peak_amplitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get peak waveform amplitudes.</span>

<span class="sd">        The peak waveform amplitudes are typically used to compute</span>
<span class="sd">        amplitude-based local magnitudes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stations : list of strings</span>
<span class="sd">            Names of the stations to include in the output array. Define the order</span>
<span class="sd">            of the station axis.</span>
<span class="sd">        components : list of strings, default to [&#39;N&#39;,&#39;E&#39;,&#39;Z&#39;]</span>
<span class="sd">            Names of the components to include in the output array. Define the order</span>
<span class="sd">            of the component axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        peak_amplitudes : numpy.ndarray</span>
<span class="sd">            (num_stations, num_components) numpy.ndarray with the peak</span>
<span class="sd">            waveform amplitude on each channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">waveforms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">)</span>
        <span class="n">peak_amplitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">waveforms</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">peak_amplitudes</span></div>


<div class="viewcode-block" id="Event.hor_ver_uncertainties"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.hor_ver_uncertainties">[docs]</a>    <span class="k">def</span> <span class="nf">hor_ver_uncertainties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;intersection&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the horizontal and vertical uncertainties on location.</span>

<span class="sd">        Return errors as given by the 68% confidence ellipsoid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------------</span>
<span class="sd">        mode: string, default to &#39;intersection&#39;</span>
<span class="sd">            Either &#39;intersection&#39; or &#39;projection&#39;. If `mode` is &#39;intersection&#39;, the</span>
<span class="sd">            horizontal uncertainties are the lengths of the semi-axes of the ellipse</span>
<span class="sd">            defined by the intersection between the confidence ellipsoid and the</span>
<span class="sd">            horizontal plane. This is consistent with the horizontal errors returned</span>
<span class="sd">            by NLLoc. If mode is &#39;projection&#39;, the horizontal uncertainties are the</span>
<span class="sd">            max and min span of the confidence ellipsoid in the horizontal</span>
<span class="sd">            directions.</span>

<span class="sd">        New Attributes</span>
<span class="sd">        ----------------</span>
<span class="sd">        hmax_unc: scalar, float</span>
<span class="sd">            The maximum horizontal uncertainty, in km.</span>
<span class="sd">        hmin_unc: scalar, float</span>
<span class="sd">            The minimum horizontal uncertainty, in km.</span>
<span class="sd">        vmax_unc: scalar, float</span>
<span class="sd">            The maximum vertical uncertainty, in km.</span>
<span class="sd">        az_hmax_unc: scalar, float</span>
<span class="sd">            The azimuth (angle from north) of the maximum horizontal</span>
<span class="sd">            uncertainty, in degrees.</span>
<span class="sd">        az_hmin_unc: scalar, float</span>
<span class="sd">            The azimuth (angle from north) of the minimum horizontal</span>
<span class="sd">            uncertainty, in degrees.</span>

<span class="sd">        Note: hmax + vmax does not have to be equal to the</span>
<span class="sd">        max_loc, the latter simply being the length of the</span>
<span class="sd">        longest semi-axis of the uncertainty ellipsoid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cov_mat&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Class instance does not have a `cov_mat` attribute.&quot;</span><span class="p">)</span>
            <span class="c1"># these private attributes should be called via their property names</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hmax_unc</span> <span class="o">=</span> <span class="mf">15.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hmin_unc</span> <span class="o">=</span> <span class="mf">15.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vmax_unc</span> <span class="o">=</span> <span class="mf">15.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmax_unc</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmin_unc</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">return</span>
        <span class="c1"># X: west, Y: south, Z: downward</span>
        <span class="n">s_68_3df</span> <span class="o">=</span> <span class="mf">3.52</span>
        <span class="n">s_68_2df</span> <span class="o">=</span> <span class="mf">2.28</span>
        <span class="c1"># eigendecomposition of whole matrix</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span><span class="p">)</span>
        <span class="n">semi_axis_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_68_3df</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
        <span class="c1"># check the vertical components of all semi-axes:</span>
        <span class="n">vertical_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">semi_axis_length</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;intersection&quot;</span><span class="p">:</span>
            <span class="c1"># eigendecomposition of cov mat restricted to horizontal components</span>
            <span class="n">wh</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">semi_axis_length_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_68_2df</span> <span class="o">*</span> <span class="n">wh</span><span class="p">)</span>
            <span class="n">hmax_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">semi_axis_length_h</span><span class="p">)</span>
            <span class="n">hmin_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">semi_axis_length_h</span><span class="p">)</span>
            <span class="n">hmax_dir</span> <span class="o">=</span> <span class="n">vh</span><span class="p">[:,</span> <span class="n">wh</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
            <span class="n">hmin_dir</span> <span class="o">=</span> <span class="n">vh</span><span class="p">[:,</span> <span class="n">wh</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
            <span class="n">az_hmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">hmax_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">hmax_dir</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">az_hmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">hmin_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">hmin_dir</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;projection&quot;</span><span class="p">:</span>
            <span class="c1"># check the horizontal components of all semi-axes:</span>
            <span class="n">horizontal_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">semi_axis_length</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">hmax_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">horizontal_unc</span><span class="p">)</span>
            <span class="n">hmin_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">horizontal_unc</span><span class="p">)</span>
            <span class="n">hmax_dir</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">horizontal_unc</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
            <span class="n">hmin_dir</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">horizontal_unc</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
            <span class="n">az_hmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">hmax_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">hmax_dir</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">az_hmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">hmin_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">hmin_dir</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="c1"># these private attributes should be called via their property names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hmax_unc</span> <span class="o">=</span> <span class="n">hmax_unc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hmin_unc</span> <span class="o">=</span> <span class="n">hmin_unc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vmax_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vertical_unc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pl_vmax_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">vertical_unc</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pl_vmax_unc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pl_vmax_unc</span><span class="p">,</span> <span class="mf">180.</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pl_vmax_unc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmax_unc</span> <span class="o">=</span> <span class="n">az_hmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmin_unc</span> <span class="o">=</span> <span class="n">az_hmin</span></div>

<div class="viewcode-block" id="Event.n_closest_stations"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.n_closest_stations">[docs]</a>    <span class="k">def</span> <span class="nf">n_closest_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust `self.stations` to the `n` closest stations.</span>


<span class="sd">        Find the `n` closest stations and modify `self.stations` accordingly.</span>
<span class="sd">        The instance&#39;s properties will also change accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        n: scalar int</span>
<span class="sd">            The `n` closest stations to fetch.</span>
<span class="sd">        available_stations: list of strings, default to None</span>
<span class="sd">            The list of stations from which we search the closest stations.</span>
<span class="sd">            If some stations are known to lack data, the user</span>
<span class="sd">            may choose to not include these in the closest stations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;network_stations&quot;</span><span class="p">):</span>
            <span class="c1"># typically, an Event instance has no network_stations</span>
            <span class="c1"># attribute, but a Template instance does</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># re-initialize the stations attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">index_pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">))</span>
        <span class="c1"># limit the index pool to available stations</span>
        <span class="k">if</span> <span class="n">available_stations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">availability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">available_stations</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">availability</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability</span>
        <span class="n">station_pool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="n">closest_stations</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source_receiver_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station_pool</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># make sure we return a n-vector</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_stations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_stations</span><span class="p">)</span>
            <span class="n">closest_stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">closest_stations</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_receiver_dist</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">closest_stations</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;rows&quot;</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="n">missing</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">closest_stations</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Event.pick_PS_phases_EQTransformer"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.pick_PS_phases_EQTransformer">[docs]</a>    <span class="k">def</span> <span class="nf">pick_PS_phases_EQTransformer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">,</span>
        <span class="n">threshold_P</span><span class="o">=</span><span class="mf">0.60</span><span class="p">,</span>
        <span class="n">threshold_S</span><span class="o">=</span><span class="mf">0.60</span><span class="p">,</span>
        <span class="n">offset_ot</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">BUFFER_EXTRACTED_EVENTS_SEC</span><span class="p">,</span>
        <span class="n">phase_on_comp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">},</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use PhaseNet (Zhu et al., 2019) to pick P and S waves (Event class).</span>

<span class="sd">        Note1: PhaseNet must be used with 3-comp data.</span>
<span class="sd">        Note2: Extra kwargs are passed to</span>
<span class="sd">        `phasenet.wrapper.automatic_detection`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        duration: scalar float</span>
<span class="sd">            Duration, in seconds, of the time window to process to search for P</span>
<span class="sd">            and S wave arrivals.</span>
<span class="sd">        tag: string</span>
<span class="sd">            Tag name of the target data. For example: &#39;preprocessed_1_12&#39;.</span>
<span class="sd">        threshold_P: scalar float, default to 0.60</span>
<span class="sd">            Threshold on PhaseNet&#39;s probabilities to trigger the identification</span>
<span class="sd">            of a P-wave arrival.</span>
<span class="sd">        threshold_S: scalar float, default to 0.60</span>
<span class="sd">            Threshold on PhaseNet&#39;s probabilities to trigger the identification</span>
<span class="sd">            of a S-wave arrival.</span>
<span class="sd">        mini_batch_size: scalar int, default to 126</span>
<span class="sd">            Number of traces processed in a single batch by PhaseNet. This</span>
<span class="sd">            shouldn&#39;t have to be tuned.</span>
<span class="sd">        phase_on_comp: dictionary, optional</span>
<span class="sd">            Dictionary defining which seismic phase is extracted on each</span>
<span class="sd">            component. For example, phase_on_comp[&#39;N&#39;] gives the phase that is</span>
<span class="sd">            extracted on the north component.</span>
<span class="sd">        component_aliases: Dictionary</span>
<span class="sd">            Each entry of the dictionary is a list of strings.</span>
<span class="sd">            `component_aliases[comp]` is the list of all aliases used for</span>
<span class="sd">            the same component &#39;comp&#39;. For example, `component_aliases[&#39;N&#39;] =</span>
<span class="sd">            [&#39;N&#39;, &#39;1&#39;]` means that both the &#39;N&#39; and &#39;1&#39; channels will be mapped</span>
<span class="sd">            to the Event&#39;s &#39;N&#39; channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">seisbench.models</span> <span class="k">as</span> <span class="nn">sbm</span>

        <span class="c1"># load model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">sbm</span><span class="o">.</span><span class="n">EQTransformer</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="s2">&quot;original&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;read_waveforms&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="c1"># read waveforms in picking mode, i.e. with `time_shifted`=False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span>
                <span class="n">duration</span><span class="p">,</span>
                <span class="n">offset_ot</span><span class="o">=</span><span class="n">offset_ot</span><span class="p">,</span>
                <span class="n">phase_on_comp</span><span class="o">=</span><span class="n">phase_on_comp</span><span class="p">,</span>
                <span class="n">component_aliases</span><span class="o">=</span><span class="n">component_aliases</span><span class="p">,</span>
                <span class="n">time_shifted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ML_picks</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">classify</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">,</span>
            <span class="n">P_threshold</span><span class="o">=</span><span class="n">threshold_P</span><span class="p">,</span>
            <span class="n">S_threshold</span><span class="o">=</span><span class="n">threshold_S</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># add picks to auxiliary data</span>
        <span class="c1"># self.set_aux_data(PhaseNet_picks)</span>
        <span class="c1"># format picks in pandas DataFrame</span>
        <span class="n">pandas_picks</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;P_picks_sec&quot;</span><span class="p">,</span>
                <span class="s2">&quot;P_probas&quot;</span><span class="p">,</span>
                <span class="s2">&quot;P_abs_picks&quot;</span><span class="p">,</span>
                <span class="s2">&quot;S_picks_sec&quot;</span><span class="p">,</span>
                <span class="s2">&quot;S_probas&quot;</span><span class="p">,</span>
                <span class="s2">&quot;S_abs_picks&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">pick</span> <span class="ow">in</span> <span class="n">ML_picks</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">sta</span> <span class="o">=</span> <span class="n">pick</span><span class="o">.</span><span class="n">trace_id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">pandas_picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pick</span><span class="o">.</span><span class="n">phase</span><span class="si">}</span><span class="s2">_probas&quot;</span><span class="p">])</span>
                <span class="ow">and</span> <span class="n">pick</span><span class="o">.</span><span class="n">peak_value</span> <span class="o">&gt;</span> <span class="n">pandas_picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pick</span><span class="o">.</span><span class="n">phase</span><span class="si">}</span><span class="s2">_probas&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">pandas_picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pick</span><span class="o">.</span><span class="n">phase</span><span class="si">}</span><span class="s2">_probas&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pick</span><span class="o">.</span><span class="n">peak_value</span>
                <span class="n">pandas_picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pick</span><span class="o">.</span><span class="n">phase</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">pick</span><span class="o">.</span><span class="n">peak_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span>
                <span class="p">)</span>
                <span class="n">pandas_picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pick</span><span class="o">.</span><span class="n">phase</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pick</span><span class="o">.</span><span class="n">peak_time</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pandas_picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pick</span><span class="o">.</span><span class="n">phase</span><span class="si">}</span><span class="s2">_probas&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pick</span><span class="o">.</span><span class="n">peak_value</span>
                <span class="n">pandas_picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pick</span><span class="o">.</span><span class="n">phase</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">pick</span><span class="o">.</span><span class="n">peak_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span>
                <span class="p">)</span>
                <span class="n">pandas_picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pick</span><span class="o">.</span><span class="n">phase</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pick</span><span class="o">.</span><span class="n">peak_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="n">pandas_picks</span></div>

<div class="viewcode-block" id="Event.pick_PS_phases"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.pick_PS_phases">[docs]</a>    <span class="k">def</span> <span class="nf">pick_PS_phases</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">,</span>
        <span class="n">threshold_P</span><span class="o">=</span><span class="mf">0.60</span><span class="p">,</span>
        <span class="n">threshold_S</span><span class="o">=</span><span class="mf">0.60</span><span class="p">,</span>
        <span class="n">offset_ot</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">BUFFER_EXTRACTED_EVENTS_SEC</span><span class="p">,</span>
        <span class="n">mini_batch_size</span><span class="o">=</span><span class="mi">126</span><span class="p">,</span>
        <span class="n">phase_on_comp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">},</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
        <span class="n">upsampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">downsampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">use_apriori_picks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">search_win_sec</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
        <span class="n">ml_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ml_model_name</span><span class="o">=</span><span class="s2">&quot;original&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use PhaseNet (Zhu et al., 2019) to pick P and S waves (Event class).</span>

<span class="sd">        Note1: PhaseNet must be used with 3-comp data.</span>
<span class="sd">        Note2: Extra kwargs are passed to</span>
<span class="sd">        `phasenet.wrapper.automatic_detection`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        duration: scalar float</span>
<span class="sd">            Duration, in seconds, of the time window to process to search for P</span>
<span class="sd">            and S wave arrivals.</span>
<span class="sd">        tag: string</span>
<span class="sd">            Tag name of the target data. For example: &#39;preprocessed_1_12&#39;.</span>
<span class="sd">        threshold_P: scalar float, default to 0.60</span>
<span class="sd">            Threshold on PhaseNet&#39;s probabilities to trigger the identification</span>
<span class="sd">            of a P-wave arrival.</span>
<span class="sd">        threshold_S: scalar float, default to 0.60</span>
<span class="sd">            Threshold on PhaseNet&#39;s probabilities to trigger the identification</span>
<span class="sd">            of a S-wave arrival.</span>
<span class="sd">        mini_batch_size: scalar int, default to 126</span>
<span class="sd">            Number of traces processed in a single batch by PhaseNet. This</span>
<span class="sd">            shouldn&#39;t have to be tuned.</span>
<span class="sd">        phase_on_comp: dictionary, optional</span>
<span class="sd">            Dictionary defining which seismic phase is extracted on each</span>
<span class="sd">            component. For example, phase_on_comp[&#39;N&#39;] gives the phase that is</span>
<span class="sd">            extracted on the north component.</span>
<span class="sd">        component_aliases: Dictionary</span>
<span class="sd">            Each entry of the dictionary is a list of strings.</span>
<span class="sd">            `component_aliases[comp]` is the list of all aliases used for</span>
<span class="sd">            the same component &#39;comp&#39;. For example, `component_aliases[&#39;N&#39;] =</span>
<span class="sd">            [&#39;N&#39;, &#39;1&#39;]` means that both the &#39;N&#39; and &#39;1&#39; channels will be mapped</span>
<span class="sd">            to the Event&#39;s &#39;N&#39; channel.</span>
<span class="sd">        upsampling: scalar integer, default to 1</span>
<span class="sd">            Upsampling factor applied before calling PhaseNet.</span>
<span class="sd">        downsampling: scalar integer, default to 1</span>
<span class="sd">            Downsampling factor applied before calling PhaseNet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">no_grad</span><span class="p">,</span> <span class="n">from_numpy</span>

        <span class="k">if</span> <span class="n">ml_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">seisbench.models</span> <span class="k">as</span> <span class="nn">sbm</span>
            <span class="n">ml_model</span> <span class="o">=</span> <span class="n">sbm</span><span class="o">.</span><span class="n">PhaseNet</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">ml_model_name</span><span class="p">)</span>
            <span class="n">ml_model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

        <span class="n">ml_p_index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ml_P_index&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ml_s_index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ml_S_index&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;read_waveforms&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="c1"># read waveforms in picking mode, i.e. with `time_shifted`=False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span>
                <span class="n">duration</span><span class="p">,</span>
                <span class="n">offset_ot</span><span class="o">=</span><span class="n">offset_ot</span><span class="p">,</span>
                <span class="n">phase_on_comp</span><span class="o">=</span><span class="n">phase_on_comp</span><span class="p">,</span>
                <span class="n">component_aliases</span><span class="o">=</span><span class="n">component_aliases</span><span class="p">,</span>
                <span class="n">time_shifted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">data_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">upsampling</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">downsampling</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">resample_poly</span>

            <span class="n">data_arr</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="n">upsampling</span><span class="p">,</span> <span class="n">downsampling</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># momentarily update samping_rate</span>
            <span class="n">sampling_rate0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span> <span class="o">*</span> <span class="n">upsampling</span> <span class="o">/</span> <span class="n">downsampling</span>
        <span class="n">data_arr_n</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_batch</span><span class="p">(</span><span class="n">data_arr</span><span class="p">)</span>
        <span class="n">closest_pow2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">data_arr_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">closest_pow2</span> <span class="o">-</span> <span class="n">data_arr_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">diff</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">diff</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="n">diff</span><span class="o">%</span><span class="mi">2</span>
        <span class="n">data_arr_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                <span class="n">data_arr_n</span><span class="p">,</span>
                <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)),</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span>
                <span class="p">)</span>
        <span class="k">with</span> <span class="n">no_grad</span><span class="p">():</span>
            <span class="n">ml_probas</span> <span class="o">=</span> <span class="n">ml_model</span><span class="p">(</span>
                    <span class="n">from_numpy</span><span class="p">(</span><span class="n">data_arr_n</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
                    <span class="p">)</span>
            <span class="n">ml_probas</span> <span class="o">=</span> <span class="n">ml_probas</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="c1"># find picks and sotre in dictionaries</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">],</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">trigger_picks</span><span class="p">(</span>
                    <span class="n">ml_probas</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">ml_p_index</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="o">-</span><span class="n">right</span><span class="p">],</span> <span class="n">threshold_P</span><span class="p">,</span> 
                    <span class="p">)</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">],</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">trigger_picks</span><span class="p">(</span>
                    <span class="n">ml_probas</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">ml_s_index</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="o">-</span><span class="n">right</span><span class="p">],</span> <span class="n">threshold_S</span><span class="p">,</span> 
                    <span class="p">)</span>
        <span class="k">if</span> <span class="n">use_apriori_picks</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;arrival_times&quot;</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s2">&quot;P&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
            <span class="n">prior_knowledge</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">prior_knowledge</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">prior_knowledge</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="n">ph</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span>
                        <span class="n">udt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_arrival_times&quot;</span><span class="p">])</span>
                        <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="p">,</span>
                        <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prior_knowledge</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># only used if use_apriori_picks is True</span>
        <span class="n">search_win_samp</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span><span class="n">search_win_sec</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
        <span class="c1"># keep best P- and S-wave pick on each 3-comp seismogram</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_picks</span><span class="p">(</span>
            <span class="n">picks</span><span class="p">,</span>
            <span class="n">prior_knowledge</span><span class="o">=</span><span class="n">prior_knowledge</span><span class="p">,</span>
            <span class="n">search_win_samp</span><span class="o">=</span><span class="n">search_win_samp</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># format picks in pandas DataFrame</span>
        <span class="n">pandas_picks</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">]:</span>
            <span class="n">rel_picks_sec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">proba_picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">abs_picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_picks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">rel_picks_sec</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span>
                    <span class="n">proba_picks</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">proba_picks</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">abs_picks</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
                            <span class="o">+</span> <span class="n">rel_picks_sec</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                        <span class="p">)</span>
            <span class="n">pandas_picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_picks_sec</span>
            <span class="n">pandas_picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_probas&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">proba_picks</span>
            <span class="n">pandas_picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_picks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pandas_picks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">upsampling</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">downsampling</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># reset the sampling rate to initial value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate0</span></div>

<div class="viewcode-block" id="Event.read_waveforms"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.read_waveforms">[docs]</a>    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">,</span>
        <span class="n">phase_on_comp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">},</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
        <span class="n">offset_phase</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">},</span>
        <span class="n">time_shifted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">offset_ot</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">BUFFER_EXTRACTED_EVENTS_SEC</span><span class="p">,</span>
        <span class="n">data_reader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="o">**</span><span class="n">reader_kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read waveform data (Event class).</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        duration : float</span>
<span class="sd">            Duration, in seconds, of the extracted time windows.</span>
<span class="sd">        phase_on_comp : dictionary, optional</span>
<span class="sd">            Dictionary defining which seismic phase is extracted on each</span>
<span class="sd">            component. For example, phase_on_comp[&#39;N&#39;] gives the phase that is</span>
<span class="sd">            extracted on the north component.</span>
<span class="sd">        component_aliases : dictionary, optional</span>
<span class="sd">            Each entry of the dictionary is a list of strings.</span>
<span class="sd">            `component_aliases[comp]` is the list of all aliases used for</span>
<span class="sd">            the same component &#39;comp&#39;. For example, `component_aliases[&#39;N&#39;] =</span>
<span class="sd">            [&#39;N&#39;, &#39;1&#39;]` means that both the &#39;N&#39; and &#39;1&#39; channels will be mapped</span>
<span class="sd">            to the Event&#39;s &#39;N&#39; channel.</span>
<span class="sd">        offset_phase : dictionary, optional</span>
<span class="sd">            Dictionary defining when the time window starts with respect to the</span>
<span class="sd">            pick. A positive offset means the window starts before the pick. Not</span>
<span class="sd">            used if `time_shifted` is False.</span>
<span class="sd">        time_shifted : boolean, optional</span>
<span class="sd">            If True (default), the moveouts are used to extract time windows from specific</span>
<span class="sd">            seismic phases. If False, windows are simply extracted with respect to</span>
<span class="sd">            the origin time.</span>
<span class="sd">        offset_ot : float, optional</span>
<span class="sd">            Only used if `time_shifted` is False. Time, in seconds, taken before</span>
<span class="sd">            `origin_time`. Default to `cfg.BUFFER_EXTRACTED_EVENTS_SEC`.</span>
<span class="sd">        data_reader : func, optional</span>
<span class="sd">            Function that takes a path and optional key-word arguments to read</span>
<span class="sd">            data from this path and returns an `obspy.Stream` instance. If None</span>
<span class="sd">            (default), this function uses `self.data_reader` and returns</span>
<span class="sd">            None if `self.data_reader=None`.</span>
<span class="sd">        n_threads : int, optional</span>
<span class="sd">            The number of threads used to parallelize reading. Default is 1</span>
<span class="sd">            (sequential reading). </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># from pyasdf import ASDFDataSet</span>
        <span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">Stream</span>
        <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
        <span class="k">if</span> <span class="n">n_threads</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>

        <span class="k">if</span> <span class="n">data_reader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_reader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_reader</span>
        <span class="k">if</span> <span class="n">data_reader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You need to specify a data reader for the class instance.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">)</span>
        <span class="n">reading_task_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
                <span class="n">ph</span> <span class="o">=</span> <span class="n">phase_on_comp</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">time_shifted</span><span class="p">:</span>
                    <span class="n">pick</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span>
                        <span class="o">-</span> <span class="n">offset_phase</span><span class="p">[</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pick</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">-</span> <span class="n">offset_ot</span>
                <span class="k">for</span> <span class="n">cp_alias</span> <span class="ow">in</span> <span class="n">component_aliases</span><span class="p">[</span><span class="n">comp</span><span class="p">]:</span>
                    <span class="n">reading_task_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">partial</span><span class="p">(</span>
                                <span class="n">data_reader</span><span class="p">,</span>
                                <span class="n">where</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">,</span>
                                <span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span>
                                <span class="n">channel</span><span class="o">=</span><span class="n">cp_alias</span><span class="p">,</span>
                                <span class="n">starttime</span><span class="o">=</span><span class="n">pick</span><span class="p">,</span>
                                <span class="n">endtime</span><span class="o">=</span><span class="n">pick</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">reader_kwargs</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
        <span class="k">if</span> <span class="n">n_threads</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_threads</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]:</span>
                <span class="c1"># n_threads = None means use all CPUs</span>
                <span class="n">n_threads</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">n_threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                <span class="n">traces_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                            <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">reading_task_list</span><span class="p">[</span><span class="n">i</span><span class="p">](),</span>
                            <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reading_task_list</span><span class="p">))</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
            <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">traces_</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">+=</span> <span class="n">tr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">reading_task_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">+=</span> <span class="n">task</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">reader_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;attach_response&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># remove traces for which we could not find the instrument response</span>
            <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;response&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">offset_phase</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;offset_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">offset_phase</span><span class="p">[</span><span class="n">ph</span><span class="p">]})</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">phase_on_comp</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;phase_on_comp</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">phase_on_comp</span><span class="p">[</span><span class="n">comp</span><span class="p">]})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">time_shifted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trim_waveforms</span><span class="p">(</span>
                <span class="n">starttime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">-</span> <span class="n">offset_ot</span><span class="p">,</span>
                <span class="n">endtime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">-</span> <span class="n">offset_ot</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Event.relocate"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.relocate">[docs]</a>    <span class="k">def</span> <span class="nf">relocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">routine</span><span class="o">=</span><span class="s2">&quot;NLLoc&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrapper function for relocation with multiple methods.</span>

<span class="sd">        This single function interfaces the earthquake relocation with</span>
<span class="sd">        multiple relocation routines. All key-word arguments go the</span>
<span class="sd">        routine corresponding to `routine`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        routine : string, optional</span>
<span class="sd">            Method used for relocation.</span>
<span class="sd">                - &#39;NLLoc&#39; calls `relocate_NLLoc` and</span>
<span class="sd">                requires `self` to have the attribute `picks`.</span>
<span class="sd">                - &#39;beam&#39; calls `relocated_beam`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">routine</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;nlloc&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relocate_NLLoc</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">routine</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;beam&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relocate_beam</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Event.relocate_beam"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.relocate_beam">[docs]</a>    <span class="k">def</span> <span class="nf">relocate_beam</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">beamformer</span><span class="p">,</span>
        <span class="n">duration</span><span class="o">=</span><span class="mf">60.0</span><span class="p">,</span>
        <span class="n">offset_ot</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">BUFFER_EXTRACTED_EVENTS_SEC</span><span class="p">,</span>
        <span class="n">phase_on_comp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">},</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
        <span class="n">waveform_features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">restricted_domain_side_km</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        beamformer : `BPMF.template_search.Beamformer`</span>
<span class="sd">            Beamformer instance used for backprojection.</span>
<span class="sd">        duration : float, optional</span>
<span class="sd">            Duration, in seconds, of the extracted time windows. Default is</span>
<span class="sd">            60sec.</span>
<span class="sd">        offset_ot : float, optional</span>
<span class="sd">            Only used if `time_shifted` is False. Time, in seconds, taken before</span>
<span class="sd">            `origin_time`. Default to `cfg.BUFFER_EXTRACTED_EVENTS_SEC`.</span>
<span class="sd">        phase_on_comp : dictionary, optional</span>
<span class="sd">            Dictionary defining which seismic phase is extracted on each</span>
<span class="sd">            component. For example, phase_on_comp[&#39;N&#39;] gives the phase that is</span>
<span class="sd">            extracted on the north component.</span>
<span class="sd">        component_aliases : dictionary, optional</span>
<span class="sd">            Each entry of the dictionary is a list of strings.</span>
<span class="sd">            `component_aliases[comp]` is the list of all aliases used for</span>
<span class="sd">            the same component &#39;comp&#39;. For example, `component_aliases[&#39;N&#39;] =</span>
<span class="sd">            [&#39;N&#39;, &#39;1&#39;]` means that both the &#39;N&#39; and &#39;1&#39; channels will be mapped</span>
<span class="sd">            to the Event&#39;s &#39;N&#39; channel.</span>
<span class="sd">        offset_phase : dictionary, optional</span>
<span class="sd">            Dictionary defining when the time window starts with respect to the</span>
<span class="sd">            pick. A positive offset means the window starts before the pick. Not</span>
<span class="sd">            used if `time_shifted` is False.</span>
<span class="sd">        waveform_features : numpy.ndarray, optional</span>
<span class="sd">            If not None (default), it must be a `(num_stations, num_channels,</span>
<span class="sd">            num_time_samples)` numpy.ndarray. This array contains the waveform</span>
<span class="sd">            features, or characteristic functions, that are backprojected onto</span>
<span class="sd">            the grid of theoretical seismic sources.</span>
<span class="sd">        restricted_domain_side_km : float, optional</span>
<span class="sd">            Location uncertainties are computed on the full 3D beam at the time</span>
<span class="sd">            when the 4D beam achieves its maximum over the `duration` seconds.</span>
<span class="sd">            To avoid having grid-size-dependent uncertainties, it is useful</span>
<span class="sd">            to truncate the domain around the location of the max beam. This</span>
<span class="sd">            variable controls the size of the truncated domain.</span>
<span class="sd">        device : string, optional</span>
<span class="sd">            Either &#39;cpu&#39; (default) or &#39;gpu&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.template_search</span> <span class="kn">import</span> <span class="n">Beamformer</span><span class="p">,</span> <span class="n">envelope</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;read_waveforms&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="n">waveform_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># read waveforms in picking mode, i.e. with `time_shifted`=False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span>
                <span class="n">duration</span><span class="p">,</span>
                <span class="n">offset_ot</span><span class="o">=</span><span class="n">offset_ot</span><span class="p">,</span>
                <span class="n">phase_on_comp</span><span class="o">=</span><span class="n">phase_on_comp</span><span class="p">,</span>
                <span class="n">component_aliases</span><span class="o">=</span><span class="n">component_aliases</span><span class="p">,</span>
                <span class="n">time_shifted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">waveform_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span>
                <span class="n">beamformer</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">norm</span><span class="p">[</span><span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">data_arr</span> <span class="o">/=</span> <span class="n">norm</span>
            <span class="n">waveform_features</span> <span class="o">=</span> <span class="n">envelope</span><span class="p">(</span><span class="n">data_arr</span><span class="p">)</span>
        <span class="c1"># print(waveform_features)</span>
        <span class="n">beamformer</span><span class="o">.</span><span class="n">backproject</span><span class="p">(</span><span class="n">waveform_features</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">reduce</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
        <span class="c1"># find where the maximum focusing occurred</span>
        <span class="n">src_idx</span><span class="p">,</span> <span class="n">time_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span>
            <span class="n">beamformer</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">argmax</span><span class="p">(),</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">)</span>
        <span class="c1"># update hypocenter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span> <span class="n">time_idx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">source_coordinates</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">src_idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">source_coordinates</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">src_idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">source_coordinates</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">src_idx</span><span class="p">]</span>
        <span class="c1"># estimate location uncertainty</span>
        <span class="c1"># 1) compute likelihood</span>
        <span class="n">likelihood</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">_likelihood</span><span class="p">(</span><span class="n">beamformer</span><span class="o">.</span><span class="n">beam</span><span class="p">[:,</span> <span class="n">time_idx</span><span class="p">])</span>
        <span class="n">beamformer</span><span class="o">.</span><span class="n">likelihood</span> <span class="o">=</span> <span class="n">likelihood</span>
        <span class="c1"># 2) define a restricted domain</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">_rectangular_domain</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
                <span class="n">side_km</span><span class="o">=</span><span class="n">restricted_domain_side_km</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="c1"># 3) compute uncertainty</span>
        <span class="n">hunc</span><span class="p">,</span> <span class="n">vunc</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">_compute_location_uncertainty</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span>
                <span class="n">likelihood</span><span class="p">,</span>
                <span class="n">domain</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="c1"># 4) set attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hmax_unc</span> <span class="o">=</span> <span class="n">hunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hmin_unc</span> <span class="o">=</span> <span class="n">hunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmax_unc</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_az_hmin_unc</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vmax_unc</span> <span class="o">=</span> <span class="n">vunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;hmax_unc&quot;</span><span class="p">:</span> <span class="n">hunc</span><span class="p">,</span> <span class="s2">&quot;hmin_unc&quot;</span><span class="p">:</span> <span class="n">hunc</span><span class="p">,</span> <span class="s2">&quot;az_hmax_unc&quot;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">,</span> <span class="s2">&quot;vmax_unc&quot;</span><span class="p">:</span> <span class="n">vunc</span><span class="p">}</span>
                <span class="p">)</span>
        <span class="c1"># fill arrival time attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">beamformer</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;P_tt_sec&quot;</span><span class="p">,</span>
                <span class="s2">&quot;P_abs_arrival_times&quot;</span><span class="p">,</span>
                <span class="s2">&quot;S_tt_sec&quot;</span><span class="p">,</span>
                <span class="s2">&quot;S_abs_arrival_times&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span>
        <span class="n">travel_times</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">moveouts</span><span class="p">[</span><span class="n">src_idx</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="n">beamformer</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="p">[</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">phases</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">beamformer</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">ph</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">]):</span>
                <span class="n">pp</span> <span class="o">=</span> <span class="n">beamformer</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ph</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">travel_times</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">pp</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_arrival_times&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span><span class="p">]</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="Event.relocate_NLLoc"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.relocate_NLLoc">[docs]</a>    <span class="k">def</span> <span class="nf">relocate_NLLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;EDT&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Relocate with NLLoc using `self.picks`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        stations: list of strings, default to None</span>
<span class="sd">            Names of the stations to include in the relocation process. If None,</span>
<span class="sd">            `stations` is set to `self.stations`.</span>
<span class="sd">        method: string, default to &#39;EDT&#39;</span>
<span class="sd">            Optimization algorithm used by NonLinLoc. Either &#39;GAU_ANALYTIC&#39;,</span>
<span class="sd">            &#39;EDT&#39;, &#39;EDT_OT&#39;, &#39;EDT_OT_WT_ML&#39;. See NonLinLoc&#39;s documentation for</span>
<span class="sd">            more information.</span>
<span class="sd">        verbose: scalar int, default to 0</span>
<span class="sd">            If more than 0, print NLLoc&#39;s outputs to the standard output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">subprocess</span>
        <span class="kn">import</span> <span class="nn">glob</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">NLLoc_utils</span>

        <span class="k">if</span> <span class="n">stations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span>
        <span class="c1"># create folder for input/output files</span>
        <span class="n">input_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_INPUT_PATH</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_OUTPUT_PATH</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">input_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">input_dir</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
        <span class="c1"># file names:</span>
        <span class="n">ctrl_fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="s2">&quot;.in&quot;</span><span class="p">)</span>
        <span class="n">out_basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="s2">&quot;_out&quot;</span><span class="p">)</span>
        <span class="n">obs_fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="s2">&quot;.obs&quot;</span><span class="p">)</span>
        <span class="c1"># write obs file</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_INPUT_PATH</span><span class="p">,</span> <span class="n">obs_fn</span><span class="p">)):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_INPUT_PATH</span><span class="p">,</span> <span class="n">obs_fn</span><span class="p">))</span>
        <span class="n">NLLoc_utils</span><span class="o">.</span><span class="n">write_NLLoc_obs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">obs_fn</span><span class="p">)</span>
        <span class="c1"># write control file</span>
        <span class="n">NLLoc_utils</span><span class="o">.</span><span class="n">write_NLLoc_control</span><span class="p">(</span>
            <span class="n">ctrl_fn</span><span class="p">,</span> <span class="n">out_basename</span><span class="p">,</span> <span class="n">obs_fn</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># run NLLoc</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;NLLoc </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_INPUT_PATH</span><span class="p">,</span><span class="w"> </span><span class="n">ctrl_fn</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&gt; </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">devnull</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># run NLLoc</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
                <span class="s2">&quot;NLLoc &quot;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_INPUT_PATH</span><span class="p">,</span> <span class="n">ctrl_fn</span><span class="p">),</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="c1"># read results</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out_fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span>
                <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_OUTPUT_PATH</span><span class="p">,</span> <span class="n">out_basename</span> <span class="o">+</span> <span class="s2">&quot;.[!s]*hyp&quot;</span><span class="p">)</span>
                <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># relocation failed</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)):</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">input_dir</span><span class="p">):</span>
                <span class="c1"># add this protection against unexpected</span>
                <span class="c1"># external change</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">input_dir</span><span class="p">)</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)):</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
                <span class="c1"># add this protection against unexpected</span>
                <span class="c1"># external change</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="n">hypocenter</span><span class="p">,</span> <span class="n">predicted_times</span> <span class="o">=</span> <span class="n">NLLoc_utils</span><span class="o">.</span><span class="n">read_NLLoc_outputs</span><span class="p">(</span>
            <span class="n">out_fn</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">NLLOC_OUTPUT_PATH</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">hypocenter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># problem when reading the output</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)):</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">input_dir</span><span class="p">):</span>
                <span class="c1"># add this protection against unexpected</span>
                <span class="c1"># external change</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">input_dir</span><span class="p">)</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)):</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
                <span class="c1"># add this protection against unexpected</span>
                <span class="c1"># external change</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="n">hypocenter</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">hypocenter</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">])</span>
        <span class="c1"># round seconds to reasonable precision to avoid producing</span>
        <span class="c1"># origin times that are in between samples</span>
        <span class="n">hypocenter</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">round_time</span><span class="p">(</span><span class="n">hypocenter</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># update event&#39;s attributes</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">hypocenter</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">hypocenter</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="c1"># add absolute arrival times to predicted_times</span>
        <span class="n">P_abs_arrivals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_times</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">S_abs_arrivals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_times</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predicted_times</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">P_abs_arrivals</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">predicted_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="s2">&quot;P_tt_sec&quot;</span><span class="p">]</span>
            <span class="n">S_abs_arrivals</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">predicted_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="s2">&quot;S_tt_sec&quot;</span><span class="p">]</span>
        <span class="n">predicted_times</span><span class="p">[</span><span class="s2">&quot;P_abs_arrival_times&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">P_abs_arrivals</span>
        <span class="n">predicted_times</span><span class="p">[</span><span class="s2">&quot;S_abs_arrival_times&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_abs_arrivals</span>
        <span class="c1"># attach the theoretical arrival times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span> <span class="o">=</span> <span class="n">predicted_times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">({</span><span class="s2">&quot;NLLoc_reloc&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">({</span><span class="s2">&quot;cov_mat&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span><span class="p">,</span> <span class="s2">&quot;tt_rms&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tt_rms</span><span class="p">})</span>
        <span class="c1"># clean the temporary control and pick files</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)):</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">input_dir</span><span class="p">):</span>
            <span class="c1"># add this protection against unexpected</span>
            <span class="c1"># external change</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">input_dir</span><span class="p">)</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)):</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
            <span class="c1"># add this protection against unexpected</span>
            <span class="c1"># external change</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span></div>

<div class="viewcode-block" id="Event.remove_outlier_picks"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.remove_outlier_picks">[docs]</a>    <span class="k">def</span> <span class="nf">remove_outlier_picks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_diff_percent</span><span class="o">=</span><span class="mf">25.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove picks that are too far from predicted arrival times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_diff_percent: float, default to 25</span>
<span class="sd">            Maximum difference, in percentage, between the picked and predicted</span>
<span class="sd">            arrival time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stations_outlier</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="n">pick</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]))</span>
                <span class="n">predicted</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_arrival_times&quot;</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">predicted_tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span><span class="p">]</span>
                <span class="n">diff_percent</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mf">100.0</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">((</span><span class="n">pick</span> <span class="o">-</span> <span class="n">predicted</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span> <span class="o">/</span> <span class="n">predicted_tt</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">diff_percent</span> <span class="o">&gt;</span> <span class="n">max_diff_percent</span><span class="p">:</span>
                    <span class="n">stations_outlier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sta</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_probas&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

<div class="viewcode-block" id="Event.zero_out_clipped_waveforms"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.zero_out_clipped_waveforms">[docs]</a>    <span class="k">def</span> <span class="nf">zero_out_clipped_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kurtosis_threshold</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find waveforms with anomalous statistic and zero them out.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kurtosis_threshold: scalar float, optional</span>
<span class="sd">            Threshold below which the kurtosis is considered anomalous.</span>
<span class="sd">            Note that the Fischer definition of the kurtosis is used,</span>
<span class="sd">            that is, kurtosis=0 for gaussian distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">kurtosis</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kurtosis</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">kurtosis_threshold</span><span class="p">:</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Event.remove_distant_stations"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.remove_distant_stations">[docs]</a>    <span class="k">def</span> <span class="nf">remove_distant_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_distance_km</span><span class="o">=</span><span class="mf">50.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove picks on stations that are further than given distance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_distance_km: float, default to 50</span>
<span class="sd">            Maximum distance, in km, beyond which picks are set to NaN.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_receiver_dist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Call self.set_source_receiver_dist(network) before &quot;</span>
                <span class="s2">&quot;using self.remove_distant_stations.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_receiver_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_distance_km</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

<div class="viewcode-block" id="Event.set_aux_data"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_aux_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_aux_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aux_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds any extra data to the Event instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        aux_data: dictionary</span>
<span class="sd">            Dictionary with any auxiliary data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">aux_data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux_data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span></div>

<div class="viewcode-block" id="Event.set_availability"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_availability">[docs]</a>    <span class="k">def</span> <span class="nf">set_availability</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the data availability.</span>

<span class="sd">        A station is available if at least one station has non-zero data. The</span>
<span class="sd">        availability is then accessed via the property `self.availability`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        stations: list of strings or numpy.ndarray, default to None</span>
<span class="sd">            Names of the stations on which we check availability. If None, use</span>
<span class="sd">            `self.stations`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.read_waveforms` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_sta</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_cha</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">stations</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">components</span><span class="p">):</span>
            <span class="n">availability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stations</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">cp_alias</span> <span class="ow">in</span> <span class="n">component_aliases</span><span class="p">[</span><span class="n">cp</span><span class="p">]:</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">cp_alias</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">):</span>
                        <span class="n">availability</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_cha</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span> <span class="o">=</span> <span class="n">availability</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_sta</span><span class="p">,</span> <span class="n">availability</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;availability&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_sta</span><span class="p">,</span>
                <span class="s2">&quot;availability_per_sta&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_sta</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span>
            <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;availability_</span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_availability_per_cha</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span> <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">components</span><span class="p">}</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Event.set_components"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_components">[docs]</a>    <span class="k">def</span> <span class="nf">set_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">components</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the list of components.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        components: list of strings</span>
<span class="sd">            The names of the components on which the `Template` instance will</span>
<span class="sd">            work after this call to `self.set_components`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">components</span></div>

<div class="viewcode-block" id="Event.set_component_aliases"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_component_aliases">[docs]</a>    <span class="k">def</span> <span class="nf">set_component_aliases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component_aliases</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set or modify the `component_aliases` attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        component_aliases: Dictionary</span>
<span class="sd">            Each entry of the dictionary is a list of strings.</span>
<span class="sd">            `component_aliases[comp]` is the list of all aliases used for</span>
<span class="sd">            the same component &#39;comp&#39;. For example, `component_aliases[&#39;N&#39;] =</span>
<span class="sd">            [&#39;N&#39;, &#39;1&#39;]` means that both the &#39;N&#39; and &#39;1&#39; channels will be mapped</span>
<span class="sd">            to the Event&#39;s &#39;N&#39; channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span> <span class="o">=</span> <span class="n">component_aliases</span></div>

<div class="viewcode-block" id="Event.set_arrival_times_from_moveouts"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_arrival_times_from_moveouts">[docs]</a>    <span class="k">def</span> <span class="nf">set_arrival_times_from_moveouts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build arrival times assuming at = ot + mv.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Make sure origin_time + moveout points at the phase arrival!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_abs_arrival_times&quot;</span> <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
            <span class="n">ph</span> <span class="o">=</span> <span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">field1</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_arrival_times&quot;</span>
            <span class="n">field2</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span>
            <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="n">field1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="n">field2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                        <span class="p">)</span></div>

<div class="viewcode-block" id="Event.set_moveouts_to_empirical_times"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_moveouts_to_empirical_times">[docs]</a>    <span class="k">def</span> <span class="nf">set_moveouts_to_empirical_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set moveouts equal to picks, if available.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;picks&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Does not have a `picks` attribute.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># make sure picks are consistent with the current origin time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_picks</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">round_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                        <span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">round_time</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">],</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span>
                    <span class="p">)</span></div>

<div class="viewcode-block" id="Event.set_moveouts_to_theoretical_times"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_moveouts_to_theoretical_times">[docs]</a>    <span class="k">def</span> <span class="nf">set_moveouts_to_theoretical_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set moveouts equal to theoretical arrival times, if available.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;arrival_times&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Does not have a `arrival_times` attribute.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># make sure travel times are consistent with the current origin time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_travel_times</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">round_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                        <span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">round_time</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span><span class="p">],</span>
                        <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">,</span>
                    <span class="p">)</span></div>

<div class="viewcode-block" id="Event.set_source_receiver_dist"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.set_source_receiver_dist">[docs]</a>    <span class="k">def</span> <span class="nf">set_source_receiver_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set source-receiver distances, given `network`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        network: `dataset.Network` instance</span>
<span class="sd">            The `Network` instance with the station coordinates to use</span>
<span class="sd">            in the source-receiver computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">compute_distances</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">],</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">],</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">],</span>
            <span class="n">network</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
            <span class="n">network</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
            <span class="n">network</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_receiver_dist</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">distances</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;source-receiver dist (km)&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;network_stations&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_receiver_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_receiver_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="Event.trim_waveforms"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.trim_waveforms">[docs]</a>    <span class="k">def</span> <span class="nf">trim_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Trim waveforms.</span>

<span class="sd">        Start times might differ of one sample on different traces. Use this</span>
<span class="sd">        method to make sure all traces have the same start time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        starttime: string or datetime, default to None</span>
<span class="sd">            If None, use `self.date` as the start time.</span>
<span class="sd">        endtime: string or datetime, default to None</span>
<span class="sd">            If None, use `self.date` + `self.duration` as the end time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You should call `read_waveforms` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">starttime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span>
        <span class="k">if</span> <span class="n">endtime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span>
                <span class="n">starttime</span><span class="o">=</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">endtime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Event.update_picks"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.update_picks">[docs]</a>    <span class="k">def</span> <span class="nf">update_picks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the picks w.r.t the current origin time.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;picks&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Does not have a `picks` attribute.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]):</span>
                    <span class="k">continue</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]</span>
                <span class="p">)</span> <span class="o">-</span> <span class="n">udt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="p">)</span></div>

<div class="viewcode-block" id="Event.update_travel_times"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.update_travel_times">[docs]</a>    <span class="k">def</span> <span class="nf">update_travel_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update travel times w.r.t the current origin time.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;arrival_times&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Does not have an `arrival_times` attribute.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_tt_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_abs_arrival_times&quot;</span><span class="p">]</span>
                <span class="p">)</span> <span class="o">-</span> <span class="n">udt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="p">)</span></div>

<div class="viewcode-block" id="Event.update_aux_data_database"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.update_aux_data_database">[docs]</a>    <span class="k">def</span> <span class="nf">update_aux_data_database</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add the new elements of `self.aux_data` that are not in the database.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>

<span class="sd">        overwrite : boolean, optional</span>
<span class="sd">            If True, will overwrite existing data. Otherwise, does not do</span>
<span class="sd">            anything.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;path_database&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It looks like you create this Event instance from scratch...&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call Event.write instead.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">lock_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_database</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.lock&quot;</span>
        <span class="k">while</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">lock_file</span><span class="p">):</span>
            <span class="c1"># another process is already writing in this file</span>
            <span class="c1"># wait a bit a check again</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
        <span class="c1"># create empty lock file</span>
        <span class="nb">open</span><span class="p">(</span><span class="n">lock_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_database</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fdb</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;hdf5_gid&quot;</span><span class="p">):</span>
                    <span class="n">fdb</span> <span class="o">=</span> <span class="n">fdb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf5_gid</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fdb</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
                        <span class="c1"># already exists</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fdb</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">overwrite</span><span class="p">:</span>
                        <span class="c1"># overwrite it</span>
                        <span class="k">del</span> <span class="n">fdb</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">]</span>
                    <span class="n">fdb</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                            <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">lock_file</span><span class="p">)</span>
            <span class="k">raise</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="c1"># remove lock file</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">lock_file</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_write</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db_filename</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">OUTPUT_PATH</span><span class="p">,</span>
        <span class="n">save_waveforms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">hdf5_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `Event.write`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output_where</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">db_filename</span><span class="p">)</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;origin_time&quot;</span><span class="p">,</span>
            <span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
            <span class="s2">&quot;longitude&quot;</span><span class="p">,</span>
            <span class="s2">&quot;depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;moveouts&quot;</span><span class="p">,</span>
            <span class="s2">&quot;stations&quot;</span><span class="p">,</span>
            <span class="s2">&quot;components&quot;</span><span class="p">,</span>
            <span class="s2">&quot;phases&quot;</span><span class="p">,</span>
            <span class="s2">&quot;where&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sampling_rate&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="c1"># moveouts&#39; indexes may have been re-ordered</span>
        <span class="c1"># because writing moveouts as an array will forget about the current</span>
        <span class="c1"># row indexes and assume that they are in the same order as</span>
        <span class="c1"># self.stations, it is critical to make sure this is true</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">hdf5_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdf5_file</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">output_where</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">gid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gid</span> <span class="ow">in</span> <span class="n">hdf5_file</span><span class="p">:</span>
                <span class="c1"># overwrite existing detection with same id</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Found existing event </span><span class="si">{</span><span class="n">gid</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">output_where</span><span class="si">}</span><span class="s2">. Overwrite it.&quot;</span>
                <span class="p">)</span>
                <span class="k">del</span> <span class="n">hdf5_file</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span>
            <span class="n">hdf5_file</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">hdf5_file</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">hdf5_file</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">attr_</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;origin_time&quot;</span><span class="p">:</span>
                <span class="n">attr_</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">attr_</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr_</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">attr_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">attr_</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">attr_</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">kind</span>
            <span class="p">):</span>
                <span class="n">attr_</span> <span class="o">=</span> <span class="n">attr_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">attr_</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;aux_data&quot;</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;aux_data&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;aux_data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;picks&quot;</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;picks&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[</span><span class="s2">&quot;picks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span>
                    <span class="c1"># pandas datetime format</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S.</span><span class="si">%f</span><span class="s2"> %z&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;picks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;arrival_times&quot;</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;arrival_times&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[</span><span class="s2">&quot;arrival_times&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span>
                    <span class="c1"># pandas datetime format</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S.</span><span class="si">%f</span><span class="s2"> %z&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;arrival_times&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_waveforms</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;waveforms&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
                    <span class="n">sta</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span>
                    <span class="n">cha</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span>
                    <span class="k">if</span> <span class="n">sta</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">]:</span>
                        <span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">sta</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cha</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sta</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">cha</span><span class="si">}</span><span class="s2"> already exists!&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">cha</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;You are trying to save the waveforms whereas you did&quot;</span>
                    <span class="s2">&quot; not read them!&quot;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
            <span class="n">hdf5_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<div class="viewcode-block" id="Event.write"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db_filename</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">OUTPUT_PATH</span><span class="p">,</span>
        <span class="n">save_waveforms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">hdf5_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write to hdf5 file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        db_filename: string</span>
<span class="sd">            Name of the hdf5 file storing the event information.</span>
<span class="sd">        db_path: string, default to `cfg.OUTPUT_PATH`</span>
<span class="sd">            Name of the directory with `db_filename`.</span>
<span class="sd">        save_waveforms: boolean, default to False</span>
<span class="sd">            If True, save the waveforms.</span>
<span class="sd">        gid: string, default to None</span>
<span class="sd">            Name of the hdf5 group where Event will be stored. If `gid=None`</span>
<span class="sd">            then Event is directly stored at the root.</span>
<span class="sd">        hdf5_file: `h5py.File`, default to None</span>
<span class="sd">            If not None, is an opened file pointing directly at the subfolder of</span>
<span class="sd">            interest.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">,</span>
                <span class="n">db_path</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="n">save_waveforms</span><span class="o">=</span><span class="n">save_waveforms</span><span class="p">,</span>
                <span class="n">gid</span><span class="o">=</span><span class="n">gid</span><span class="p">,</span>
                <span class="n">hdf5_file</span><span class="o">=</span><span class="n">hdf5_file</span>
                <span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">read_write_waiting_list</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">db_filename</span><span class="p">)</span>
                <span class="p">)</span></div>


    <span class="c1"># -----------------------------------------------------------</span>
    <span class="c1">#            plotting method(s)</span>
    <span class="c1"># -----------------------------------------------------------</span>

<div class="viewcode-block" id="Event.plot"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Event.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
        <span class="n">gain</span><span class="o">=</span><span class="mf">1.0e6</span><span class="p">,</span>
        <span class="n">stations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;Velocity ($\mu$m/s)&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the waveforms of the Event instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        fig: plt.Figure</span>
<span class="sd">            Figure instance produced by this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">matplotlib.dates</span> <span class="k">as</span> <span class="nn">mdates</span>

        <span class="k">if</span> <span class="n">stations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span>
        <span class="n">start_times</span><span class="p">,</span> <span class="n">end_times</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span>
            <span class="n">num</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;event_</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
            <span class="n">nrows</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">),</span>
            <span class="n">ncols</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Event at </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">cp_alias</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span><span class="p">[</span><span class="n">cp</span><span class="p">]:</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">cp_alias</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># succesfully retrieved data</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">time_range</span><span class="p">(</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="o">+</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span>
                    <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;ms&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">start_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">end_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="n">time</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">],</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">]</span> <span class="o">*</span> <span class="n">gain</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span>
                <span class="p">)</span>
                <span class="c1"># plot the picks</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;picks&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_abs_picks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
                <span class="p">):</span>
                    <span class="k">for</span> <span class="n">P_pick</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">][</span><span class="s2">&quot;P_abs_picks&quot;</span><span class="p">]):</span>
                        <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">P_pick</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C0&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.00</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span>
                                <span class="p">)</span>
                    <span class="c1">#P_pick = np.datetime64(self.picks.loc[sta][&quot;P_abs_picks&quot;])</span>
                    <span class="c1">#axes[s, c].axvline(P_pick, color=&quot;C0&quot;, lw=1.00, ls=&quot;--&quot;)</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;picks&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_abs_picks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
                <span class="p">):</span>
                    <span class="k">for</span> <span class="n">S_pick</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">][</span><span class="s2">&quot;S_abs_picks&quot;</span><span class="p">]):</span>
                        <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">S_pick</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C3&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.00</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span>
                                <span class="p">)</span>
                    <span class="c1">#S_pick = np.datetime64(self.picks.loc[sta][&quot;S_abs_picks&quot;])</span>
                    <span class="c1">#axes[s, c].axvline(S_pick, color=&quot;C3&quot;, lw=1.00, ls=&quot;--&quot;)</span>
                <span class="c1"># plot the theoretical arrival times</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;arrival_times&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                    <span class="n">P_pick</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">][</span><span class="s2">&quot;P_abs_arrival_times&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">P_pick</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C4&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.25</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;arrival_times&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                    <span class="n">S_pick</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">arrival_times</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">][</span><span class="s2">&quot;S_abs_arrival_times&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">S_pick</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C1&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.25</span><span class="p">)</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
                    <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sta</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">cp_alias</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">transAxes</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">flatten</span><span class="p">():</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">start_times</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">end_times</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span>
                <span class="n">mdates</span><span class="o">.</span><span class="n">ConciseDateFormatter</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_major_locator</span><span class="p">())</span>
            <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">top</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.06</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mf">0.98</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mf">0.06</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.40</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div></div>


<div class="viewcode-block" id="Template"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template">[docs]</a><span class="k">class</span> <span class="nc">Template</span><span class="p">(</span><span class="n">Event</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class for template events.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">origin_time</span><span class="p">,</span>
        <span class="n">moveouts</span><span class="p">,</span>
        <span class="n">stations</span><span class="p">,</span>
        <span class="n">phases</span><span class="p">,</span>
        <span class="n">template_filename</span><span class="p">,</span>
        <span class="n">template_path</span><span class="p">,</span>
        <span class="n">latitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">longitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
        <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">origin_time</span><span class="p">,</span>
            <span class="n">moveouts</span><span class="p">,</span>
            <span class="n">stations</span><span class="p">,</span>
            <span class="n">phases</span><span class="p">,</span>
            <span class="n">template_filename</span><span class="p">,</span>
            <span class="n">template_path</span><span class="p">,</span>
            <span class="n">latitude</span><span class="o">=</span><span class="n">latitude</span><span class="p">,</span>
            <span class="n">longitude</span><span class="o">=</span><span class="n">longitude</span><span class="p">,</span>
            <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># network_stations is a copy of the original list of stations</span>
        <span class="c1"># self.stations may change if the user wants to use the template</span>
        <span class="c1"># on a subset of stations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="Template.init_from_event"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.init_from_event">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">init_from_event</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">attach_waveforms</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instanciate a `Template` object from an `Event` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        event: `Event` instance</span>
<span class="sd">            The `Event` instance to convert to a `Template` instance.</span>
<span class="sd">        attach_waveforms: boolean, default to True</span>
<span class="sd">            Should not be turned to False when used directly.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------</span>
<span class="sd">        template: Template instance</span>
<span class="sd">            `Template` instance base on `event`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">db_path</span><span class="p">,</span> <span class="n">db_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
        <span class="n">template</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">event</span><span class="o">.</span><span class="n">origin_time</span><span class="p">,</span>
            <span class="n">event</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">event</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">event</span><span class="o">.</span><span class="n">phases</span><span class="p">,</span>
            <span class="n">db_filename</span><span class="p">,</span>
            <span class="n">db_path</span><span class="p">,</span>
            <span class="n">latitude</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
            <span class="n">longitude</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
            <span class="n">depth</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s2">&quot;picks&quot;</span><span class="p">):</span>
            <span class="n">template</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">picks</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s2">&quot;arrival_times&quot;</span><span class="p">):</span>
            <span class="n">template</span><span class="o">.</span><span class="n">arrival_times</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">arrival_times</span>
        <span class="n">aux_data_to_keep</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;offset_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">event</span><span class="o">.</span><span class="n">phases</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
            <span class="s2">&quot;tid&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cov_mat&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Mw&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Mw_err&quot;</span>
        <span class="p">]</span>
        <span class="n">select</span> <span class="o">=</span> <span class="k">lambda</span> <span class="nb">str</span><span class="p">:</span> <span class="nb">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;phase_on_comp&quot;</span><span class="p">)</span>
        <span class="n">aux_data_to_keep</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">select</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">aux_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">aux_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">event</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">aux_data_to_keep</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">event</span><span class="o">.</span><span class="n">aux_data</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">attach_waveforms</span><span class="p">:</span>
            <span class="c1"># ----------------------------------</span>
            <span class="c1"># attach traces</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;You need to call `event.read_waveforms` before instanciating&quot;</span>
                    <span class="s2">&quot; a Template object with this Event instance.&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span>
            <span class="n">template</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">traces</span>
            <span class="n">template</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">n_samples</span>
            <span class="n">template</span><span class="o">.</span><span class="n">set_availability</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">template</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;n_samples&quot;</span><span class="p">]</span>
        <span class="c1"># ----------------------------------</span>
        <span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;n_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">n_samples</span>
        <span class="k">if</span> <span class="s2">&quot;cov_mat&quot;</span> <span class="ow">in</span> <span class="n">aux_data</span><span class="p">:</span>
            <span class="n">template</span><span class="o">.</span><span class="n">cov_mat</span> <span class="o">=</span> <span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;cov_mat&quot;</span><span class="p">]</span>
        <span class="n">template</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span><span class="n">aux_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">template</span></div>

<div class="viewcode-block" id="Template.read_from_file"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.read_from_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">INPUT_PATH</span><span class="p">,</span> <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a `Template` instance from a file.&quot;&quot;&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">init_from_event</span><span class="p">(</span>
            <span class="n">Event</span><span class="o">.</span><span class="n">read_from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">db_path</span><span class="o">=</span><span class="n">db_path</span><span class="p">,</span> <span class="n">gid</span><span class="o">=</span><span class="n">gid</span><span class="p">),</span>
            <span class="n">attach_waveforms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">template</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;n_samples&quot;</span><span class="p">]</span>
        <span class="n">template</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="s2">&quot;tid&quot;</span><span class="p">]</span>
        <span class="c1"># overwrite any path that was stored in aux_data, because what matters</span>
        <span class="c1"># for the template is only the file it was associated with</span>
        <span class="n">template</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">template</span></div>

    <span class="c1"># properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">template_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">moveouts_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a moveout array given self.components and phase_on_comp.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moveouts_win</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">][</span>
                <span class="p">[</span>
                    <span class="sa">f</span><span class="s1">&#39;moveouts_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;phase_on_comp</span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
                <span class="p">]</span>
            <span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">moveouts_win</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_moveouts_win&quot;</span><span class="p">):</span>
            <span class="c1"># this new moveout table store the moveouts of the</span>
            <span class="c1"># time windows rather than the phases</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_moveouts_win</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_moveouts_win</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;offset_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moveouts_win</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">waveforms_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return traces in numpy.ndarray.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="s2">&quot;HH&quot;</span><span class="p">,</span>
            <span class="n">component_aliases</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span><span class="p">,</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># methods</span>
<div class="viewcode-block" id="Template.distance"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.distance">[docs]</a>    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute distance between template and a given location.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        longitude: scalar, float</span>
<span class="sd">            Longitude of the target location.</span>
<span class="sd">        latitude: scalar, float</span>
<span class="sd">            Latitude of the target location.</span>
<span class="sd">        depth: scalar, float</span>
<span class="sd">            Depth of the target location, in km.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">two_point_distance</span>

        <span class="k">return</span> <span class="n">two_point_distance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">depth</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Template.n_best_SNR_stations"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.n_best_SNR_stations">[docs]</a>    <span class="k">def</span> <span class="nf">n_best_SNR_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust `self.stations` to the `n` best SNR stations.</span>


<span class="sd">        Find the `n` best stations and modify `self.stations` accordingly.</span>
<span class="sd">        The instance&#39;s properties will also change accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        n: scalar int</span>
<span class="sd">            The `n` closest stations.</span>
<span class="sd">        available_stations: list of strings, default to None</span>
<span class="sd">            The list of stations from which we search the closest stations.</span>
<span class="sd">            If some stations are known to lack data, the user</span>
<span class="sd">            may choose to not include these in the closest stations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># re-initialize the stations attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">index_pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">))</span>
        <span class="c1"># limit the index pool to available stations</span>
        <span class="k">if</span> <span class="n">available_stations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">availability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">availability</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability</span>
        <span class="n">index_pool</span> <span class="o">=</span> <span class="n">index_pool</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="n">best_SNR_stations</span> <span class="o">=</span> <span class="n">index_pool</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SNR</span><span class="p">[</span><span class="n">index_pool</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="c1"># make sure we return a n-vector</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_SNR_stations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_SNR_stations</span><span class="p">)</span>
            <span class="n">remaining_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SNR</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">best_SNR_stations</span>
            <span class="p">)</span>
            <span class="n">best_SNR_stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">best_SNR_stations</span><span class="p">,</span> <span class="n">remaining_indexes</span><span class="p">[:</span><span class="n">missing</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_stations</span><span class="p">[</span><span class="n">best_SNR_stations</span><span class="p">[:</span><span class="n">n</span><span class="p">]]</span></div>

<div class="viewcode-block" id="Template.read_waveforms"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.read_waveforms">[docs]</a>    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the waveforms time series.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span>
        <span class="k">if</span> <span class="n">components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>

        <span class="k">def</span> <span class="nf">find_channel</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">cp</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">cp_alias</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span><span class="p">[</span><span class="n">cp</span><span class="p">]:</span>
                <span class="n">channel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">cp_alias</span><span class="p">),</span> <span class="n">keys</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;hdf5_gid&quot;</span><span class="p">):</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf5_gid</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sta</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">]:</span>
                    <span class="c1"># station not available</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
                    <span class="n">channel</span> <span class="o">=</span> <span class="n">find_channel</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">cp</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">Trace</span><span class="p">()</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;waveforms&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">][</span><span class="n">channel</span><span class="p">][()]</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="o">=</span> <span class="n">sta</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>
                    <span class="n">ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;phase_on_comp</span><span class="si">{</span><span class="n">cp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                    <span class="n">mv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts_win</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">mv</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">+=</span> <span class="n">tr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_availability</span><span class="p">(</span><span class="n">stations</span><span class="o">=</span><span class="n">stations</span><span class="p">)</span></div>

<div class="viewcode-block" id="Template.write"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db_filename</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">OUTPUT_PATH</span><span class="p">,</span>
        <span class="n">save_waveforms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">db_filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
        <span class="n">Event</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">db_filename</span><span class="p">,</span> <span class="n">db_path</span><span class="o">=</span><span class="n">db_path</span><span class="p">,</span> <span class="n">save_waveforms</span><span class="o">=</span><span class="n">save_waveforms</span><span class="p">,</span> <span class="n">gid</span><span class="o">=</span><span class="n">gid</span>
        <span class="p">)</span></div>

    <span class="c1"># ---------------------------------------------</span>
    <span class="c1">#  methods to investigate the detected events</span>
<div class="viewcode-block" id="Template.read_catalog"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.read_catalog">[docs]</a>    <span class="k">def</span> <span class="nf">read_catalog</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_attributes</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">return_events</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">check_summary_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a `Catalog` instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        filename: string, default to None</span>
<span class="sd">            Name of the detection file. If None, use the standard file</span>
<span class="sd">            and folder naming convention.</span>
<span class="sd">        db_path: string, default to None</span>
<span class="sd">            Name of the directory where the detection file is located. If None,</span>
<span class="sd">            use the standard file and folder naming convention.</span>
<span class="sd">        gid: string, int, or float, default to None</span>
<span class="sd">            If not None, this is the hdf5 group where to read the data.</span>
<span class="sd">        extra_attributes: list of strings, default to []</span>
<span class="sd">            Attributes to read in addition to the default &#39;longitude&#39;,</span>
<span class="sd">            &#39;latitude&#39;, &#39;depth&#39;, and &#39;origin_time&#39;.</span>
<span class="sd">        fill_value: string, int, or float, default to np.nan</span>
<span class="sd">            Default value if the target attribute does not exist.</span>
<span class="sd">        return_events: boolean, default to False</span>
<span class="sd">            If True, return a list of `dataset.Event` instances. Can only be</span>
<span class="sd">            True if `check_summary_file=False`.</span>
<span class="sd">        check_summary_file: boolean, default to True</span>
<span class="sd">            If True, check if the summary hdf5 file already exists and read from</span>
<span class="sd">            if it does; this uses the standard naming convention. If False,</span>
<span class="sd">            it builds the catalog from the detection output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">db_path_T</span><span class="p">,</span> <span class="n">filename_T</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_events</span> <span class="ow">and</span> <span class="n">check_summary_file</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;If `return_events` is True, `check_summary_file` has&quot;</span>
                <span class="s2">&quot; to be False. Change arguments.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">check_summary_file</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># try standard names</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path_T</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;summary_template</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="si">}</span><span class="s2">.h5&quot;</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="c1"># found an existing summary file</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;summary_template</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="si">}</span><span class="s2">.h5&quot;</span>
                    <span class="n">build_from_scratch</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># no existing summary file</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;detections_</span><span class="si">{</span><span class="n">filename_T</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">build_from_scratch</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path_T</span><span class="p">,</span> <span class="n">filename</span><span class="p">)):</span>
                <span class="c1"># use provided file</span>
                <span class="n">build_from_scratch</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">build_from_scratch</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># try standard name</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;detections_</span><span class="si">{</span><span class="n">filename_T</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">build_from_scratch</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">build_from_scratch</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">db_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># guess from standard convention</span>
                <span class="n">db_path</span> <span class="o">=</span> <span class="n">db_path_T</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;template&quot;</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;matched_filter&quot;</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span>
                <span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">Catalog</span><span class="o">.</span><span class="n">read_from_detection_file</span><span class="p">(</span>
                <span class="n">filename</span><span class="p">,</span>
                <span class="n">db_path</span><span class="o">=</span><span class="n">db_path</span><span class="p">,</span>
                <span class="n">gid</span><span class="o">=</span><span class="n">gid</span><span class="p">,</span>
                <span class="n">extra_attributes</span><span class="o">=</span><span class="n">extra_attributes</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">return_events</span><span class="o">=</span><span class="n">return_events</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">return_events</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span> <span class="o">=</span> <span class="n">output</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">,</span> <span class="n">events</span> <span class="o">=</span> <span class="n">output</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;tid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;event_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">))</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;event_id&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">catalog</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path_T</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;catalog&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">catalog</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;catalog&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">][()]</span>
                    <span class="k">if</span> <span class="n">catalog</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                        <span class="n">catalog</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
            <span class="n">extra_attributes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">catalog</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="s2">&quot;origin_time&quot;</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span> <span class="o">=</span> <span class="n">Catalog</span><span class="p">(</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">],</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">],</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">],</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">],</span>
                <span class="o">**</span><span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">catalog</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">extra_attributes</span><span class="p">},</span>
                <span class="n">event_ids</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">]))],</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">return_events</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">events</span></div>

<div class="viewcode-block" id="Template.write_summary"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.write_summary">[docs]</a>    <span class="k">def</span> <span class="nf">write_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">db_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write summary of template characteristics.</span>

<span class="sd">        hdf5 does not support storing datasets of strings. Therefore, You need</span>
<span class="sd">        to convert strings to bytes or this method will raise an error.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        attributes: dictionary</span>
<span class="sd">            Dictionary with scalars, `numpy.ndarray`, dictionary, or</span>
<span class="sd">            `pandas.DataFrame`. The keys of the dictionary are used to name the</span>
<span class="sd">            dataset or group in the hdf5 file.</span>
<span class="sd">        filename: string, default to None</span>
<span class="sd">            Name of the detection file. If None, use the standard file</span>
<span class="sd">            and folder naming convention.</span>
<span class="sd">        db_path: string, default to None</span>
<span class="sd">            Name of the directory where the detection file is located. If None,</span>
<span class="sd">            use the standard file and folder naming convention.</span>
<span class="sd">        overwrite: boolean, default to True</span>
<span class="sd">            If True, overwrite existing datasets or groups.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">db_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">db_path</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;summary_template</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="si">}</span><span class="s2">.h5&quot;</span>
        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">attributes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">f</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">key2</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">f</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">key2</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">key2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">])</span></div>

    <span class="c1"># ---------------------------------------------</span>
    <span class="c1"># plotting methods</span>
<div class="viewcode-block" id="Template.plot_detection"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.plot_detection">[docs]</a>    <span class="k">def</span> <span class="nf">plot_detection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">db_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">duration</span><span class="o">=</span><span class="mf">60.0</span><span class="p">,</span>
        <span class="n">phase_on_comp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">},</span>
        <span class="n">offset_ot</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the `idx`-th detection made with this template.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        filename: string, default to None</span>
<span class="sd">            Name of the detection file. If None, use the standard file</span>
<span class="sd">            and folder naming convention.</span>
<span class="sd">        db_path: string, default to None</span>
<span class="sd">            Name of the directory where the detection file is located. If None,</span>
<span class="sd">            use the standard file and folder naming convention.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;traces&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `Template.read_waveforms` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">db_path_T</span><span class="p">,</span> <span class="n">filename_T</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># guess from standard convention</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;detections_</span><span class="si">{</span><span class="n">filename_T</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">db_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># guess from standard convention</span>
            <span class="n">db_path</span> <span class="o">=</span> <span class="n">db_path_T</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="s2">&quot;template&quot;</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;matched_filter&quot;</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span>
            <span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">event</span> <span class="o">=</span> <span class="n">Event</span><span class="o">.</span><span class="n">read_from_file</span><span class="p">(</span><span class="n">hdf5_file</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span>
        <span class="n">event</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">event</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span>
            <span class="n">duration</span><span class="p">,</span>
            <span class="n">offset_ot</span><span class="o">=</span><span class="n">offset_ot</span><span class="p">,</span>
            <span class="n">phase_on_comp</span><span class="o">=</span><span class="n">phase_on_comp</span><span class="p">,</span>
            <span class="n">time_shifted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">stations</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1">#stations = event.stations</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">get_axes</span><span class="p">()</span>
        <span class="n">cc</span><span class="p">,</span> <span class="n">n_channels</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">components</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">cp_alias</span> <span class="ow">in</span> <span class="n">event</span><span class="o">.</span><span class="n">component_aliases</span><span class="p">[</span><span class="n">cp</span><span class="p">]:</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">cp_alias</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># succesfully retrieved data</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ph</span> <span class="o">=</span> <span class="n">phase_on_comp</span><span class="p">[</span><span class="n">cp_alias</span><span class="p">]</span>
                <span class="n">starttime</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">event</span><span class="o">.</span><span class="n">origin_time</span>
                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts_win</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">endtime</span> <span class="o">=</span> <span class="n">starttime</span> <span class="o">+</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="o">*</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">time_range</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;ms&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">event_tr</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">cp_alias</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">idx1</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">moveouts_win</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                        <span class="o">+</span> <span class="n">offset_ot</span><span class="p">,</span>
                        <span class="n">sr</span><span class="o">=</span><span class="n">event_tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">idx2</span> <span class="o">=</span> <span class="n">idx1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span>
                    <span class="n">max_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">event_tr</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx1</span><span class="p">:</span><span class="n">idx2</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="s2">&quot;gain&quot;</span><span class="p">,</span> <span class="mf">1.0e6</span>
                    <span class="p">)</span>
                    <span class="n">cc_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">event_tr</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx1</span><span class="p">:</span><span class="n">idx2</span><span class="p">]</span> <span class="o">*</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">event_tr</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx1</span><span class="p">:</span><span class="n">idx2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cc_</span><span class="p">):</span>
                        <span class="n">cc</span> <span class="o">+=</span> <span class="n">cc_</span>
                        <span class="n">n_channels</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="c1"># trace not found</span>
                    <span class="n">max_amp</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">)</span>
                    <span class="n">max_amp</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">s</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="n">time</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">],</span>
                    <span class="n">utils</span><span class="o">.</span><span class="n">max_norm</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">])</span> <span class="o">*</span> <span class="n">max_amp</span><span class="p">,</span>
                    <span class="n">lw</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C3&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="n">cc</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_channels</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">_suptitle</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; CC=</span><span class="si">{</span><span class="n">cc</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="Template.plot_recurrence_times"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Template.plot_recurrence_times">[docs]</a>    <span class="k">def</span> <span class="nf">plot_recurrence_times</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annotate_axes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot recurrence times vs detection times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        ax: `plt.Axes`, default to None</span>
<span class="sd">            If not None, use this `plt.Axes` instance to plot the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;marker&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;ls&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;recurrence_times_tp</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;catalog&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `read_catalog` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">rt</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">origin_time</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">origin_time</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">/</span> <span class="mf">1.0e9</span>  <span class="c1"># in sec</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">origin_time</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">annotate_axes</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Detection Time&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Recurrence Time (s)&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">semilogy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span></div></div>


<div class="viewcode-block" id="Family"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family">[docs]</a><span class="k">class</span> <span class="nc">Family</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An abstract class for several subclasses.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;network&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.set_network(network)` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">components</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;network&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Call `self.set_network(network)` first.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">stations</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">moveouts_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_moveouts_arr&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_moveouts_arr</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moveouts_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">waveforms_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_waveforms_arr&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_waveforms_arr</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waveforms_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_n_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">)</span>

<div class="viewcode-block" id="Family.get_moveouts_arr"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family.get_moveouts_arr">[docs]</a>    <span class="k">def</span> <span class="nf">get_moveouts_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_moveouts_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_events</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_stations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_events</span><span class="p">):</span>
            <span class="n">ev_stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">stations</span>
            <span class="n">sta_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">station_indexes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ev_stations</span><span class="p">]</span>
            <span class="n">_moveouts_arr</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">sta_indexes</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">moveouts_arr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_moveouts_arr</span> <span class="o">=</span> <span class="n">_moveouts_arr</span></div>

<div class="viewcode-block" id="Family.get_waveforms_arr"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family.get_waveforms_arr">[docs]</a>    <span class="k">def</span> <span class="nf">get_waveforms_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;read_waveforms&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">()</span>
        <span class="c1"># check the templates&#39; duration</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">ev</span><span class="o">.</span><span class="n">n_samples</span> <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Templates have different durations, we cannot return&quot;</span>
                <span class="s2">&quot; the template data in a single array.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waveforms_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">ev</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span><span class="n">stations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remember</span><span class="p">(</span><span class="s2">&quot;get_waveforms_arr&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Family.normalize"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;rms&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normalize the template waveforms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        method: string, default to &#39;rms&#39;</span>
<span class="sd">            Either &#39;rms&#39; (default) or &#39;max&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;rms&quot;</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">norm</span><span class="p">[</span><span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waveforms_arr</span> <span class="o">/=</span> <span class="n">norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remember</span><span class="p">(</span><span class="s2">&quot;normalize&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Family.read_waveforms"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family.read_waveforms">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Family.set_network"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family.set_network">[docs]</a>    <span class="k">def</span> <span class="nf">set_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update `self.network` to the new desired `network`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        network: `dataset.Network` instance</span>
<span class="sd">            The `Network` instance used to query consistent data accross all</span>
<span class="sd">            templates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updating the instance accordingly...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">action</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>
            <span class="n">func</span><span class="p">()</span></div>

<div class="viewcode-block" id="Family.set_source_receiver_dist"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Family.set_source_receiver_dist">[docs]</a>    <span class="k">def</span> <span class="nf">set_source_receiver_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the source-receiver distances for template.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">:</span>
            <span class="n">ev</span><span class="o">.</span><span class="n">set_source_receiver_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remember</span><span class="p">(</span><span class="s2">&quot;set_source_receiver_dist&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_remember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Append `action` to the list of processes to remember.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        action: string</span>
<span class="sd">            Name of the class method that was called once and that has to be</span>
<span class="sd">            repeated every time `self.network` is updated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">action</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">action</span><span class="p">)</span></div>


<div class="viewcode-block" id="EventGroup"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.EventGroup">[docs]</a><span class="k">class</span> <span class="nc">EventGroup</span><span class="p">(</span><span class="n">Family</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class for a group of events.</span>

<span class="sd">    Each event is represented by a `dataset.Event` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">network</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the EventGroup with a list of `dataset.Event` instances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        events: (n_events,) list of `dataset.Event` instances</span>
<span class="sd">            The list of events constituting the group.</span>
<span class="sd">        network: `dataset.Network` instance</span>
<span class="sd">            The `Network` instance used to query consistent data accross all</span>
<span class="sd">            events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># alias to use the parent class&#39; methods</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>

    <span class="c1"># methods</span>
<div class="viewcode-block" id="EventGroup.read_waveforms"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.EventGroup.read_waveforms">[docs]</a>    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">time_shifted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call `dataset.Event.read_waveform` with each event.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_shifted</span> <span class="o">=</span> <span class="n">time_shifted</span>
        <span class="n">disable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Reading event waveforms&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable</span><span class="p">):</span>
            <span class="n">ev</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span><span class="n">duration</span><span class="p">,</span> <span class="n">time_shifted</span><span class="o">=</span><span class="n">time_shifted</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remember</span><span class="p">(</span><span class="s2">&quot;read_waveforms&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventGroup.SVDWF_stack"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.EventGroup.SVDWF_stack">[docs]</a>    <span class="k">def</span> <span class="nf">SVDWF_stack</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">freqmin</span><span class="p">,</span>
        <span class="n">freqmax</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">,</span>
        <span class="n">expl_var</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
        <span class="n">max_singular_values</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">wiener_filter_colsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)):</span>
                <span class="n">filtered_data</span><span class="p">[:,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">SVDWF</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">[:,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:],</span>
                    <span class="n">max_singular_values</span><span class="o">=</span><span class="n">max_singular_values</span><span class="p">,</span>
                    <span class="n">expl_var</span><span class="o">=</span><span class="n">expl_var</span><span class="p">,</span>
                    <span class="n">freqmin</span><span class="o">=</span><span class="n">freqmin</span><span class="p">,</span>
                    <span class="n">freqmax</span><span class="o">=</span><span class="n">freqmax</span><span class="p">,</span>
                    <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
                    <span class="n">wiener_filter_colsize</span><span class="o">=</span><span class="n">wiener_filter_colsize</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">[:,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;Problem with station </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{:d}</span><span class="s2">), component </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{:d}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">c</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="n">stacked_waveforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">stacked_waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">norm</span><span class="p">[</span><span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">stacked_waveforms</span> <span class="o">/=</span> <span class="n">norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_data</span> <span class="o">=</span> <span class="n">filtered_data</span>
        <span class="c1"># create a stream with a fake origin time to track future</span>
        <span class="c1"># changes in reference time better</span>
        <span class="n">stacked_traces</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
        <span class="n">reference_time</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">):</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">Trace</span><span class="p">()</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="o">=</span> <span class="n">sta</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">component</span> <span class="o">=</span> <span class="n">cp</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">stacked_waveforms</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_shifted</span><span class="p">:</span>
                    <span class="n">ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;phase_on_comp</span><span class="si">{</span><span class="n">cp</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">reference_time</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="n">reference_time</span>
                <span class="n">stacked_traces</span> <span class="o">+=</span> <span class="n">tr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">(</span>
            <span class="n">stacked_traces</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">phases</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
            <span class="n">filtered_data</span><span class="o">=</span><span class="n">filtered_data</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># fetch auxiliary data</span>
        <span class="n">select</span> <span class="o">=</span> <span class="k">lambda</span> <span class="nb">str</span><span class="p">:</span> <span class="nb">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;phase_on_comp&quot;</span><span class="p">)</span>
        <span class="n">aux_data_to_keep</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">select</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">aux_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">aux_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">aux_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">aux_data_to_keep</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">aux_data</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span><span class="n">aux_data</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="TemplateGroup"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup">[docs]</a><span class="k">class</span> <span class="nc">TemplateGroup</span><span class="p">(</span><span class="n">Family</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class for a group of templates.</span>

<span class="sd">    Each template is represented by a `dataset.Template` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">templates</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">source_receiver_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the TemplateGroup instance with a list of</span>
<span class="sd">        `dataset.Template` instances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        templates: (n_templates,) list of `dataset.Template` instances</span>
<span class="sd">            The list of templates constituting the group.</span>
<span class="sd">        network: `dataset.Network` instance</span>
<span class="sd">            The `Network` instance used to query consistent data accross all</span>
<span class="sd">            templates.</span>
<span class="sd">        source_receiver_dist: boolean, default to True</span>
<span class="sd">            If True, compute the source-receiver distances on all templates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">templates</span> <span class="o">=</span> <span class="n">templates</span>
        <span class="c1"># self._events = self.templates # alias to use the base class methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
        <span class="c1"># self.n_templates = len(self.templates)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">tid</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="c1"># convenient map between template id and the template index in</span>
        <span class="c1"># the self.templates list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tindexes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;tid_to_tindex&quot;</span>
        <span class="p">)</span>
        <span class="c1"># keep track of the attributes that need updating</span>
        <span class="c1"># when self.network changes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_attributes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># compute source-receiver distances if requested</span>
        <span class="k">if</span> <span class="n">source_receiver_dist</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_source_receiver_dist</span><span class="p">()</span>

<div class="viewcode-block" id="TemplateGroup.read_from_files"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.read_from_files">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_files</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filenames</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">gids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the TemplateGroup instance given a list of filenames.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        filenames: (n_templates,) list of strings</span>
<span class="sd">            List of full file paths from which we instanciate the list of</span>
<span class="sd">            `dataset.Template` objects.</span>
<span class="sd">        network: `dataset.Network` instance</span>
<span class="sd">            The `Network` instance used to query consistent data accross all</span>
<span class="sd">            templates.</span>
<span class="sd">        gids: (n_templates,) list of strings, default to None</span>
<span class="sd">            If not None, this should be a list of group ids where the template</span>
<span class="sd">            data are stored in their hdf5 files.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        template_group: TemplateGroup instance</span>
<span class="sd">            The initialized TemplateGroup instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">templates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filenames</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">gids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="n">gids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">db_path</span><span class="p">,</span> <span class="n">db_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">templates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Template</span><span class="o">.</span><span class="n">read_from_file</span><span class="p">(</span><span class="n">db_filename</span><span class="p">,</span> <span class="n">db_path</span><span class="o">=</span><span class="n">db_path</span><span class="p">,</span> <span class="n">gid</span><span class="o">=</span><span class="n">gid</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">network</span><span class="p">)</span></div>

    <span class="c1"># properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># alias to use the parent class&#39; methods</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dir_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_dir_errors&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_dir_errors</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dir_errors</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ellipsoid_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_ellipsoid_dist&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_ellipsoid_dist</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ellipsoid_dist</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intertemplate_cc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_cc&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_intertemplate_cc</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intertemplate_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_dist&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_intertemplate_dist</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_dist</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">network_to_template_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_network_to_template_map&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_network_to_template_map</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network_to_template_map</span>

    <span class="c1"># methods</span>
<div class="viewcode-block" id="TemplateGroup.box"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.box">[docs]</a>    <span class="k">def</span> <span class="nf">box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon_min</span><span class="p">,</span> <span class="n">lon_max</span><span class="p">,</span> <span class="n">lat_min</span><span class="p">,</span> <span class="n">lat_max</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Keep templates inside the requested geographic bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        lon_min: scalar float</span>
<span class="sd">            Minimum longitude, in decimal degrees.</span>
<span class="sd">        lon_max: scalar float</span>
<span class="sd">            Maximum longitude, in decimal degrees.</span>
<span class="sd">        lat_min: scalar float</span>
<span class="sd">            Minimum latitude, in decimal degrees.</span>
<span class="sd">        lat_max: scalar float</span>
<span class="sd">            Maximum latitude, in decimal degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">templates_inside</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">longitude</span> <span class="o">&gt;=</span> <span class="n">lon_min</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">longitude</span> <span class="o">&lt;=</span> <span class="n">lon_max</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">latitude</span> <span class="o">&gt;=</span> <span class="n">lat_min</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">latitude</span> <span class="o">&lt;=</span> <span class="n">lat_max</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">templates_inside</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span> <span class="o">=</span> <span class="n">templates_inside</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">tid</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tindexes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;tid_to_tindex&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_dist&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tids</span>
                <span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_dir_errors&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dir_errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dir_errors</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_ellipsoid_dist&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ellipsoid_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ellipsoid_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_cc&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tids</span>
                <span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_waveforms_arr&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_waveforms_arr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_template_group</span> <span class="o">=</span> <span class="n">TemplateGroup</span><span class="p">(</span><span class="n">templates_inside</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">)</span>
            <span class="n">new_tids</span> <span class="o">=</span> <span class="n">new_template_group</span><span class="o">.</span><span class="n">tids</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_dist&quot;</span><span class="p">):</span>
                <span class="n">new_template_group</span><span class="o">.</span><span class="n">_intertemplate_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">new_tids</span><span class="p">,</span> <span class="n">new_tids</span>
                <span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_dir_errors&quot;</span><span class="p">):</span>
                <span class="n">new_template_group</span><span class="o">.</span><span class="n">_dir_errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dir_errors</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">new_tids</span><span class="p">,</span> <span class="n">new_tids</span>
                <span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_ellipsoid_dist&quot;</span><span class="p">):</span>
                <span class="n">new_template_group</span><span class="o">.</span><span class="n">_ellipsoid_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ellipsoid_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">new_tids</span><span class="p">,</span> <span class="n">new_tids</span>
                <span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_cc&quot;</span><span class="p">):</span>
                <span class="n">new_template_group</span><span class="o">.</span><span class="n">_intertemplate_cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">new_tids</span><span class="p">,</span> <span class="n">new_tids</span>
                <span class="p">]</span>
            <span class="k">return</span> <span class="n">new_template_group</span></div>

<div class="viewcode-block" id="TemplateGroup.compute_intertemplate_dist"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.compute_intertemplate_dist">[docs]</a>    <span class="k">def</span> <span class="nf">compute_intertemplate_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the template-pairwise distances, in km.&quot;&quot;&quot;</span>
        <span class="n">longitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">longitude</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="n">latitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">latitude</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="n">depths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">depth</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="n">_intertemplate_dist</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">compute_distances</span><span class="p">(</span>
            <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">depths</span><span class="p">,</span> <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">,</span> <span class="n">depths</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_dist</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">_intertemplate_dist</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TemplateGroup.compute_dir_errors"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.compute_dir_errors">[docs]</a>    <span class="k">def</span> <span class="nf">compute_dir_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute length of uncertainty ellipsoid in inter-template direction.</span>

<span class="sd">        New Attributes</span>
<span class="sd">        --------------</span>
<span class="sd">        _dir_errors: (n_templates, n_templates) pandas.DataFrame</span>
<span class="sd">            The length, in kilometers, of the uncertainty ellipsoid in the</span>
<span class="sd">            inter-template direction.</span>
<span class="sd">            Example: self.directional_errors.loc[tid1, tid2] is the width of</span>
<span class="sd">            template tid1&#39;s uncertainty ellipsoid in the direction of</span>
<span class="sd">            template tid2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">cartopy</span> <span class="kn">import</span> <span class="n">crs</span>

        <span class="c1"># X: west, Y: south, Z: downward</span>
        <span class="n">s_68_3df</span> <span class="o">=</span> <span class="mf">3.52</span>
        <span class="n">s_90_3df</span> <span class="o">=</span> <span class="mf">6.251</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing the inter-template directional errors...&quot;</span><span class="p">)</span>
        <span class="n">longitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">longitude</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="n">latitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">latitude</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="n">depths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">tp</span><span class="o">.</span><span class="n">depth</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="c1"># ----------------------------------------------</span>
        <span class="c1">#      Define the projection used to</span>
        <span class="c1">#      work in a cartesian space</span>
        <span class="c1"># ----------------------------------------------</span>
        <span class="n">data_coords</span> <span class="o">=</span> <span class="n">crs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">()</span>
        <span class="n">projection</span> <span class="o">=</span> <span class="n">crs</span><span class="o">.</span><span class="n">Mercator</span><span class="p">(</span>
            <span class="n">central_longitude</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">longitudes</span><span class="p">),</span>
            <span class="n">min_latitude</span><span class="o">=</span><span class="n">latitudes</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
            <span class="n">max_latitude</span><span class="o">=</span><span class="n">latitudes</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="n">XY</span> <span class="o">=</span> <span class="n">projection</span><span class="o">.</span><span class="n">transform_points</span><span class="p">(</span><span class="n">data_coords</span><span class="p">,</span> <span class="n">longitudes</span><span class="p">,</span> <span class="n">latitudes</span><span class="p">)</span>
        <span class="n">cartesian_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">depths</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># compute the directional errors</span>
        <span class="n">_dir_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">):</span>
            <span class="n">unit_direction</span> <span class="o">=</span> <span class="n">cartesian_coords</span> <span class="o">-</span> <span class="n">cartesian_coords</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">unit_direction</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">unit_direction</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span>
                <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span>
            <span class="p">]</span>
            <span class="c1"># this operation produced NaNs for i=t</span>
            <span class="n">unit_direction</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">unit_direction</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="s2">&quot;cov_mat&quot;</span><span class="p">):</span>
                <span class="c1"># compute the length of the covariance ellipsoid</span>
                <span class="c1"># in the direction that links the two earthquakes</span>
                <span class="n">cov_dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">cov_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">unit_direction</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">unit_direction</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># covariance is unit of [distance**2], therefore we need the sqrt:</span>
                <span class="n">_dir_errors</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_68_3df</span> <span class="o">*</span> <span class="n">cov_dir</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># use default large error</span>
                <span class="n">_dir_errors</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">15.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dir_errors</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">_dir_errors</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TemplateGroup.compute_ellipsoid_dist"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.compute_ellipsoid_dist">[docs]</a>    <span class="k">def</span> <span class="nf">compute_ellipsoid_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute separation between unc. ellipsoids in inter-template dir.</span>

<span class="sd">        Can be negative if the uncertainty ellipsoids overlap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ellipsoid_dist</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intertemplate_dist</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir_errors</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir_errors</span><span class="o">.</span><span class="n">T</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TemplateGroup.compute_intertemplate_cc"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.compute_intertemplate_cc">[docs]</a>    <span class="k">def</span> <span class="nf">compute_intertemplate_cc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">distance_threshold</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
        <span class="n">n_stations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">max_lag</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">save_cc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">compute_from_scratch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span>
        <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the pairwise template CCs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        distance_threshold: float, default to 5</span>
<span class="sd">            The distance threshold, in kilometers, between two</span>
<span class="sd">            uncertainty ellipsoids under which similarity is computed.</span>
<span class="sd">        n_stations: integer, default to 10</span>
<span class="sd">            The number of stations closest to each template used in</span>
<span class="sd">            the computation of the average CC.</span>
<span class="sd">        max_lag: integer, default to 10</span>
<span class="sd">            Maximum lag, in samples, allowed when searching for the</span>
<span class="sd">            maximum CC on each channel. This is to account for small</span>
<span class="sd">            discrepancies in windowing that could occur for two templates</span>
<span class="sd">            highly similar but associated to slightly different locations.</span>
<span class="sd">        save_cc: boolean, default to False</span>
<span class="sd">            If True, save the inter-template CCs in the same folder as</span>
<span class="sd">            `self.templates[0]` and with filename &#39;intertp_cc.h5&#39;.</span>
<span class="sd">        compute_from_scratch: boolean, default to False</span>
<span class="sd">            If True, force to compute the inter-template CCs from scratch.</span>
<span class="sd">            Useful if user knows the computation is faster than reading a</span>
<span class="sd">            potentially large file.</span>
<span class="sd">        device: string, default to &#39;cpu&#39;</span>
<span class="sd">            Either &#39;cpu&#39; or &#39;gpu&#39;.</span>
<span class="sd">        progress: boolean, default to False</span>
<span class="sd">            If True, print progress bar with `tqdm`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">fast_matched_filter</span> <span class="k">as</span> <span class="nn">fmf</span>  <span class="c1"># clearly need some optimization</span>

        <span class="n">disable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>

        <span class="c1"># try reading the inter-template CC from db</span>
        <span class="n">db_path</span><span class="p">,</span> <span class="n">db_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
        <span class="n">cc_fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="s2">&quot;intertp_cc.h5&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">compute_from_scratch</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">cc_fn</span><span class="p">):</span>
            <span class="n">_intertemplate_cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_intertp_cc</span><span class="p">(</span><span class="n">cc_fn</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">_intertemplate_cc</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>
                <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span>
            <span class="p">):</span>
                <span class="c1"># all current templates are contained in intertp_cc</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span> <span class="o">=</span> <span class="n">_intertemplate_cc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read inter-template CCs from </span><span class="si">{</span><span class="n">cc_fn</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">compute_from_scratch</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compute_from_scratch</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">compute_from_scratch</span><span class="p">:</span>
            <span class="c1"># compute from scratch</span>
            <span class="c1">#self.n_closest_stations(n_stations)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing the similarity matrix...&quot;</span><span class="p">)</span>
            <span class="c1"># format arrays for FMF</span>
            <span class="n">data_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">template_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">:</span><span class="o">-</span><span class="n">max_lag</span><span class="p">]</span>
            <span class="n">moveouts_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">intertp_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
            <span class="p">)</span>
            <span class="n">n_network_stations</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="n">moveouts_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="c1"># use FMF on one template at a time against all others</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">template</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Inter-tp CC&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable</span>
            <span class="p">):</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">template_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="c1"># select the `n_stations` closest stations</span>
                <span class="c1"># apply similar approach than Event.n_closest_stations</span>
                <span class="n">station_pool</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">network_stations</span><span class="p">[</span><span class="n">template</span><span class="o">.</span><span class="n">availability</span><span class="p">]</span>
                <span class="n">closest_stations</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">template</span><span class="o">.</span><span class="n">source_receiver_dist</span>\
                                <span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station_pool</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="n">n_stations</span><span class="p">]</span>
                        <span class="p">)</span>
                <span class="c1"># make sure we return a n_stations-vector</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_stations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_stations</span><span class="p">:</span>
                    <span class="n">missing</span> <span class="o">=</span> <span class="n">n_stations</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_stations</span><span class="p">)</span>
                    <span class="n">closest_stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">closest_stations</span><span class="p">,</span>
                            <span class="n">template</span><span class="o">.</span><span class="n">source_receiver_dist</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">closest_stations</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;rows&quot;</span><span class="p">)</span>
                            <span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
                            <span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="n">missing</span><span class="p">],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">network_stations</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">closest_stations</span><span class="p">:</span>
                        <span class="n">weights</span><span class="p">[:,</span> <span class="n">s</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span>
                                <span class="n">template</span><span class="o">.</span><span class="n">availability_per_cha</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                                <span class="p">)</span>
                <span class="n">weights</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">above_thrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ellipsoid_dist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">[</span><span class="n">t</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">distance_threshold</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">above_thrs</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">cc</span> <span class="o">=</span> <span class="n">fmf</span><span class="o">.</span><span class="n">matched_filter</span><span class="p">(</span>
                    <span class="n">template_arr</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                    <span class="n">moveouts_arr</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                    <span class="n">data_arr</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                    <span class="mi">1</span><span class="p">,</span>
                    <span class="n">arch</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                    <span class="n">network_sum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">check_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">intertp_cc</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">keep</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="c1"># make the CC matrix symmetric by averaging the lower</span>
            <span class="c1"># and upper triangles</span>
            <span class="n">_intertemplate_cc</span> <span class="o">=</span> <span class="p">(</span><span class="n">intertp_cc</span> <span class="o">+</span> <span class="n">intertp_cc</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">_intertemplate_cc</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">compute_from_scratch</span> <span class="ow">and</span> <span class="n">save_cc</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving inter-tp CC to </span><span class="si">{</span><span class="n">cc_fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_intertp_cc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_intertemplate_cc</span><span class="p">,</span> <span class="n">cc_fn</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_save_intertp_cc</span><span class="p">(</span><span class="n">intertp_cc</span><span class="p">,</span> <span class="n">fullpath</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save inter-template correlation coefficients.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        intertp_cc: `pd.DataFrame`</span>
<span class="sd">            The inter-template CC computed by `compute_intertemplate_cc`.</span>
<span class="sd">        fullpath: string</span>
<span class="sd">            Full path to output file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;tids&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">intertp_cc</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;intertp_cc&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">intertp_cc</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_intertp_cc</span><span class="p">(</span><span class="n">fullpath</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read inter-template correlation coefficients from file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        fullpath: string</span>
<span class="sd">            Full path to output file.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        intertp_cc: `pd.DataFrame`</span>
<span class="sd">            The inter-template CC in a `pd.DataFrame`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fullpath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">tids</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;tids&quot;</span><span class="p">][()]</span>
            <span class="n">intertp_cc</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;intertp_cc&quot;</span><span class="p">][()]</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">tids</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">tids</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">intertp_cc</span><span class="p">)</span>

<div class="viewcode-block" id="TemplateGroup.read_waveforms"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.read_waveforms">[docs]</a>    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        progress: boolean, default to False</span>
<span class="sd">            If True, print progress bar with `tqdm`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">disable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_threads</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>
            <span class="c1"># cannot use tqdm with parallel execution</span>
            <span class="n">disable</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">n_threads</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]:</span>
                <span class="c1"># n_threads = None means use all CPUs</span>
                <span class="n">n_threads</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">n_threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                <span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">tp</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span>
                            <span class="n">stations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span>
                            <span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">templates</span>
                        <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Reading waveforms&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable</span><span class="p">):</span>
                <span class="n">tp</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span><span class="n">stations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remember</span><span class="p">(</span><span class="s2">&quot;read_waveforms&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TemplateGroup.set_network_to_template_map"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.set_network_to_template_map">[docs]</a>    <span class="k">def</span> <span class="nf">set_network_to_template_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the map between network arrays and template data.</span>

<span class="sd">        Template data are broadcasted to fit the dimensions of the network</span>
<span class="sd">        arrays. This method computes the `network_to_template_map` that tells</span>
<span class="sd">        which stations and channels are used on each template. For example:</span>
<span class="sd">        `network_to_template_map[t, s, c] = False` means that station s and</span>
<span class="sd">        channel c are not used on template t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_network_to_template_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_templates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_stations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">n_components</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># 1) find the non-zero channels</span>
        <span class="n">_network_to_template_map</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="c1"># 2) only keep the stations that were selected on each template</span>
        <span class="n">selected_stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_network_to_template_map</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">tp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">):</span>
            <span class="n">valid_sta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">station_indexes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">stations</span><span class="p">]</span>
            <span class="n">selected_stations</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">valid_sta</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">_network_to_template_map</span> <span class="o">=</span> <span class="n">_network_to_template_map</span> <span class="o">&amp;</span> <span class="n">selected_stations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_network_to_template_map</span> <span class="o">=</span> <span class="n">_network_to_template_map</span></div>

<div class="viewcode-block" id="TemplateGroup.n_best_SNR_stations"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.n_best_SNR_stations">[docs]</a>    <span class="k">def</span> <span class="nf">n_best_SNR_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust `self.stations` on each template to the `n` best SNR stations.</span>


<span class="sd">        Find the `n` best stations and modify `self.stations` accordingly.</span>
<span class="sd">        The instance&#39;s properties will also change accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        n: scalar int</span>
<span class="sd">            The `n` closest stations.</span>
<span class="sd">        available_stations: list of strings, default to None</span>
<span class="sd">            The list of stations from which we search the closest stations.</span>
<span class="sd">            If some stations are known to lack data, the user</span>
<span class="sd">            may choose to not include these in the closest stations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">:</span>
            <span class="n">tp</span><span class="o">.</span><span class="n">n_best_SNR_stations</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">=</span><span class="n">available_stations</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_network_to_template_map&quot;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network_to_template_map</span></div>

<div class="viewcode-block" id="TemplateGroup.n_closest_stations"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.n_closest_stations">[docs]</a>    <span class="k">def</span> <span class="nf">n_closest_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust `self.stations` on each template to the `n` closest stations.</span>


<span class="sd">        Find the `n` closest stations and modify `self.stations` accordingly.</span>
<span class="sd">        The instance&#39;s properties will also change accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        n: scalar int</span>
<span class="sd">            The `n` closest stations to fetch.</span>
<span class="sd">        available_stations: list of strings, default to None</span>
<span class="sd">            The list of stations from which we search the closest stations.</span>
<span class="sd">            If some stations are known to lack data, the user</span>
<span class="sd">            may choose to not include these in the closest stations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">:</span>
            <span class="n">tp</span><span class="o">.</span><span class="n">n_closest_stations</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">available_stations</span><span class="o">=</span><span class="n">available_stations</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_network_to_template_map&quot;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network_to_template_map</span></div>

<div class="viewcode-block" id="TemplateGroup.read_catalog"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.read_catalog">[docs]</a>    <span class="k">def</span> <span class="nf">read_catalog</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">extra_attributes</span><span class="o">=</span><span class="p">[],</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a catalog from all templates&#39; detections.</span>

<span class="sd">        Work only if folder and file names follow the standard convention.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        extra_attributes: list of strings, default to []</span>
<span class="sd">            Attributes to read in addition to the default &#39;longitude&#39;,</span>
<span class="sd">            &#39;latitude&#39;, &#39;depth&#39;, and &#39;origin_time&#39;.</span>
<span class="sd">        fill_value: string, int, or float, default to np.nan</span>
<span class="sd">            Default value if the target attribute does not exist.</span>
<span class="sd">        progress: boolean, default to False</span>
<span class="sd">            If True, print progress bar with `tqdm`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">disable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Reading catalog&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="s2">&quot;catalog&quot;</span><span class="p">):</span>
                <span class="n">template</span><span class="o">.</span><span class="n">read_catalog</span><span class="p">(</span>
                    <span class="n">extra_attributes</span><span class="o">=</span><span class="n">extra_attributes</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
        <span class="c1"># concatenate all catalogs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span> <span class="o">=</span> <span class="n">Catalog</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">template</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span> <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">],</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TemplateGroup.remove_multiples"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.remove_multiples">[docs]</a>    <span class="k">def</span> <span class="nf">remove_multiples</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_closest_stations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">dt_criterion</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
        <span class="n">distance_criterion</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">speed_criterion</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
        <span class="n">similarity_criterion</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Search for events detected by multiple templates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        n_closest_stations: integer, default to 10</span>
<span class="sd">            In case template similarity is taken into account,</span>
<span class="sd">            this is the number of stations closest to each template</span>
<span class="sd">            that are used in the calculation of the average cc.</span>
<span class="sd">        dt_criterion: float, default to 4</span>
<span class="sd">            Time interval, in seconds, under which two events are</span>
<span class="sd">            examined for redundancy.</span>
<span class="sd">        distance_criterion: float, default to 1</span>
<span class="sd">            Distance threshold, in kilometers, between two uncertainty</span>
<span class="sd">            ellipsoids under which two events are examined for redundancy.</span>
<span class="sd">        speed_criterion: float, default to 5</span>
<span class="sd">            Speed criterion, in km/s, below which the inter-event time and</span>
<span class="sd">            inter-event distance can be explained by errors in origin times and</span>
<span class="sd">            a reasonable P-wave speed.</span>
<span class="sd">        similarity_criterion: float, default to -1</span>
<span class="sd">            Template similarity threshold, in terms of average CC, over</span>
<span class="sd">            which two events are examined for redundancy. The default</span>
<span class="sd">            value of -1 is always verified, meaning that similarity is</span>
<span class="sd">            actually not taken into account.</span>
<span class="sd">        progress: boolean, default to False</span>
<span class="sd">            If True, print progress bar with `tqdm`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">disable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;catalog&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_catalog</span><span class="p">(</span><span class="n">extra_attributes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cc&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[ms]&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
            <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;origin_time_sec&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;interevent_time_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time_sec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time_sec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># alias:</span>
        <span class="n">catalog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">similarity_criterion</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_cc&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">similarity_criterion</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_intertemplate_cc&quot;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I&#39;m here!&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_intertemplate_cc</span><span class="p">(</span>
                    <span class="n">distance_threshold</span><span class="o">=</span><span class="n">distance_criterion</span><span class="p">,</span>
                    <span class="n">n_stations</span><span class="o">=</span><span class="n">n_closest_stations</span><span class="p">,</span>
                    <span class="n">max_lag</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_lag&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                    <span class="n">device</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;device&quot;</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;What about </span><span class="si">{</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;_intertemplate_cc&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># -----------------------------------</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">give_time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Searching for events detected by multiple templates&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;All events occurring within </span><span class="si">{:.1f}</span><span class="s2"> sec, with uncertainty &quot;</span>
            <span class="s2">&quot;ellipsoids closer than </span><span class="si">{:.1f}</span><span class="s2"> km will and &quot;</span>
            <span class="s2">&quot;inter-template CC larger than </span><span class="si">{:.2f}</span><span class="s2"> be considered the same&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">dt_criterion</span><span class="p">,</span> <span class="n">distance_criterion</span><span class="p">,</span> <span class="n">similarity_criterion</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">n_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">)</span>
        <span class="n">index_pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_events</span><span class="p">)</span>
        <span class="c1"># dt_criterion = np.timedelta64(int(1000.0 * dt_criterion), &quot;ms&quot;)</span>
        <span class="n">unique_event</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_events</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_events</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Removing multiples&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">unique_event</span><span class="p">[</span><span class="n">n1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">tid1</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;tid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span>
            <span class="c1"># apply the time criterion</span>
            <span class="c1"># ---------- version 4 ------------</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">n2</span> <span class="o">&lt;</span> <span class="n">n_events</span><span class="p">:</span>
                <span class="n">dt_n1n2</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;interevent_time_sec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">temporal_neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">n1</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">dt_n1n2</span> <span class="o">&lt;</span> <span class="n">dt_criterion</span><span class="p">:</span>
                <span class="n">temporal_neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
                <span class="n">n2</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="o">&gt;=</span> <span class="n">n_events</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">dt_n1n2</span> <span class="o">+=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;interevent_time_sec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span>
            <span class="n">temporal_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">temporal_neighbors</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temporal_neighbors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># did not find any temporal neighbors</span>
                <span class="k">continue</span>
            <span class="c1"># remove events that were already flagged as non unique</span>
            <span class="n">temporal_neighbors</span> <span class="o">=</span> <span class="n">temporal_neighbors</span><span class="p">[</span><span class="n">unique_event</span><span class="p">[</span><span class="n">temporal_neighbors</span><span class="p">]]</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">temporal_neighbors</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># get template ids of all events that passed the time criterion</span>
            <span class="n">tids_candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;tid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
            <span class="c1"># apply the spatial criterion to the distance between</span>
            <span class="c1"># uncertainty ellipsoids</span>
            <span class="n">ellips_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ellipsoid_dist</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tid1</span><span class="p">,</span> <span class="n">tids_candidates</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">time_diff</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time_sec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">candidates</span><span class="p">]</span>
                <span class="o">-</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;origin_time_sec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="c1"># if the time difference were to be entirely due to errors in</span>
            <span class="c1"># origin times, what would be wave speed explaining the location</span>
            <span class="c1"># differences?</span>
            <span class="c1"># time_diff = 0 is the time_diff between n1 and n1</span>
            <span class="n">time_diff</span><span class="p">[</span><span class="n">time_diff</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">speed_diff</span> <span class="o">=</span> <span class="n">ellips_dist</span> <span class="o">/</span> <span class="n">time_diff</span>
            <span class="k">if</span> <span class="n">similarity_criterion</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
                <span class="n">similarities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intertemplate_cc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tid1</span><span class="p">,</span> <span class="n">tids_candidates</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">multiples</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="p">(</span><span class="n">ellips_dist</span> <span class="o">&lt;</span> <span class="n">distance_criterion</span><span class="p">)</span>
                            <span class="o">|</span> <span class="p">(</span><span class="n">speed_diff</span> <span class="o">&lt;</span> <span class="n">speed_criterion</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="o">&amp;</span> <span class="p">(</span><span class="n">similarities</span> <span class="o">&gt;=</span> <span class="n">similarity_criterion</span><span class="p">)</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">multiples</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ellips_dist</span> <span class="o">&lt;</span> <span class="n">distance_criterion</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">multiples</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_event</span><span class="p">[</span><span class="n">multiples</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># find best CC and keep it</span>
                <span class="n">ccs</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;cc&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multiples</span><span class="p">]</span>
                <span class="n">best_cc</span> <span class="o">=</span> <span class="n">multiples</span><span class="p">[</span><span class="n">ccs</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
                <span class="n">unique_event</span><span class="p">[</span><span class="n">best_cc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">give_time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s to flag the multiples&quot;</span><span class="p">)</span>
        <span class="c1"># -------------------------------------------</span>
        <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;unique_event&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_event</span>
        <span class="k">for</span> <span class="n">tid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tids</span><span class="p">:</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tindexes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span>
            <span class="n">cat_indexes</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;tid&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">tid</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;unique_event&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="n">cat_indexes</span><span class="p">,</span> <span class="s2">&quot;unique_event&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cat_indexes</span><span class="p">,</span> <span class="s2">&quot;unique_event&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span></div>

    <span class="c1"># plotting routines</span>
<div class="viewcode-block" id="TemplateGroup.plot_detection"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.plot_detection">[docs]</a>    <span class="k">def</span> <span class="nf">plot_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        idx: scalar int</span>
<span class="sd">            Event index in `self.catalog.catalog`.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------</span>
<span class="sd">        fig: `plt.Figure`</span>
<span class="sd">            The figure showing the detected event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tid</span><span class="p">,</span> <span class="n">evidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tindexes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">tid</span><span class="p">)]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Plotting:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">plot_detection</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">evidx</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="TemplateGroup.plot_recurrence_times"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.TemplateGroup.plot_recurrence_times">[docs]</a>    <span class="k">def</span> <span class="nf">plot_recurrence_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot recurrence times vs detection times, template-wise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        figsize: tuple of floats, default to (20, 10)</span>
<span class="sd">            Size in inches of the figure (width, height).</span>
<span class="sd">        progress: boolean, default to False</span>
<span class="sd">            If True, print progress bar with `tqdm`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">disable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="s2">&quot;recurrence_times&quot;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Plotting rec. times&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable</span>
        <span class="p">):</span>
            <span class="n">template</span><span class="o">.</span><span class="n">plot_recurrence_times</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">annotate_axes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Detection Time&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Recurrence Time (s)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">semilogy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span></div></div>


<div class="viewcode-block" id="Stack"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Stack">[docs]</a><span class="k">class</span> <span class="nc">Stack</span><span class="p">(</span><span class="n">Event</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A modification of the Event class for stacked events.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stacked_traces</span><span class="p">,</span>
        <span class="n">moveouts</span><span class="p">,</span>
        <span class="n">stations</span><span class="p">,</span>
        <span class="n">phases</span><span class="p">,</span>
        <span class="n">latitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">longitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
        <span class="n">sampling_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
        <span class="n">aux_data</span><span class="o">=</span><span class="p">{},</span>
        <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">filtered_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize an Event instance with basic attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        stacked_traces: `obspy.Stream`</span>
<span class="sd">            Traces with the stacked waveforms.</span>
<span class="sd">        moveouts: (n_stations, n_phases) float `numpy.ndarray`</span>
<span class="sd">            Moveouts, in seconds, for each station and each phase.</span>
<span class="sd">        stations: List of strings</span>
<span class="sd">            List of station names corresponding to `moveouts`.</span>
<span class="sd">        phases: List of strings</span>
<span class="sd">            List of phase names corresponding to `moveouts`.</span>
<span class="sd">        latitude: scalar float, default to None</span>
<span class="sd">            Event latitude.</span>
<span class="sd">        longitude: scalar float, default to None</span>
<span class="sd">            Event longitude.</span>
<span class="sd">        depth: scalar float, default to None</span>
<span class="sd">            Event depth.</span>
<span class="sd">        sampling_rate: scalar float, default to None</span>
<span class="sd">            Sampling rate (Hz) of the waveforms. It should be different from</span>
<span class="sd">            None only if you plan on reading preprocessed data with a fixed</span>
<span class="sd">            sampling rate.</span>
<span class="sd">        components: List of strings, default to [&#39;N&#39;,&#39;E&#39;,&#39;Z&#39;]</span>
<span class="sd">            List of the components to use in reading and plotting methods.</span>
<span class="sd">        component_aliases: Dictionary, optional</span>
<span class="sd">            Each entry of the dictionary is a list of strings.</span>
<span class="sd">            `component_aliases[comp]` is the list of all aliases used for</span>
<span class="sd">            the same component &#39;comp&#39;. For example, `component_aliases[&#39;N&#39;] =</span>
<span class="sd">            [&#39;N&#39;, &#39;1&#39;]` means that both the &#39;N&#39; and &#39;1&#39; channels will be mapped</span>
<span class="sd">            to the Event&#39;s &#39;N&#39; channel.</span>
<span class="sd">        aux_data: dictionary, optional</span>
<span class="sd">            Dictionary with auxiliary data (see `dataset.Event`). Note that</span>
<span class="sd">            aux_data[&#39;phase_on_comp{cp}&#39;] is necessary to call</span>
<span class="sd">            `self.read_waveforms`.</span>
<span class="sd">        id: string, default to None</span>
<span class="sd">            Identifying label.</span>
<span class="sd">        filtered_data: (n_events, n_stations, n_components, n_samples)</span>
<span class="sd">        `numpy.ndarray`, default to None</span>
<span class="sd">            The event waveforms filtered by the SVDWF technique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stacked_traces</span> <span class="o">=</span> <span class="n">stacked_traces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_data</span> <span class="o">=</span> <span class="n">filtered_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span>  <span class="c1"># for compatibility with Data class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">stations</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">components</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">component_aliases</span> <span class="o">=</span> <span class="n">component_aliases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">latitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">longitude</span> <span class="o">=</span> <span class="n">longitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate</span>
        <span class="k">if</span> <span class="n">moveouts</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Integer data type detected for moveouts. Are you sure these&quot;</span>
                <span class="s2">&quot; are in seconds?&quot;</span>
            <span class="p">)</span>
        <span class="c1"># format moveouts in a Pandas data frame</span>
        <span class="n">mv_table</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">ph</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">):</span>
            <span class="n">mv_table</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">moveouts</span><span class="p">[:,</span> <span class="n">p</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">mv_table</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">_%H%M%S&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>

<div class="viewcode-block" id="Stack.read_waveforms"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Stack.read_waveforms">[docs]</a>    <span class="k">def</span> <span class="nf">read_waveforms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">,</span>
        <span class="n">phase_on_comp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">},</span>
        <span class="n">offset_phase</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">},</span>
        <span class="n">time_shifted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">offset_ot</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">BUFFER_EXTRACTED_EVENTS_SEC</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read waveform data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        duration: scalar float</span>
<span class="sd">            Duration, in seconds, of the extracted time windows.</span>
<span class="sd">        phase_on_comp: dictionary, optional</span>
<span class="sd">            Dictionary defining which seismic phase is extracted on each</span>
<span class="sd">            component. For example, phase_on_comp[&#39;N&#39;] gives the phase that is</span>
<span class="sd">            extracted on the north component.</span>
<span class="sd">        offset_phase: dictionary, optional</span>
<span class="sd">            Dictionary defining when the time window starts with respect to the</span>
<span class="sd">            pick. A positive offset means the window starts before the pick. Not</span>
<span class="sd">            used if `time_shifted` is False.</span>
<span class="sd">        time_shifted: boolean, default to True</span>
<span class="sd">            If True, the moveouts are used to extract time windows from specific</span>
<span class="sd">            seismic phases. If False, windows are simply extracted with respect to</span>
<span class="sd">            the origin time.</span>
<span class="sd">        offset_ot: scalar float, default to `cfg.BUFFER_EXTRACTED_EVENTS_SEC`</span>
<span class="sd">            Only used if `time_shifted` is False. Time, in seconds, taken before</span>
<span class="sd">            `origin_time`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sec_to_samp</span><span class="p">(</span><span class="n">duration</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">):</span>
                <span class="n">ph</span> <span class="o">=</span> <span class="n">phase_on_comp</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">time_shifted</span><span class="p">:</span>
                    <span class="n">mv</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">offset_ot</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveouts</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;moveouts_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span>
                        <span class="o">-</span> <span class="n">offset_phase</span><span class="p">[</span><span class="n">ph</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mv</span> <span class="o">=</span> <span class="n">offset_ot</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stacked_traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">cp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="o">.</span><span class="n">slice</span><span class="p">(</span>
                        <span class="n">starttime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">mv</span><span class="p">,</span>
                        <span class="n">endtime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">mv</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span>
                    <span class="n">starttime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">mv</span><span class="p">,</span>
                    <span class="n">endtime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_time</span> <span class="o">+</span> <span class="n">mv</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span>
                    <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">+=</span> <span class="n">tr</span>
        <span class="n">aux_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;offset_</span><span class="si">{</span><span class="n">ph</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">offset_phase</span><span class="p">[</span><span class="n">ph</span><span class="p">]</span> <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">offset_phase</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aux_data</span><span class="p">(</span><span class="n">aux_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_availability</span><span class="p">(</span><span class="n">stations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stack.pick_PS_phases_family_mode"><a class="viewcode-back" href="../../usage/api/dataset.html#BPMF.dataset.Stack.pick_PS_phases_family_mode">[docs]</a>    <span class="k">def</span> <span class="nf">pick_PS_phases_family_mode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">,</span>
        <span class="n">threshold_P</span><span class="o">=</span><span class="mf">0.60</span><span class="p">,</span>
        <span class="n">threshold_S</span><span class="o">=</span><span class="mf">0.60</span><span class="p">,</span>
        <span class="n">mini_batch_size</span><span class="o">=</span><span class="mi">126</span><span class="p">,</span>
        <span class="n">phase_on_comp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">},</span>
        <span class="n">n_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">err_threshold</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">central</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
        <span class="n">upsampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">downsampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">ml_model_name</span><span class="o">=</span><span class="s2">&quot;original&quot;</span><span class="p">,</span>
        <span class="n">ml_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use PhaseNet (Zhu et al., 2019) to pick P and S waves.</span>

<span class="sd">        Note1: PhaseNet must be used with 3-comp data.</span>
<span class="sd">        Note2: Extra kwargs are passed to</span>
<span class="sd">        `phasenet.wrapper.automatic_detection`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        duration: scalar float</span>
<span class="sd">            Duration, in seconds, of the time window to process to search for P</span>
<span class="sd">            and S wave arrivals.</span>
<span class="sd">        threshold_P: scalar float, default to 0.60</span>
<span class="sd">            Threshold on PhaseNet&#39;s probabilities to trigger the identification</span>
<span class="sd">            of a P-wave arrival.</span>
<span class="sd">        threshold_S: scalar float, default to 0.60</span>
<span class="sd">            Threshold on PhaseNet&#39;s probabilities to trigger the identification</span>
<span class="sd">            of a S-wave arrival.</span>
<span class="sd">        mini_batch_size: scalar int, default to 126</span>
<span class="sd">            Number of traces processed in a single batch by PhaseNet. This</span>
<span class="sd">            shouldn&#39;t have to be tuned.</span>
<span class="sd">        phase_on_comp: dictionary, optional</span>
<span class="sd">            Dictionary defining which seismic phase is extracted on each</span>
<span class="sd">            component. For example, phase_on_comp[&#39;N&#39;] gives the phase that is</span>
<span class="sd">            extracted on the north component.</span>
<span class="sd">        upsampling: scalar integer, default to 1</span>
<span class="sd">            Upsampling factor applied before calling PhaseNet.</span>
<span class="sd">        downsampling: scalar integer, default to 1</span>
<span class="sd">            Downsampling factor applied before calling PhaseNet.</span>
<span class="sd">        n_threshold: scalar int, optional</span>
<span class="sd">            Used if `self.filtered_data` is not None. Minimum number of</span>
<span class="sd">            successful picks to keep the phase. Default to 1.</span>
<span class="sd">        err_threshold: scalar int or float, optional</span>
<span class="sd">            Used if `self.filtered_data` is not None. Maximum error (in samples)</span>
<span class="sd">            on pick to keep the phase. Default to 100.</span>
<span class="sd">        central: string, optional</span>
<span class="sd">            Used if `self.filtered_data` is not None. Either &#39;mean&#39; or &#39;mode&#39;.</span>
<span class="sd">            The pick is either taken as the mean or the mode of the empirical</span>
<span class="sd">            distribution of picks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">no_grad</span><span class="p">,</span> <span class="n">from_numpy</span>

        <span class="k">if</span> <span class="n">ml_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">seisbench.models</span> <span class="k">as</span> <span class="nn">sbm</span>
            <span class="n">ml_model</span> <span class="o">=</span> <span class="n">sbm</span><span class="o">.</span><span class="n">PhaseNet</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">ml_model_name</span><span class="p">)</span>
            <span class="n">ml_model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

        <span class="n">ml_p_index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ml_P_index&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ml_s_index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ml_S_index&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># read waveforms in &quot;picking&quot; mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_waveforms</span><span class="p">(</span>
            <span class="n">duration</span><span class="p">,</span>
            <span class="n">offset_ot</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">phase_on_comp</span><span class="o">=</span><span class="n">phase_on_comp</span><span class="p">,</span>
            <span class="n">time_shifted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">data_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_np_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">data_arr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_data</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">upsampling</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">downsampling</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">resample_poly</span>

                <span class="n">data_arr</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="n">upsampling</span><span class="p">,</span> <span class="n">downsampling</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># momentarily update samping_rate</span>
                <span class="n">sampling_rate0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span> <span class="o">*</span> <span class="n">upsampling</span> <span class="o">/</span> <span class="n">downsampling</span>
            <span class="n">num_events</span><span class="p">,</span> <span class="n">num_stations</span> <span class="o">=</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">num_traces</span> <span class="o">=</span> <span class="n">num_events</span> <span class="o">*</span> <span class="n">num_stations</span>
            <span class="n">data_arr_n</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_batch</span><span class="p">(</span>
                    <span class="n">data_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_traces</span><span class="p">,</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                    <span class="p">)</span>
            <span class="n">closest_pow2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">data_arr_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">closest_pow2</span> <span class="o">-</span> <span class="n">data_arr_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">diff</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">diff</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="n">diff</span><span class="o">%</span><span class="mi">2</span>
            <span class="n">data_arr_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                    <span class="n">data_arr_n</span><span class="p">,</span>
                    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)),</span>
                    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span>
                    <span class="p">)</span>
            <span class="k">with</span> <span class="n">no_grad</span><span class="p">():</span>
                <span class="n">ml_probas</span> <span class="o">=</span> <span class="n">ml_model</span><span class="p">(</span>
                        <span class="n">from_numpy</span><span class="p">(</span><span class="n">data_arr_n</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
                        <span class="p">)</span>
                <span class="n">ml_probas</span> <span class="o">=</span> <span class="n">ml_probas</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="c1"># find picks and sotre in dictionaries</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">],</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">],</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_events</span><span class="p">):</span>
                    <span class="n">tr_idx</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">num_events</span> <span class="o">+</span> <span class="n">n</span>
                    <span class="n">P_proba</span><span class="p">,</span> <span class="n">P_pick</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">trigger_picks</span><span class="p">(</span>
                            <span class="n">ml_probas</span><span class="p">[</span><span class="n">tr_idx</span><span class="p">,</span> <span class="n">ml_p_index</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="o">-</span><span class="n">right</span><span class="p">],</span> <span class="n">threshold_P</span><span class="p">,</span> 
                            <span class="p">)</span>
                    <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P_proba</span><span class="p">)</span>
                    <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P_pick</span><span class="p">)</span>
                    <span class="n">S_proba</span><span class="p">,</span> <span class="n">S_pick</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">trigger_picks</span><span class="p">(</span>
                            <span class="n">ml_probas</span><span class="p">[</span><span class="n">tr_idx</span><span class="p">,</span> <span class="n">ml_s_index</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="o">-</span><span class="n">right</span><span class="p">],</span> <span class="n">threshold_S</span><span class="p">,</span> 
                            <span class="p">)</span>
                    <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_proba</span><span class="p">)</span>
                    <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_pick</span><span class="p">)</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">])</span>
                        <span class="p">)</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">])</span>
                        <span class="p">)</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">])</span>
                        <span class="p">)</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">])</span>
                        <span class="p">)</span>

            <span class="c1">#if use_apriori_picks and hasattr(self, &quot;arrival_times&quot;):</span>
            <span class="c1">#    columns = []</span>
            <span class="c1">#    if &quot;P&quot; in self.phases:</span>
            <span class="c1">#        columns.append(&quot;P&quot;)</span>
            <span class="c1">#    if &quot;S&quot; in self.phases:</span>
            <span class="c1">#        columns.append(&quot;S&quot;)</span>
            <span class="c1">#    prior_knowledge = pd.DataFrame(columns=columns)</span>
            <span class="c1">#    for sta in self.stations:</span>
            <span class="c1">#        for ph in prior_knowledge.columns:</span>
            <span class="c1">#            prior_knowledge.loc[sta, ph] = utils.sec_to_samp(</span>
            <span class="c1">#                udt(self.arrival_times.loc[sta, f&quot;{ph}_abs_arrival_times&quot;])</span>
            <span class="c1">#                - self.origin_time,</span>
            <span class="c1">#                sr=self.sampling_rate,</span>
            <span class="c1">#            )</span>
            <span class="c1">#else:</span>
            <span class="c1">#    prior_knowledge = None</span>
            <span class="c1">## only used if use_apriori_picks is True</span>
            <span class="c1">#search_win_samp = utils.sec_to_samp(search_win_sec, sr=self.sampling_rate)</span>
            <span class="c1">## keep best P- and S-wave pick on each 3-comp seismogram</span>
            <span class="c1">#picks = utils.get_picks(</span>
            <span class="c1">#    picks,</span>
            <span class="c1">#    prior_knowledge=prior_knowledge,</span>
            <span class="c1">#    search_win_samp=search_win_samp,</span>
            <span class="c1">#)</span>

            <span class="c1"># format picks in pandas DataFrame</span>
            <span class="n">pandas_picks</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">]:</span>
                <span class="n">rel_picks_sec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
                <span class="n">proba_picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
                <span class="n">abs_picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stations</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_picks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">rel_picks_sec</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_picks&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sr</span>
                        <span class="n">proba_picks</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_proba&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">])</span>
                        <span class="n">abs_picks</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
                                <span class="o">+</span>
                                <span class="n">rel_pick</span><span class="p">,</span>
                                <span class="s2">&quot;ms&quot;</span>
                                <span class="p">)</span> <span class="k">for</span> <span class="n">rel_pick</span> <span class="ow">in</span> <span class="n">rel_picks_sec</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                        <span class="p">])</span>
                <span class="n">pandas_picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_picks_sec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_picks_sec</span>
                <span class="n">pandas_picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_probas&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">proba_picks</span>
                <span class="n">pandas_picks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">_abs_picks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_picks</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pandas_picks</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;stations&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1">#self.picks.replace(0.0, np.nan, inplace=True)</span>
            <span class="k">if</span> <span class="n">upsampling</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">downsampling</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># reset the sampling rate to initial value</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Stack</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">pick_PS_phases</span><span class="p">(</span>
                <span class="n">duration</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="n">threshold_P</span><span class="o">=</span><span class="n">threshold_P</span><span class="p">,</span>
                <span class="n">threshold_S</span><span class="o">=</span><span class="n">threshold_S</span><span class="p">,</span>
                <span class="n">read_waveforms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span></div></div>


<span class="c1"># -------------------------------------------------</span>
<span class="c1"># old classes that will disappear in the future</span>

<span class="c1"># class Stack(object):</span>
<span class="c1">#    &quot;&quot;&quot;A class for stacked waveforms.</span>
<span class="c1">#</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#    def __init__(self,</span>
<span class="c1">#                 stations,</span>
<span class="c1">#                 components,</span>
<span class="c1">#                 tid=None,</span>
<span class="c1">#                 sampling_rate=cfg.SAMPLING_RATE_HZ):</span>
<span class="c1">#</span>
<span class="c1">#        self.stations = stations</span>
<span class="c1">#        self.components = components</span>
<span class="c1">#        self.sampling_rate = sampling_rate</span>
<span class="c1">#        if isinstance(self.stations, str):</span>
<span class="c1">#            self.stations = [self.stations]</span>
<span class="c1">#        if isinstance(self.components, str):</span>
<span class="c1">#            self.components = [self.components]</span>
<span class="c1">#        if not isinstance(self.stations, list):</span>
<span class="c1">#            self.stations = list(self.stations)</span>
<span class="c1">#        if not isinstance(self.components, list):</span>
<span class="c1">#            self.components = list(self.components)</span>
<span class="c1">#        if tid is not None:</span>
<span class="c1">#            self.template_idx = tid</span>
<span class="c1">#</span>
<span class="c1">#    def add_data(self, waveforms):</span>
<span class="c1">#</span>
<span class="c1">#        self.waveforms = waveforms</span>
<span class="c1">#        self.traces = obs.Stream()</span>
<span class="c1">#        for s, sta in enumerate(self.stations):</span>
<span class="c1">#            for c, cp in enumerate(self.components):</span>
<span class="c1">#                tr = obs.Trace()</span>
<span class="c1">#                tr.data = self.waveforms[s, c, :]</span>
<span class="c1">#                tr.stats.station = sta</span>
<span class="c1">#                # not really a channel, but the component</span>
<span class="c1">#                tr.stats.channel = cp</span>
<span class="c1">#                tr.stats.sampling_rate = self.sampling_rate</span>
<span class="c1">#                self.traces += tr</span>
<span class="c1">#</span>
<span class="c1">#    def SVDWF_stack(self, detection_waveforms, freqmin, freqmax,</span>
<span class="c1">#                    expl_var=0.4, max_singular_values=5,</span>
<span class="c1">#                    wiener_filter_colsize=None):</span>
<span class="c1">#        filtered_data = np.zeros_like(detection_waveforms)</span>
<span class="c1">#        for s in range(len(self.stations)):</span>
<span class="c1">#            for c in range(len(self.components)):</span>
<span class="c1">#                filtered_data[:, s, c, :] = utils.SVDWF(</span>
<span class="c1">#                        detection_waveforms[:, s, c, :],</span>
<span class="c1">#                        max_singular_values=max_singular_values,</span>
<span class="c1">#                        expl_var=expl_var,</span>
<span class="c1">#                        freqmin=freqmin,</span>
<span class="c1">#                        freqmax=freqmax,</span>
<span class="c1">#                        sampling_rate=self.sampling_rate,</span>
<span class="c1">#                        wiener_filter_colsize=wiener_filter_colsize)</span>
<span class="c1">#                if np.sum(filtered_data[:, s, c, :]) == 0:</span>
<span class="c1">#                    print(&#39;Problem with station {} ({:d}), component {} ({:d})&#39;.</span>
<span class="c1">#                            format(self.stations[s], s, self.components[c], c))</span>
<span class="c1">#        stacked_waveforms = np.mean(filtered_data, axis=0)</span>
<span class="c1">#        norm = np.max(stacked_waveforms, axis=-1)[..., np.newaxis]</span>
<span class="c1">#        norm[norm == 0.] = 1.</span>
<span class="c1">#        stacked_waveforms /= norm</span>
<span class="c1">#        self.add_data(stacked_waveforms)</span>
<span class="c1">#        self.data = filtered_data</span>
<span class="c1">#</span>
<span class="c1">#    def read_data(self,</span>
<span class="c1">#                  filename,</span>
<span class="c1">#                  db_path_S,</span>
<span class="c1">#                  db_path=cfg.INPUT_PATH):</span>
<span class="c1">#</span>
<span class="c1">#        with h5.File(os.path.join(db_path, db_path_S,</span>
<span class="c1">#            &#39;{}meta.h5&#39;.format(filename)), mode=&#39;r&#39;) as f:</span>
<span class="c1">#            file_stations = f[&#39;stations&#39;][()].astype(&#39;U&#39;).tolist()</span>
<span class="c1">#            file_components = f[&#39;components&#39;][()].astype(&#39;U&#39;).tolist()</span>
<span class="c1">#        with h5.File(os.path.join(db_path, db_path_S,</span>
<span class="c1">#            &#39;{}wav.h5&#39;.format(filename)), mode=&#39;r&#39;) as f:</span>
<span class="c1">#            file_waveforms = f[&#39;waveforms&#39;][()]</span>
<span class="c1">#        station_map = []</span>
<span class="c1">#        for s in range(len(self.stations)):</span>
<span class="c1">#            station_map.append(file_stations.index(self.stations[s]))</span>
<span class="c1">#        component_map = []</span>
<span class="c1">#        for c in range(len(self.components)):</span>
<span class="c1">#            component_map.append(file_components.index(self.components[c]))</span>
<span class="c1">#        station_map = np.int32(station_map)</span>
<span class="c1">#        component_map = np.int32(component_map)</span>
<span class="c1">#        self.waveforms = file_waveforms[station_map, :, :][:, component_map, :]</span>
<span class="c1">#        self.traces = obs.Stream()</span>
<span class="c1">#        for s, sta in enumerate(self.stations):</span>
<span class="c1">#            for c, cp in enumerate(self.components):</span>
<span class="c1">#                tr = obs.Trace()</span>
<span class="c1">#                tr.data = self.waveforms[s, c, :]</span>
<span class="c1">#                tr.stats.station = sta</span>
<span class="c1">#                # not really a channel, but the component</span>
<span class="c1">#                tr.stats.channel = cp</span>
<span class="c1">#                tr.stats.sampling_rate = self.sampling_rate</span>
<span class="c1">#                self.traces += tr</span>

<span class="c1"># class FamilyCatalog(object):</span>
<span class="c1">#</span>
<span class="c1">#    def __init__(self, filename, db_path_M, db_path=cfg.INPUT_PATH):</span>
<span class="c1">#        self.filename = filename</span>
<span class="c1">#        self.db_path_M = db_path_M</span>
<span class="c1">#        self.db_path = db_path</span>
<span class="c1">#        self.full_filename = os.path.join(</span>
<span class="c1">#                db_path, db_path_M, filename)</span>
<span class="c1">#</span>
<span class="c1">#    def read_data(self, items_in=[], items_out=[]):</span>
<span class="c1">#        &quot;&quot;&quot;Attach the requested attributes to the FamilyCatalog instance.</span>
<span class="c1">#</span>
<span class="c1">#        Parameters</span>
<span class="c1">#        -----------</span>
<span class="c1">#        items_in: list of strings, default to an empty list</span>
<span class="c1">#            List of items to read from the catalog file.</span>
<span class="c1">#            If an empty list is provided, then all items are read.</span>
<span class="c1">#        items_out: list of strings, default to an empty list</span>
<span class="c1">#            List of items to reject when reading from the catalog file.</span>
<span class="c1">#            If an empty list is provided, no items are discarded.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if not isinstance(items_in, list):</span>
<span class="c1">#            items_in = [items_in]</span>
<span class="c1">#        if not isinstance(items_out, list):</span>
<span class="c1">#            items_out = [items_out]</span>
<span class="c1">#        # attach &#39;template_idx&#39; as a default item</span>
<span class="c1">#        items_in = list(set(items_in+[&#39;template_idx&#39;]))</span>
<span class="c1">#        with h5.File(self.full_filename, mode=&#39;r&#39;) as f:</span>
<span class="c1">#            for key in f.keys():</span>
<span class="c1">#                if key in items_out:</span>
<span class="c1">#                    continue</span>
<span class="c1">#                elif (key in items_in) or len(items_in) == 1:</span>
<span class="c1">#                    setattr(self, key, f[key][()])</span>
<span class="c1">#        # temporary:</span>
<span class="c1">#        if hasattr(self, &#39;location&#39;):</span>
<span class="c1">#            self.latitude, self.longitude, self.depth =\</span>
<span class="c1">#                    self.location</span>
<span class="c1">#        # alias</span>
<span class="c1">#        self.tid = self.template_idx</span>
<span class="c1">#</span>
<span class="c1">#    def flatten_catalog(self, attributes=[], unique_event=False):</span>
<span class="c1">#        &quot;&quot;&quot;Output a catalog with one row for each requested attribute.</span>
<span class="c1">#</span>
<span class="c1">#        Parameters</span>
<span class="c1">#        -----------</span>
<span class="c1">#        attributes: list of strings, default to an empty list</span>
<span class="c1">#            List of all the attributes, in addition to origin_times</span>
<span class="c1">#            and tids, that will be included in the flat catalog.</span>
<span class="c1">#        unique_event: boolean, default to False</span>
<span class="c1">#            If True, only returns the events flagged as unique.</span>
<span class="c1">#</span>
<span class="c1">#        Returns</span>
<span class="c1">#        ------------</span>
<span class="c1">#        flat_catalog: dictionary</span>
<span class="c1">#            Dictionary with one entry for each requested attribute.</span>
<span class="c1">#            Each entry contains an array of size n_events.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if not hasattr(self, &#39;origin_times&#39;):</span>
<span class="c1">#            print(&#39;FamilyCatalog needs to have the origin_times attribute &#39;</span>
<span class="c1">#                  &#39;to return a flat catalog.&#39;)</span>
<span class="c1">#            return</span>
<span class="c1">#        n_events = len(self.origin_times)</span>
<span class="c1">#        flat_catalog = {}</span>
<span class="c1">#        flat_catalog[&#39;origin_times&#39;] = np.asarray(self.origin_times)</span>
<span class="c1">#        flat_catalog[&#39;tids&#39;] = np.ones(n_events, dtype=np.int32)*self.tid</span>
<span class="c1">#        for attr in attributes:</span>
<span class="c1">#            if not hasattr(self, attr):</span>
<span class="c1">#                print(f&#39;FamilyCatalog does not have {attr}&#39;)</span>
<span class="c1">#                continue</span>
<span class="c1">#            attr_ = getattr(self, attr)</span>
<span class="c1">#            if not isinstance(attr_, list)\</span>
<span class="c1">#                    and not isinstance(attr_, np.ndarray):</span>
<span class="c1">#                flat_catalog[attr] = \</span>
<span class="c1">#                        np.ones(n_events, dtype=np.dtype(type(attr_)))*attr_</span>
<span class="c1">#            else:</span>
<span class="c1">#                #flat_catalog[attr] = np.asarray(attr_)[selection]</span>
<span class="c1">#                flat_catalog[attr] = np.asarray(attr_)</span>
<span class="c1">#                if flat_catalog[attr].shape[0] != n_events:</span>
<span class="c1">#                    # this condition should work for spotting</span>
<span class="c1">#                    # list-like attributes that are not of the</span>
<span class="c1">#                    # shape (n_events, n_attr)</span>
<span class="c1">#                    flat_catalog[attr] = np.repeat(flat_catalog[attr], n_events).\</span>
<span class="c1">#                            reshape((n_events,)+flat_catalog[attr].shape)</span>
<span class="c1">#                else:</span>
<span class="c1">#                    flat_catalog[attr] = flat_catalog[attr]</span>
<span class="c1">#        if unique_event:</span>
<span class="c1">#            selection = self.unique_event</span>
<span class="c1">#            for attr in flat_catalog.keys():</span>
<span class="c1">#                flat_catalog[attr] = flat_catalog[attr][selection]</span>
<span class="c1">#        return flat_catalog</span>
<span class="c1">#</span>
<span class="c1">#    def return_as_dic(self, attributes=[]):</span>
<span class="c1">#        catalog = {}</span>
<span class="c1">#        for attr in attributes:</span>
<span class="c1">#            if hasattr(self, attr):</span>
<span class="c1">#                catalog[attr] = getattr(self, attr)</span>
<span class="c1">#            else:</span>
<span class="c1">#                print(f&#39;Template {self.tid} catalog has no attribute {attr}&#39;)</span>
<span class="c1">#        return catalog</span>
<span class="c1">#</span>
<span class="c1"># class FamilyGroupCatalog(object):</span>
<span class="c1">#</span>
<span class="c1">#    def __init__(self, families=None, filenames=None,</span>
<span class="c1">#                 db_path_M=None, db_path=cfg.INPUT_PATH):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Must either provide families (list of instances of Family),</span>
<span class="c1">#        or list of filenames.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if families is not None:</span>
<span class="c1">#            # index the single-template families by their tid</span>
<span class="c1">#            # in a dictionary</span>
<span class="c1">#            if isinstance(catalog.template_idx, np.ndarray):</span>
<span class="c1">#                self.families = {catalog.template_idx[0]: catalog</span>
<span class="c1">#                                 for catalog in families}</span>
<span class="c1">#            else:</span>
<span class="c1">#                self.families = {catalog.template_idx: catalog</span>
<span class="c1">#                                 for catalog in families}</span>
<span class="c1">#            self.tids = list(self.families.keys())</span>
<span class="c1">#        else:</span>
<span class="c1">#            self.db_path = db_path</span>
<span class="c1">#            self.db_path_M = db_path_M</span>
<span class="c1">#            self.filenames = filenames</span>
<span class="c1">#</span>
<span class="c1">#    def add_recurrence_times(self):</span>
<span class="c1">#        for tid in self.tids:</span>
<span class="c1">#            self.families[tid].recurrence_times =\</span>
<span class="c1">#                    np.hstack(([np.nan], np.diff(self.families[tid].origin_times)))</span>
<span class="c1">#</span>
<span class="c1">#    def read_data(self, items_in=[], items_out=[]):</span>
<span class="c1">#        &quot;&quot;&quot;Attach the requested attributes to the Family instances.</span>
<span class="c1">#</span>
<span class="c1">#        Parameters</span>
<span class="c1">#        -----------</span>
<span class="c1">#        items_in: list of strings, default to an empty list</span>
<span class="c1">#            List of items to read from the catalog file.</span>
<span class="c1">#            If an empty list is provided, then all items are read.</span>
<span class="c1">#        items_out: list of strings, default to an empty list</span>
<span class="c1">#            List of items to reject when reading from the catalog file.</span>
<span class="c1">#            If an empty list is provided, no items are discarded.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if not isinstance(items_in, list):</span>
<span class="c1">#            items_in = [items_in]</span>
<span class="c1">#        if not isinstance(items_out, list):</span>
<span class="c1">#            items_out = [items_out]</span>
<span class="c1">#        # initialize the dictionary of Family instances</span>
<span class="c1">#        self.families = {}</span>
<span class="c1">#        for filename in self.filenames:</span>
<span class="c1">#            # initialize a Family instance</span>
<span class="c1">#            catalog = Family(filename, self.db_path_M, db_path=self.db_path)</span>
<span class="c1">#            # attach the requested attributes</span>
<span class="c1">#            catalog.read_data(items_in=items_in, items_out=items_out)</span>
<span class="c1">#            # fill the dictionary</span>
<span class="c1">#            if isinstance(catalog.template_idx, np.ndarray):</span>
<span class="c1">#                self.families[catalog.template_idx[0]] = catalog</span>
<span class="c1">#            else:</span>
<span class="c1">#                self.families[catalog.template_idx] = catalog</span>
<span class="c1">#        self.tids = list(self.families.keys())</span>
<span class="c1">#</span>
<span class="c1">#    def flatten_catalog(self, attributes=[], chronological_order=True,</span>
<span class="c1">#                        unique_event=False):</span>
<span class="c1">#        flat_catalogs = [self.families[tid].flatten_catalog(</span>
<span class="c1">#            attributes=attributes, unique_event=unique_event)</span>
<span class="c1">#            for tid in self.tids]</span>
<span class="c1">#        flat_agg_catalog = {}</span>
<span class="c1">#        for attr in flat_catalogs[0].keys():</span>
<span class="c1">#            flat_agg_catalog[attr] = \</span>
<span class="c1">#                    np.concatenate(</span>
<span class="c1">#                            [flat_cat[attr] for flat_cat in flat_catalogs],</span>
<span class="c1">#                             axis=0)</span>
<span class="c1">#        if chronological_order:</span>
<span class="c1">#            order = np.argsort(flat_agg_catalog[&#39;origin_times&#39;])</span>
<span class="c1">#            for attr in flat_agg_catalog.keys():</span>
<span class="c1">#                flat_agg_catalog[attr] = flat_agg_catalog[attr][order]</span>
<span class="c1">#        return flat_agg_catalog</span>
<span class="c1">#</span>
<span class="c1">#    def remove_multiples(self, db_path_T, n_closest_stations=10,</span>
<span class="c1">#                         dt_criterion=3., distance_criterion=1.,</span>
<span class="c1">#                         similarity_criterion=-1., return_catalog=False):</span>
<span class="c1">#        &quot;&quot;&quot;Search for events detected by multiple templates.</span>
<span class="c1">#</span>
<span class="c1">#        Parameters</span>
<span class="c1">#        -----------</span>
<span class="c1">#        db_path_T: string</span>
<span class="c1">#            Name of the directory where template files are stored.</span>
<span class="c1">#        n_closest_stations: integer, default to 10</span>
<span class="c1">#            In case template similarity is taken into account,</span>
<span class="c1">#            this is the number of stations closest to each template</span>
<span class="c1">#            that are used in the calculation of the average cc.</span>
<span class="c1">#        dt_criterion: float, default to 3</span>
<span class="c1">#            Time interval, in seconds, under which two events are</span>
<span class="c1">#            examined for redundancy.</span>
<span class="c1">#        distance_criterion: float, default to 1</span>
<span class="c1">#            Distance threshold, in kilometers, between two uncertainty</span>
<span class="c1">#            ellipsoids under which two events are examined for redundancy.</span>
<span class="c1">#        similarity_criterion: float, default to -1</span>
<span class="c1">#            Template similarity threshold, in terms of average CC, over</span>
<span class="c1">#            which two events are examined for redundancy. The default</span>
<span class="c1">#            value of -1 is always verified, meaning that similarity is</span>
<span class="c1">#            actually not taken into account.</span>
<span class="c1">#        return_catalog: boolean, default to False</span>
<span class="c1">#            If True, returns a flatten catalog.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        self.db_path_T = db_path_T</span>
<span class="c1">#        catalog = self.flatten_catalog(</span>
<span class="c1">#                attributes=[&#39;latitude&#39;, &#39;longitude&#39;, &#39;depth&#39;,</span>
<span class="c1">#                            &#39;correlation_coefficients&#39;])</span>
<span class="c1">#        # define an alias for tids</span>
<span class="c1">#        catalog[&#39;template_ids&#39;] = catalog[&#39;tids&#39;]</span>
<span class="c1">#        self.TpGroup = TemplateGroup(self.tids, db_path_T)</span>
<span class="c1">#        self.TpGroup.attach_ellipsoid_distances(substract_errors=True)</span>
<span class="c1">#        if similarity_criterion &gt; -1.:</span>
<span class="c1">#            self.TpGroup.template_similarity(distance_threshold=distance_criterion,</span>
<span class="c1">#                                             n_stations=n_closest_stations)</span>
<span class="c1">#        # -----------------------------------</span>
<span class="c1">#        t1 = give_time()</span>
<span class="c1">#        print(&#39;Searching for events detected by multiple templates&#39;)</span>
<span class="c1">#        print(&#39;All events occurring within {:.1f} sec, with uncertainty &#39;</span>
<span class="c1">#              &#39;ellipsoids closer than {:.1f} km will and &#39;</span>
<span class="c1">#              &#39;inter-template CC larger than {:.2f} be considered the same&#39;.</span>
<span class="c1">#              format(dt_criterion, distance_criterion, similarity_criterion))</span>
<span class="c1">#        n_events = len(catalog[&#39;origin_times&#39;])</span>
<span class="c1">#        unique_event = np.ones(n_events, dtype=bool)</span>
<span class="c1">#        for n1 in range(n_events):</span>
<span class="c1">#            if not unique_event[n1]:</span>
<span class="c1">#                continue</span>
<span class="c1">#            tid1 = catalog[&#39;template_ids&#39;][n1]</span>
<span class="c1">#            # apply the time criterion</span>
<span class="c1">#            dt_n1 = (catalog[&#39;origin_times&#39;] - catalog[&#39;origin_times&#39;][n1])</span>
<span class="c1">#            temporal_neighbors = (dt_n1 &lt; dt_criterion) &amp; (dt_n1 &gt;= 0.)\</span>
<span class="c1">#                                &amp; unique_event</span>
<span class="c1">#            # comment this line if you keep best CC</span>
<span class="c1">#            #temporal_neighbors[n1] = False</span>
<span class="c1">#            # get indices of where the above selection is True</span>
<span class="c1">#            candidates = np.where(temporal_neighbors)[0]</span>
<span class="c1">#            if len(candidates) == 0:</span>
<span class="c1">#                continue</span>
<span class="c1">#            # get template ids of all events that passed the time criterion</span>
<span class="c1">#            tids_candidates = np.int32([catalog[&#39;template_ids&#39;][idx]</span>
<span class="c1">#                                       for idx in candidates])</span>
<span class="c1">#            # apply the spatial criterion to the distance between</span>
<span class="c1">#            # uncertainty ellipsoids</span>
<span class="c1">#            ellips_dist = self.TpGroup.ellipsoid_distances[tid1].\</span>
<span class="c1">#                    loc[tids_candidates].values</span>
<span class="c1">#            if similarity_criterion &gt; -1.:</span>
<span class="c1">#                similarities = self.TpGroup.intertp_cc[tid1].\</span>
<span class="c1">#                        loc[tids_candidates].values</span>
<span class="c1">#                multiples = candidates[np.where(</span>
<span class="c1">#                    (ellips_dist &lt; distance_criterion)\</span>
<span class="c1">#                   &amp; (similarities &gt;= similarity_criterion))[0]]</span>
<span class="c1">#            else:</span>
<span class="c1">#                multiples = candidates[np.where(</span>
<span class="c1">#                    ellips_dist &lt; distance_criterion)[0]]</span>
<span class="c1">#            # comment this line if you keep best CC</span>
<span class="c1">#            #if len(multiples) == 0:</span>
<span class="c1">#            #    continue</span>
<span class="c1">#            # uncomment if you keep best CC</span>
<span class="c1">#            if len(multiples) == 1:</span>
<span class="c1">#                continue</span>
<span class="c1">#            else:</span>
<span class="c1">#                unique_event[multiples] = False</span>
<span class="c1">#                # find best CC and keep it</span>
<span class="c1">#                ccs = catalog[&#39;correlation_coefficients&#39;][multiples]</span>
<span class="c1">#                best_cc = multiples[ccs.argmax()]</span>
<span class="c1">#                unique_event[best_cc] = True</span>
<span class="c1">#        t2 = give_time()</span>
<span class="c1">#        print(&#39;{:.2f}s to flag the multiples&#39;.format(t2-t1))</span>
<span class="c1">#        # -------------------------------------------</span>
<span class="c1">#        catalog[&#39;unique_event&#39;] = unique_event</span>
<span class="c1">#        for tid in self.tids:</span>
<span class="c1">#            selection = catalog[&#39;tids&#39;] == tid</span>
<span class="c1">#            unique_event_t = catalog[&#39;unique_event&#39;][selection]</span>
<span class="c1">#            self.families[tid].unique_event = unique_event_t</span>
<span class="c1">#        if return_catalog:</span>
<span class="c1">#            return catalog</span>
<span class="c1">#</span>
<span class="c1"># class FamilyEvents(object):</span>
<span class="c1">#</span>
<span class="c1">#    def __init__(self, tid, db_path_T, db_path_M, db_path=cfg.INPUT_PATH):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Initializes an FamilyEvents instance and attaches the</span>
<span class="c1">#        Template instance corresponding to this family.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        self.tid = tid</span>
<span class="c1">#        self.db_path_T = db_path_T</span>
<span class="c1">#        self.db_path_M = db_path_M</span>
<span class="c1">#        self.db_path = db_path</span>
<span class="c1">#        self.template = Template(f&#39;template{tid}&#39;, db_path_T, db_path=db_path)</span>
<span class="c1">#        self.template.read_waveforms()</span>
<span class="c1">#        self.sr = self.template.sampling_rate</span>
<span class="c1">#        self.stations = self.template.network_stations</span>
<span class="c1">#</span>
<span class="c1">#    def attach_catalog(self, items_in=[], items_out=[]):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Creates a Family instance and call Family.read_data()</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        filename = f&#39;multiplets{self.tid}catalog.h5&#39;</span>
<span class="c1">#        self.catalog = Family(filename, self.db_path_M, db_path=self.db_path)</span>
<span class="c1">#        self.catalog.read_data(items_in=items_in, items_out=items_out)</span>
<span class="c1">#</span>
<span class="c1">#    def check_template_reloc(self):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        If templates were relocated, overwrite the catalog&#39;s location</span>
<span class="c1">#        with the template&#39;s relocated hypocenter</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        for attr in [&#39;longitude&#39;, &#39;latitude&#39;, &#39;depth&#39;]:</span>
<span class="c1">#            if hasattr(self.template, &#39;relocated_&#39;+attr):</span>
<span class="c1">#                setattr(self.catalog, attr, getattr(self.template, &#39;relocated_&#39;+attr))</span>
<span class="c1">#</span>
<span class="c1">#    def find_closest_stations(self, n_stations, available_stations=None):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Here for consistency with FamilyGroupEvents and write the</span>
<span class="c1">#        cross_correlate method such that FamilyGroupEvents can inherit</span>
<span class="c1">#        from it.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        self.template.n_closest_stations(</span>
<span class="c1">#                n_stations, available_stations=available_stations)</span>
<span class="c1">#        self.stations = self.template.stations</span>
<span class="c1">#        self.map_to_subnet = self.template.map_to_subnet</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def dtt_P(self, max_corr=1000.):</span>
<span class="c1">#        &quot;&quot;&quot; Travel-time corrections to individual events.</span>
<span class="c1">#</span>
<span class="c1">#        Parameters</span>
<span class="c1">#        -----------</span>
<span class="c1">#        max_corr: float, default to 1000.</span>
<span class="c1">#            Maximum correction time, in seconds, below which</span>
<span class="c1">#            a correction time is considered to be valid.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if hasattr(self, &#39;_dtt_P&#39;):</span>
<span class="c1">#            _dtt_P = self._dtt_P</span>
<span class="c1">#        else:</span>
<span class="c1">#            print(&#39;Call `get_tt_corrections` first!&#39;)</span>
<span class="c1">#            return None</span>
<span class="c1">#        if hasattr(self, &#39;event_ids&#39;):</span>
<span class="c1">#            _dtt_P = _dtt_P[self.event_ids, :]</span>
<span class="c1">#        #if hasattr(self, &#39;map_to_subnet&#39;):</span>
<span class="c1">#        #    _dtt_P = _dtt_P[:, self.map_to_subnet]</span>
<span class="c1">#        return _dtt_P</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def dtt_S(self, max_corr=1000.):</span>
<span class="c1">#        &quot;&quot;&quot; Travel-time corrections to individual events.</span>
<span class="c1">#</span>
<span class="c1">#        Parameters</span>
<span class="c1">#        -----------</span>
<span class="c1">#        max_corr: float, default to 1000.</span>
<span class="c1">#            Maximum correction time, in seconds, below which</span>
<span class="c1">#            a correction time is considered to be valid.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if hasattr(self, &#39;_dtt_S&#39;):</span>
<span class="c1">#            _dtt_S = self._dtt_S</span>
<span class="c1">#        else:</span>
<span class="c1">#            print(&#39;Call `get_tt_corrections` first!&#39;)</span>
<span class="c1">#            return None</span>
<span class="c1">#        if hasattr(self, &#39;event_ids&#39;):</span>
<span class="c1">#            _dtt_S = _dtt_S[self.event_ids, :]</span>
<span class="c1">#        #if hasattr(self, &#39;map_to_subnet&#39;):</span>
<span class="c1">#        #    _dtt_S = _dtt_S[:, self.map_to_subnet]</span>
<span class="c1">#        return _dtt_S</span>
<span class="c1">#</span>
<span class="c1">#    def get_tt_corrections(self, max_corr=1000.):</span>
<span class="c1">#        &quot;&quot;&quot; Read travel-time corrections to individual events.</span>
<span class="c1">#</span>
<span class="c1">#        Parameters</span>
<span class="c1">#        -----------</span>
<span class="c1">#        max_corr: float, default to 1000.</span>
<span class="c1">#            Maximum correction time, in seconds, below which</span>
<span class="c1">#            a correction time is considered to be valid.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        cat_file = os.path.join(</span>
<span class="c1">#                            self.db_path, self.db_path_M,</span>
<span class="c1">#                            f&#39;multiplets{self.tid}catalog.h5&#39;)</span>
<span class="c1">#        with h5.File(cat_file, mode=&#39;r&#39;) as f:</span>
<span class="c1">#            if &#39;dtt_P&#39; in f:</span>
<span class="c1">#                self._dtt_P = f[&#39;dtt_P&#39;][()]</span>
<span class="c1">#                self._dtt_P[self._dtt_P &gt; max_corr] = 0.</span>
<span class="c1">#            else:</span>
<span class="c1">#                print(f&#39;No P-wave travel-time corrections found in {cat_file}.&#39;)</span>
<span class="c1">#                self._dtt_P = np.zeros(</span>
<span class="c1">#                        (len(self.event_ids), len(self.template.network_stations)),</span>
<span class="c1">#                        dtype=np.float32)</span>
<span class="c1">#            if &#39;dtt_S&#39; in f:</span>
<span class="c1">#                self._dtt_S = f[&#39;dtt_S&#39;][()]</span>
<span class="c1">#                self._dtt_S[self._dtt_S &gt; max_corr] = 0.</span>
<span class="c1">#            else:</span>
<span class="c1">#                print(f&#39;No S-wave travel-time corrections found in {cat_file}.&#39;)</span>
<span class="c1">#                self._dtt_S = np.zeros(</span>
<span class="c1">#                        (len(self.event_ids), len(self.template.network_stations)),</span>
<span class="c1">#                        dtype=np.float32)</span>
<span class="c1">#</span>
<span class="c1">#    def read_data(self, **kwargs):</span>
<span class="c1">#        &quot;&quot;&quot;Call &#39;fetch_detection_waveforms&#39; from utils.</span>
<span class="c1">#</span>
<span class="c1">#        Read waveforms from the event waveforms that were</span>
<span class="c1">#        extracted at the time of detection.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        # self.event_ids tell us in which order the events were read,</span>
<span class="c1">#        # which depends on the kwargs given to fetch_detection_waveforms</span>
<span class="c1">#        # force ordering to be chronological</span>
<span class="c1">#        kwargs[&#39;ordering&#39;] = &#39;origin_times&#39;</span>
<span class="c1">#        #kwargs[&#39;flip_order&#39;] = True # why did I do that?? This seems totally unnecessary</span>
<span class="c1">#        if (kwargs.get(&#39;unique_event&#39;, False)\</span>
<span class="c1">#                and np.sum(self.catalog.unique_event) == 0):</span>
<span class="c1">#            self.detection_waveforms = []</span>
<span class="c1">#            self.event_ids, self.event_ids_str = [], []</span>
<span class="c1">#            self.n_events = 0</span>
<span class="c1">#        else:</span>
<span class="c1">#            self.detection_waveforms, _, self.event_ids = \</span>
<span class="c1">#                    utils.fetch_detection_waveforms(</span>
<span class="c1">#                            self.tid, self.db_path_T, self.db_path_M,</span>
<span class="c1">#                            return_event_ids=True, **kwargs)</span>
<span class="c1">#            self.n_events = self.detection_waveforms.shape[0]</span>
<span class="c1">#            self.event_ids_str = [f&#39;{self.tid},{event_id}&#39; for event_id in self.event_ids]</span>
<span class="c1">#</span>
<span class="c1">#    def trim_waveforms(self, duration, offset_start_S, offset_start_P,</span>
<span class="c1">#                       t0=cfg.BUFFER_EXTRACTED_EVENTS_SEC,</span>
<span class="c1">#                       S_window_time=4., P_window_time=1., correct_tt=False):</span>
<span class="c1">#        &quot;&quot;&quot;Trim the waveforms using the P- and S-wave moveouts from the template.</span>
<span class="c1">#</span>
<span class="c1">#        Parameters</span>
<span class="c1">#        ------------</span>
<span class="c1">#        duration: scalar, float</span>
<span class="c1">#            Duration, in seconds, of the trimmed windows.</span>
<span class="c1">#        offset_start_S: scalar, float</span>
<span class="c1">#            Time, in seconds, taken BEFORE the S wave.</span>
<span class="c1">#        offset_start_P: scalar, float</span>
<span class="c1">#            Time, in seconds, taken BEFORE the P wave.</span>
<span class="c1">#        t0: float, optional</span>
<span class="c1">#            Time, in seconds, taken before the detection time</span>
<span class="c1">#            when the waveforms were extracted at the time</span>
<span class="c1">#            of detection. Default to the value written in</span>
<span class="c1">#            the parameter file.</span>
<span class="c1">#        S_window_time: scalar, float</span>
<span class="c1">#            Time between the beginning of the S-wave template</span>
<span class="c1">#            window and the predicted S-wave arrival time.</span>
<span class="c1">#        P_window_time: scalar, float</span>
<span class="c1">#            Time between the beginning of the P-wave template</span>
<span class="c1">#            widow and the predicted P-wave arrival time.</span>
<span class="c1">#        correct_tt: boolean, default to False</span>
<span class="c1">#            If True, use the individual phase picks -- if available -- to</span>
<span class="c1">#            adjust the template&#39;s travel times to individual events.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if not hasattr(self, &#39;detection_waveforms&#39;):</span>
<span class="c1">#            print(&#39;Need to call read_data first.&#39;)</span>
<span class="c1">#            return</span>
<span class="c1">#        if self.n_events == 0:</span>
<span class="c1">#            print(&#39;No events were read, probably because only &#39;</span>
<span class="c1">#                  &#39;unique events were requested.&#39;)</span>
<span class="c1">#            return</span>
<span class="c1">#        # convert all times from seconds to samples</span>
<span class="c1">#        duration = utils.sec_to_samp(duration, sr=self.sr)</span>
<span class="c1">#        offset_start_S = utils.sec_to_samp(offset_start_S, sr=self.sr)</span>
<span class="c1">#        offset_start_P = utils.sec_to_samp(offset_start_P, sr=self.sr)</span>
<span class="c1">#        S_window_time = utils.sec_to_samp(S_window_time, sr=self.sr)</span>
<span class="c1">#        P_window_time = utils.sec_to_samp(P_window_time, sr=self.sr)</span>
<span class="c1">#        t0 = utils.sec_to_samp(t0, sr=self.sr)</span>
<span class="c1">#        new_shape = self.detection_waveforms.shape[:-1] + (duration,)</span>
<span class="c1">#        self.trimmed_waveforms = np.zeros(new_shape, dtype=np.float32)</span>
<span class="c1">#        _, n_stations, _, n_samples = self.detection_waveforms.shape</span>
<span class="c1">#        if correct_tt:</span>
<span class="c1">#            self.get_tt_corrections(max_corr=5.)</span>
<span class="c1">#        for s in range(n_stations):</span>
<span class="c1">#            if not correct_tt:</span>
<span class="c1">#                # P-wave window on vertical components</span>
<span class="c1">#                P_start = t0 + self.template.network_p_moveouts[s] + P_window_time - offset_start_P</span>
<span class="c1">#                P_end = P_start + duration</span>
<span class="c1">#                if P_start &lt; n_samples:</span>
<span class="c1">#                    P_end = min(n_samples, P_end)</span>
<span class="c1">#                    self.trimmed_waveforms[:, s, 2, :P_end-P_start] = \</span>
<span class="c1">#                            self.detection_waveforms[:, s, 2, P_start:P_end]</span>
<span class="c1">#                # S-wave window on horizontal components</span>
<span class="c1">#                S_start = t0 + self.template.network_s_moveouts[s] + S_window_time - offset_start_S</span>
<span class="c1">#                S_end = S_start + duration</span>
<span class="c1">#                if S_start &lt; n_samples:</span>
<span class="c1">#                    S_end = min(n_samples, S_end)</span>
<span class="c1">#                    self.trimmed_waveforms[:, s, :2, :S_end-S_start] = \</span>
<span class="c1">#                            self.detection_waveforms[:, s, :2, S_start:S_end]</span>
<span class="c1">#            else:</span>
<span class="c1">#                for n in range(self.n_events):</span>
<span class="c1">#                    # P-wave window on vertical components</span>
<span class="c1">#                    P_start = t0 + self.template.network_p_moveouts[s]\</span>
<span class="c1">#                            + P_window_time - offset_start_P\</span>
<span class="c1">#                            + utils.sec_to_samp(self.dtt_P[n, s], sr=self.sr)</span>
<span class="c1">#                    P_end = P_start + duration</span>
<span class="c1">#                    if P_start &lt; n_samples:</span>
<span class="c1">#                        P_end = min(n_samples, P_end)</span>
<span class="c1">#                        self.trimmed_waveforms[n, s, 2, :P_end-P_start] = \</span>
<span class="c1">#                                self.detection_waveforms[n, s, 2, P_start:P_end]</span>
<span class="c1">#                    # S-wave window on horizontal components</span>
<span class="c1">#                    S_start = t0 + self.template.network_s_moveouts[s]\</span>
<span class="c1">#                            + S_window_time - offset_start_S\</span>
<span class="c1">#                            + utils.sec_to_samp(self.dtt_S[n, s], sr=self.sr)</span>
<span class="c1">#                    S_end = S_start + duration</span>
<span class="c1">#                    if S_start &lt; n_samples:</span>
<span class="c1">#                        S_end = min(n_samples, S_end)</span>
<span class="c1">#                        self.trimmed_waveforms[n, s, :2, :S_end-S_start] = \</span>
<span class="c1">#                                self.detection_waveforms[n, s, :2, S_start:S_end]</span>
<span class="c1">#</span>
<span class="c1">#    def read_trimmed_waveforms(self, duration, offset_start, net, target_SR,</span>
<span class="c1">#                               tt_phases=[&#39;S&#39;, &#39;S&#39;, &#39;P&#39;], norm_rms=True,</span>
<span class="c1">#                               buffer=2., unique_event=False, correct_tt=False,</span>
<span class="c1">#                               selection=None, **preprocess_kwargs):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Read waveforms from raw data and refilter/resample. Extra key-word</span>
<span class="c1">#        arguments will be passed to the preprocessing routine.</span>
<span class="c1">#</span>
<span class="c1">#        Parameters</span>
<span class="c1">#        ------------</span>
<span class="c1">#        duration: float</span>
<span class="c1">#            Duration, in seconds, of the extracted time windows.</span>
<span class="c1">#        offset_start: float</span>
<span class="c1">#            Time, in seconds, added to the requested time to define</span>
<span class="c1">#            the beginning of the time window. It should be negative if</span>
<span class="c1">#            the goal is to make the window start before the target phase.</span>
<span class="c1">#        net: `Network` object</span>
<span class="c1">#            `Network` instance.</span>
<span class="c1">#        tt_phases: list of strings, default to [&#39;S&#39;, &#39;S&#39;, &#39;P&#39;]</span>
<span class="c1">#            Determine which phase is targetted on each component.</span>
<span class="c1">#        buffer: float, default to 2</span>
<span class="c1">#            Time, in seconds, taken at the beginning and end of the window.</span>
<span class="c1">#            It is used to make sure the preprocessing does not alter the</span>
<span class="c1">#            actual window.</span>
<span class="c1">#        unique_event: boolean, default to False</span>
<span class="c1">#            If True, only loads the unique detections.</span>
<span class="c1">#        correct_tt: boolean, default to False</span>
<span class="c1">#            If True, use the individual phase picks -- if available -- to</span>
<span class="c1">#            adjust the template&#39;s travel times to individual events.</span>
<span class="c1">#        selection: numpy array, default to None</span>
<span class="c1">#            Indexes of the events to use.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        from . import event_extraction</span>
<span class="c1">#        if not hasattr(self, &#39;catalog&#39;):</span>
<span class="c1">#            self.attach_catalog()</span>
<span class="c1">#        preprocess_kwargs[&#39;target_SR&#39;] = target_SR</span>
<span class="c1">#        detection_waveforms  = []</span>
<span class="c1">#        # reshape travel times</span>
<span class="c1">#        station_indexes = np.int32([self.template.network_stations.tolist().index(sta)</span>
<span class="c1">#                for sta in net.stations])</span>
<span class="c1">#        # use travel times according to requested phase on each channel</span>
<span class="c1">#        phase_index = {&#39;S&#39;: 1, &#39;P&#39;: 0}</span>
<span class="c1">#        tts = np.stack([self.template.network_travel_times\</span>
<span class="c1">#                [station_indexes, phase_index[tt_phases[c]]]</span>
<span class="c1">#            for c in range(len(tt_phases))], axis=1)</span>
<span class="c1">#        if selection is None:</span>
<span class="c1">#            if unique_event:</span>
<span class="c1">#                selection = self.catalog.unique_event</span>
<span class="c1">#            else:</span>
<span class="c1">#                selection = np.ones(len(self.catalog.origin_times), dtype=bool)</span>
<span class="c1">#        self.event_ids = np.arange(len(selection), dtype=np.int32)[selection]</span>
<span class="c1">#        if correct_tt:</span>
<span class="c1">#            self.get_tt_corrections(max_corr=5.)</span>
<span class="c1">#        print(f&#39;Reading {np.sum(selection)} events...&#39;)</span>
<span class="c1">#        for n, evidx in enumerate(self.event_ids):</span>
<span class="c1">#            ot = self.catalog.origin_times[evidx]</span>
<span class="c1">#            if correct_tt:</span>
<span class="c1">#                tt_corrections = np.stack(</span>
<span class="c1">#                        [getattr(self, f&#39;dtt_{ph}&#39;)[n, station_indexes] for ph in tt_phases], axis=1)</span>
<span class="c1">#            else:</span>
<span class="c1">#                tt_corrections = np.zeros_like(tts, dtype=np.float32)</span>
<span class="c1">#            event = event_extraction.extract_event_realigned(</span>
<span class="c1">#                    ot, net, tts+tt_corrections, duration=duration+2.*buffer,</span>
<span class="c1">#                    offset_start=offset_start-buffer, folder=&#39;raw&#39;)</span>
<span class="c1">#            event = event_extraction.preprocess_event(</span>
<span class="c1">#                    event, target_duration=duration+2.*buffer,</span>
<span class="c1">#                    **preprocess_kwargs)</span>
<span class="c1">#            if len(event) &gt; 0:</span>
<span class="c1">#                detection_waveforms.append(utils.get_np_array(</span>
<span class="c1">#                    event, net.stations, components=net.components, verbose=False))</span>
<span class="c1">#            else:</span>
<span class="c1">#                detection_waveforms.append(np.zeros(</span>
<span class="c1">#                    len(net.stations), len(net.components),</span>
<span class="c1">#                    utils.sec_to_samp(target_duration, sr=target_SR),</span>
<span class="c1">#                    dtype=np.float32))</span>
<span class="c1">#        detection_waveforms = np.stack(detection_waveforms, axis=0)</span>
<span class="c1">#        if norm_rms:</span>
<span class="c1">#            # one normalization factor for each 3-comp seismogram</span>
<span class="c1">#            norm = np.std(detection_waveforms, axis=(2, 3))[..., np.newaxis, np.newaxis]</span>
<span class="c1">#            norm[norm == 0.] = 1.</span>
<span class="c1">#            detection_waveforms /= norm</span>
<span class="c1">#        # trim the waveforms</span>
<span class="c1">#        buffer = utils.sec_to_samp(buffer, sr=target_SR)</span>
<span class="c1">#        self.trimmed_waveforms = detection_waveforms[..., buffer:-buffer]</span>
<span class="c1">#        # update SR</span>
<span class="c1">#        self.sr = target_SR</span>
<span class="c1">#        # add metadata</span>
<span class="c1">#        self.n_events = self.trimmed_waveforms.shape[0]</span>
<span class="c1">#        self.event_ids_str = [f&#39;{self.tid},{event_id}&#39; for event_id in self.event_ids]</span>
<span class="c1">#</span>
<span class="c1">#    def read_trimmed_waveforms_raw(</span>
<span class="c1">#            self, duration, offset_start, net,</span>
<span class="c1">#            tt_phases=[&#39;S&#39;, &#39;S&#39;, &#39;P&#39;],</span>
<span class="c1">#            buffer=2., unique_event=False, correct_tt=False,</span>
<span class="c1">#            selection=None, **preprocess_kwargs):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Read waveforms from raw data and remove instrument response if requested.</span>
<span class="c1">#        Extra key-word arguments will be passed to the preprocessing routine.</span>
<span class="c1">#        This should not be used to resample all traces to the same sampling</span>
<span class="c1">#        rate, instead use `read_trimmed_waveforms`.</span>
<span class="c1">#</span>
<span class="c1">#        Parameters</span>
<span class="c1">#        ------------</span>
<span class="c1">#        duration: float</span>
<span class="c1">#            Duration, in seconds, of the extracted time windows.</span>
<span class="c1">#        offset_start: float</span>
<span class="c1">#            Time, in seconds, added to the requested time to define</span>
<span class="c1">#            the beginning of the time window. It should be negative if</span>
<span class="c1">#            the goal is to make the window start before the target phase.</span>
<span class="c1">#        net: `Network` object</span>
<span class="c1">#            `Network` instance.</span>
<span class="c1">#        tt_phases: list of strings, default to [&#39;S&#39;, &#39;S&#39;, &#39;P&#39;]</span>
<span class="c1">#            Determine which phase is targetted on each component.</span>
<span class="c1">#        buffer: float, default to 2</span>
<span class="c1">#            Time, in seconds, taken at the beginning and end of the window.</span>
<span class="c1">#            It is used to make sure the preprocessing does not alter the</span>
<span class="c1">#            actual window.</span>
<span class="c1">#        unique_event: boolean, default to False</span>
<span class="c1">#            If True, only loads the unique detections.</span>
<span class="c1">#        correct_tt: boolean, default to False</span>
<span class="c1">#            If True, use the individual phase picks -- if available -- to</span>
<span class="c1">#            adjust the template&#39;s travel times to individual events.</span>
<span class="c1">#        selection: numpy array, default to None</span>
<span class="c1">#            Indexes of the events to use.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        from . import event_extraction</span>
<span class="c1">#        if not hasattr(self, &#39;catalog&#39;):</span>
<span class="c1">#            self.attach_catalog()</span>
<span class="c1">#        detection_waveforms  = []</span>
<span class="c1">#        # reshape travel times</span>
<span class="c1">#        station_indexes = np.int32([self.template.network_stations.tolist().index(sta)</span>
<span class="c1">#                for sta in net.stations])</span>
<span class="c1">#        # use travel times according to requested phase on each channel</span>
<span class="c1">#        phase_index = {&#39;S&#39;: 1, &#39;P&#39;: 0}</span>
<span class="c1">#        tts = np.stack([self.template.network_travel_times\</span>
<span class="c1">#                [station_indexes, phase_index[tt_phases[c]]]</span>
<span class="c1">#            for c in range(len(tt_phases))], axis=1)</span>
<span class="c1">#        if selection is None:</span>
<span class="c1">#            if unique_event:</span>
<span class="c1">#                selection = self.catalog.unique_event</span>
<span class="c1">#            else:</span>
<span class="c1">#                selection = np.ones(len(self.catalog.origin_times), dtype=bool)</span>
<span class="c1">#        self.event_ids = np.arange(len(selection), dtype=np.int32)[selection]</span>
<span class="c1">#        if correct_tt:</span>
<span class="c1">#            self.get_tt_corrections(max_corr=5.)</span>
<span class="c1">#        events = []</span>
<span class="c1">#        for n, evidx in enumerate(self.event_ids):</span>
<span class="c1">#            ot = self.catalog.origin_times[evidx]</span>
<span class="c1">#            if correct_tt:</span>
<span class="c1">#                tt_corrections = np.stack(</span>
<span class="c1">#                        [getattr(self, f&#39;dtt_{ph}&#39;)[n, station_indexes] for ph in tt_phases], axis=1)</span>
<span class="c1">#            else:</span>
<span class="c1">#                tt_corrections = np.zeros_like(tts, dtype=np.float32)</span>
<span class="c1">#            event = event_extraction.extract_event_realigned(</span>
<span class="c1">#                    ot, net, tts+tt_corrections, duration=duration+2.*buffer,</span>
<span class="c1">#                    offset_start=offset_start-buffer, folder=&#39;raw&#39;,</span>
<span class="c1">#                    attach_response=True)</span>
<span class="c1">#            event = event_extraction.preprocess_event(</span>
<span class="c1">#                    event, target_duration=duration+2.*buffer,</span>
<span class="c1">#                    **preprocess_kwargs)</span>
<span class="c1">#            # now that the preprocessing is done, remove the sides</span>
<span class="c1">#            for tr in event:</span>
<span class="c1">#                tr.trim(starttime=tr.stats.starttime+buffer,</span>
<span class="c1">#                        endtime=tr.stats.endtime-buffer)</span>
<span class="c1">#            events.append(event)</span>
<span class="c1">#        self.trimmed_events = events</span>
<span class="c1">#        # add metadata</span>
<span class="c1">#        self.n_events = len(events)</span>
<span class="c1">#        self.event_ids_str = [f&#39;{self.tid},{event_id}&#39; for event_id in self.event_ids]</span>
<span class="c1">#        if self.n_events != np.sum(selection):</span>
<span class="c1">#            print(&#39;Number of extracted events does not match &#39;</span>
<span class="c1">#                  f&#39;expected number ({self.n_events} vs {np.sum(selection)}).&#39;)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    def cross_correlate(self, n_stations=40, max_lag=10,</span>
<span class="c1">#                        paired=None, device=&#39;cpu&#39;, available_stations=None):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Parameters</span>
<span class="c1">#        -----------</span>
<span class="c1">#        n_stations: integer, default to 40</span>
<span class="c1">#            The number of stations closest to each template used in</span>
<span class="c1">#            the computation of the average CC.</span>
<span class="c1">#        max_lag: integer, default to 10</span>
<span class="c1">#            Maximum lag, in samples, allowed when searching for the</span>
<span class="c1">#            maximum CC on each channel. This is to account for small</span>
<span class="c1">#            discrepancies in windowing that could occur for two templates</span>
<span class="c1">#            highly similar but associated to slightly different locations.</span>
<span class="c1">#        paired: (n_events, n_events) boolean array, default to None</span>
<span class="c1">#            If not None, this array is used to determine for which</span>
<span class="c1">#            events the CC should be computed. This is mostly useful</span>
<span class="c1">#            when cross correlating large data sets, with potentially</span>
<span class="c1">#            many redundant events.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        import fast_matched_filter as fmf</span>
<span class="c1">#        if not hasattr(self, &#39;trimmed_waveforms&#39;):</span>
<span class="c1">#            print(&#39;The FamilyEvents instance needs the trimmed_waveforms &#39;</span>
<span class="c1">#                  &#39;attribute, see trim_waveforms.&#39;)</span>
<span class="c1">#            return</span>
<span class="c1">#        self.max_lag = max_lag</span>
<span class="c1">#        self.find_closest_stations(n_stations, available_stations=available_stations)</span>
<span class="c1">#        print(&#39;Finding the best inter-event CCs...&#39;)</span>
<span class="c1">#        # format arrays for FMF</span>
<span class="c1">#        slice_ = np.index_exp[:, self.map_to_subnet, :, :]</span>
<span class="c1">#        data_arr = self.trimmed_waveforms.copy()[slice_]</span>
<span class="c1">#        norm_data = np.std(data_arr, axis=-1)[..., np.newaxis]</span>
<span class="c1">#        norm_data[norm_data == 0.] = 1.</span>
<span class="c1">#        data_arr /= norm_data</span>
<span class="c1">#        template_arr = data_arr[..., max_lag:-max_lag]</span>
<span class="c1">#        n_stations, n_components = data_arr.shape[1:-1]</span>
<span class="c1">#        # initialize ouputs</span>
<span class="c1">#        if paired is None:</span>
<span class="c1">#            paired = np.ones((self.n_events, self.n_events), dtype=bool)</span>
<span class="c1">#            self.paired = paired</span>
<span class="c1">#        output_shape = (np.sum(paired), n_stations)</span>
<span class="c1">#        CCs_S = np.zeros(output_shape, dtype=np.float32)</span>
<span class="c1">#        lags_S = np.zeros(output_shape, dtype=np.int32)</span>
<span class="c1">#        CCs_P = np.zeros(output_shape, dtype=np.float32)</span>
<span class="c1">#        lags_P = np.zeros(output_shape, dtype=np.int32)</span>
<span class="c1">#        # re-arrange input arrays to pass pieces of array</span>
<span class="c1">#        data_arr_P = np.ascontiguousarray(data_arr[:, :, 2:3, :])</span>
<span class="c1">#        template_arr_P = np.ascontiguousarray(template_arr[:, :, 2:3, :])</span>
<span class="c1">#        moveouts_arr_P = np.zeros((self.n_events, 1, 1), dtype=np.int32)</span>
<span class="c1">#        weights_arr_P = np.ones((self.n_events, 1, 1), dtype=np.float32)</span>
<span class="c1">#        data_arr_S = np.ascontiguousarray(data_arr[:, :, :2, :])</span>
<span class="c1">#        template_arr_S = np.ascontiguousarray(template_arr[:, :, :2, :])</span>
<span class="c1">#        moveouts_arr_S = np.zeros((self.n_events, 1, 2), dtype=np.int32)</span>
<span class="c1">#        weights_arr_S = 0.5*np.ones((self.n_events, 1, 2), dtype=np.float32)</span>
<span class="c1">#        # free some space</span>
<span class="c1">#        del data_arr, template_arr</span>
<span class="c1">#        counter = 0</span>
<span class="c1">#        for n in range(self.n_events):</span>
<span class="c1">#            print(f&#39;------ {n+1}/{self.n_events} -------&#39;)</span>
<span class="c1">#            selection = paired[n, :]</span>
<span class="c1">#            counter_inc = np.sum(selection)</span>
<span class="c1">#            for s in range(n_stations):</span>
<span class="c1">#                # use trick to keep station and component dim</span>
<span class="c1">#                slice_ = np.index_exp[selection, s:s+1, :, :]</span>
<span class="c1">#                cc_S = fmf.matched_filter(</span>
<span class="c1">#                        template_arr_S[slice_], moveouts_arr_S[selection, ...],</span>
<span class="c1">#                        weights_arr_S[selection, ...], data_arr_S[(n,)+slice_[1:]],</span>
<span class="c1">#                        1, check_zeros=False, arch=device)</span>
<span class="c1">#                cc_P = fmf.matched_filter(</span>
<span class="c1">#                        template_arr_P[slice_], moveouts_arr_P[selection, ...],</span>
<span class="c1">#                        weights_arr_P[selection, ...], data_arr_P[(n,)+slice_[1:]],</span>
<span class="c1">#                        1, check_zeros=False, arch=device)</span>
<span class="c1">#                # get best CC and its lag</span>
<span class="c1">#                CCs_S[counter:counter+counter_inc, s] = np.max(cc_S, axis=-1)</span>
<span class="c1">#                lags_S[counter:counter+counter_inc, s] = np.argmax(cc_S, axis=-1) - max_lag</span>
<span class="c1">#                CCs_P[counter:counter+counter_inc, s] = np.max(cc_P, axis=-1)</span>
<span class="c1">#                lags_P[counter:counter+counter_inc, s] = np.argmax(cc_P, axis=-1) - max_lag</span>
<span class="c1">#                # N.B: lags[n1, n2] is the ev1-ev2 time</span>
<span class="c1">#            counter += counter_inc</span>
<span class="c1">#        self.CCs_S = CCs_S</span>
<span class="c1">#        self.lags_S = lags_S</span>
<span class="c1">#        self.CCs_P = CCs_P</span>
<span class="c1">#        self.lags_P = lags_P</span>
<span class="c1">#        self.paired = paired</span>
<span class="c1">#        self.max_lag = max_lag</span>
<span class="c1">#</span>
<span class="c1">#    def plot_alignment(self, pair_id, s,</span>
<span class="c1">#                       components = [&#39;N&#39;, &#39;E&#39;, &#39;Z&#39;]):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Check visually what the max correlation alignment is worth.</span>
<span class="c1">#        This also demonstrates that we use the following convention:</span>
<span class="c1">#        Argmax(CC(pair[i, j])) == tt_j - tt_i</span>
<span class="c1">#        i.e. tt_2 - tt_1 in GrowClust</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        import matplotlib.pyplot as plt</span>
<span class="c1">#        if not hasattr(self, &#39;CCs_S&#39;):</span>
<span class="c1">#            print(&#39;Need to run self.cross_correlate first!&#39;)</span>
<span class="c1">#            return</span>
<span class="c1">#        pairs = np.column_stack(np.where(self.paired))</span>
<span class="c1">#        evid1, evid2 = pairs[pair_id]</span>
<span class="c1">#        ss = self.map_to_subnet[s]</span>
<span class="c1">#        fig, axes = plt.subplots(</span>
<span class="c1">#                num=f&#39;ev{evid1}_ev{evid2}_station_{s}&#39;,</span>
<span class="c1">#                nrows=3, ncols=1, figsize=(18, 9))</span>
<span class="c1">#        time = np.arange(self.trimmed_waveforms.shape[-1], dtype=np.float32)</span>
<span class="c1">#        for c in range(len(components)):</span>
<span class="c1">#            phase = &#39;S&#39; if c &lt; 2 else &#39;P&#39;</span>
<span class="c1">#            axes[c].plot(</span>
<span class="c1">#                    time, utils.max_norm(self.trimmed_waveforms[evid1, ss, c, :]),</span>
<span class="c1">#                    color=&#39;k&#39;, label=f&#39;Ev. {evid1}: {components[c]} cp. - {phase} wave&#39;)</span>
<span class="c1">#            if phase == &#39;S&#39;:</span>
<span class="c1">#                mv = self.max_lag + self.lags_S[pair_id, s]</span>
<span class="c1">#                CC = self.CCs_S[pair_id, s]</span>
<span class="c1">#            else:</span>
<span class="c1">#                mv = self.max_lag + self.lags_P[pair_id, s]</span>
<span class="c1">#                CC = self.CCs_P[pair_id, s]</span>
<span class="c1">#            axes[c].plot(</span>
<span class="c1">#                    time[:-2*self.max_lag] + mv,</span>
<span class="c1">#                    utils.max_norm(self.trimmed_waveforms[evid2, ss, c, self.max_lag:-self.max_lag]),</span>
<span class="c1">#                    color=&#39;C3&#39;, label=f&#39;Ev. {evid2}: {components[c]} cp. - {phase} wave&#39;</span>
<span class="c1">#                    f&#39;\nCC={CC:.2f}\nLag: {mv-self.max_lag}sp&#39;)</span>
<span class="c1">#            axes[c].axvline(self.max_lag, color=&#39;k&#39;)</span>
<span class="c1">#            axes[c].legend(loc=&#39;upper left&#39;)</span>
<span class="c1">#            axes[c].set_ylabel(&#39;Normalized Amp.&#39;)</span>
<span class="c1">#            axes[c].set_xlabel(&#39;Time (samples)&#39;)</span>
<span class="c1">#        plt.subplots_adjust(hspace=0.3)</span>
<span class="c1">#        return fig</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    # -------------------------------------------</span>
<span class="c1">#    #       GrowClust related methods</span>
<span class="c1">#    # -------------------------------------------</span>
<span class="c1">#    def read_GrowClust_output(self, filename, path):</span>
<span class="c1">#        print(&#39;Reading GrowClust output from {}&#39;.</span>
<span class="c1">#                format(os.path.join(path, filename)))</span>
<span class="c1">#        ot_, lon_, lat_, dep_, err_h_, err_v_, err_t_ = \</span>
<span class="c1">#                [], [], [], [], [], [], []</span>
<span class="c1">#        with open(os.path.join(path, filename), &#39;r&#39;) as f:</span>
<span class="c1">#            for line in f.readlines():</span>
<span class="c1">#                line = line.split()</span>
<span class="c1">#                year, month, day, hour, minu, sec = line[:6]</span>
<span class="c1">#                # correct date if necessary</span>
<span class="c1">#                if int(day) == 0:</span>
<span class="c1">#                    date_ = udt(f&#39;{year}-{month}-01&#39;)</span>
<span class="c1">#                    date_ -= datetime.timedelta(days=1)</span>
<span class="c1">#                    year, month, day = date_.year, date_.month, date_.day</span>
<span class="c1">#                # correct seconds if necessary</span>
<span class="c1">#                sec = float(sec)</span>
<span class="c1">#                if sec == 60.:</span>
<span class="c1">#                    sec -= 0.001</span>
<span class="c1">#                ot_.append(udt(f&#39;{year}-{month}-{day}T{hour}:{minu}:{sec}&#39;).timestamp)</span>
<span class="c1">#                event_id = int(line[6])</span>
<span class="c1">#                latitude, longitude, depth = list(map(float, line[7:10]))</span>
<span class="c1">#                lon_.append(longitude)</span>
<span class="c1">#                lat_.append(latitude)</span>
<span class="c1">#                dep_.append(depth)</span>
<span class="c1">#                mag = float(line[10])</span>
<span class="c1">#                q_id, cl_id, cluster_pop = list(map(int, line[11:14]))</span>
<span class="c1">#                n_pairs, n_P_dt, n_S_dt = list(map(int, line[14:17]))</span>
<span class="c1">#                rms_P, rms_S = list(map(float, line[17:19]))</span>
<span class="c1">#                err_h, err_v, err_t = list(map(float, line[19:22])) # errors in km and sec</span>
<span class="c1">#                err_h_.append(err_h)</span>
<span class="c1">#                err_v_.append(err_v)</span>
<span class="c1">#                err_t_.append(err_t)</span>
<span class="c1">#                latitude_init, longitude_init, depth_init =\</span>
<span class="c1">#                        list(map(float, line[22:25]))</span>
<span class="c1">#        cat = {}</span>
<span class="c1">#        cat[&#39;origin_time&#39;] = ot_</span>
<span class="c1">#        cat[&#39;longitude&#39;] = lon_</span>
<span class="c1">#        cat[&#39;latitude&#39;] = lat_</span>
<span class="c1">#        cat[&#39;depth&#39;] = dep_</span>
<span class="c1">#        cat[&#39;error_hor&#39;] = err_h_</span>
<span class="c1">#        cat[&#39;error_ver&#39;] = err_v_</span>
<span class="c1">#        cat[&#39;error_t&#39;] = err_t_</span>
<span class="c1">#        self.relocated_catalog =\</span>
<span class="c1">#                pd.DataFrame(data=cat)</span>
<span class="c1">#</span>
<span class="c1">#    def write_GrowClust_stationlist(self, filename, path,</span>
<span class="c1">#                                    network_filename=&#39;all_stations.in&#39;):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        This routine assumes that cross_correlate was called</span>
<span class="c1">#        shortly before and that self.template still has the same</span>
<span class="c1">#        set of stations as the ones used for the inter-event CCs.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        net = Network(network_filename)</span>
<span class="c1">#        net.read()</span>
<span class="c1">#        subnet = net.subset(</span>
<span class="c1">#                self.stations, net.components, method=&#39;keep&#39;)</span>
<span class="c1">#        with open(os.path.join(path, filename), &#39;w&#39;) as f:</span>
<span class="c1">#            for s in range(len(subnet.stations)):</span>
<span class="c1">#                f.write(&#39;{:&lt;5}\t{:.6f}\t{:.6f}\t{:.3f}\n&#39;.</span>
<span class="c1">#                        format(subnet.stations[s], subnet.latitude[s],</span>
<span class="c1">#                               subnet.longitude[s], -1000.*subnet.depth[s]))</span>
<span class="c1">#</span>
<span class="c1">#    def write_GrowClust_eventlist(self, filename, path):</span>
<span class="c1">#        from obspy.core import UTCDateTime as udt</span>
<span class="c1">#        if not hasattr(self, &#39;catalog&#39;):</span>
<span class="c1">#            self.attach_catalog()</span>
<span class="c1">#        with open(os.path.join(path, filename), &#39;w&#39;) as f:</span>
<span class="c1">#            for n in range(self.n_events):</span>
<span class="c1">#                nn = self.event_ids[n]</span>
<span class="c1">#                ot = udt(self.catalog.origin_times[nn])</span>
<span class="c1">#                if hasattr(self.catalog, relocated_catalog):</span>
<span class="c1">#                    # start from the relocated catalog</span>
<span class="c1">#                    f.write(&#39;{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t0.\t0.\t0.\t{}\n&#39;.</span>
<span class="c1">#                            format(ot.year, ot.month, ot.day, ot.hour, ot.minute,</span>
<span class="c1">#                                   ot.second, self.catalog.relocated_latitude[nn],</span>
<span class="c1">#                                   self.catalog.relocated_longitude[nn],</span>
<span class="c1">#                                   self.catalog.relocated_depth[nn],</span>
<span class="c1">#                                   self.catalog.magnitudes[nn], self.event_ids[n]))</span>
<span class="c1">#                else:</span>
<span class="c1">#                    # all events are given the template location</span>
<span class="c1">#                    f.write(&#39;{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t0.\t0.\t0.\t{}\n&#39;.</span>
<span class="c1">#                            format(ot.year, ot.month, ot.day, ot.hour, ot.minute,</span>
<span class="c1">#                                   ot.second, self.template.latitude,</span>
<span class="c1">#                                   self.template.longitude, self.template.depth,</span>
<span class="c1">#                                   self.catalog.magnitudes[nn], self.event_ids[n]))</span>
<span class="c1">#</span>
<span class="c1">#    def write_GrowClust_CC(self, filename, path, CC_threshold=0.):</span>
<span class="c1">#        if not hasattr(self, &#39;CCs_S&#39;):</span>
<span class="c1">#            print(&#39;Need to compute the inter-event CCs first.&#39;)</span>
<span class="c1">#            return</span>
<span class="c1">#        with open(os.path.join(path, filename), &#39;w&#39;) as f:</span>
<span class="c1">#            n1, n2 = np.meshgrid(np.arange(self.n_events, dtype=np.int32),</span>
<span class="c1">#                                 np.arange(self.n_events, dtype=np.int32),</span>
<span class="c1">#                                 indexing=&#39;ij&#39;)</span>
<span class="c1">#            n1  = n1.flatten()[self.paired.flatten()]</span>
<span class="c1">#            n2  = n2.flatten()[self.paired.flatten()]</span>
<span class="c1">#            for n in range(len(n1)):</span>
<span class="c1">#                f.write(&#39;#\t{}\t{}\t0.0\n&#39;.</span>
<span class="c1">#                        format(self.event_ids[n1[n]], self.event_ids[n2[n]]))</span>
<span class="c1">#                for s in range(len(self.stations)):</span>
<span class="c1">#                    # CCs that are zero are pairs that have to be skipped</span>
<span class="c1">#                    if self.CCs_S[n, s] &gt; CC_threshold:</span>
<span class="c1">#                        f.write(&#39;  {:&gt;5} {} {:.4f} S\n&#39;.</span>
<span class="c1">#                                format(self.stations[s],</span>
<span class="c1">#                                       self.lags_S[n, s]/self.sr,</span>
<span class="c1">#                                       self.CCs_S[n, s]))</span>
<span class="c1">#                    if self.CCs_P[n, s] &gt; CC_threshold:</span>
<span class="c1">#                        f.write(&#39;  {:&gt;5} {} {:.4f} P\n&#39;.</span>
<span class="c1">#                                format(self.stations[s],</span>
<span class="c1">#                                       self.lags_P[n, s]/self.sr,</span>
<span class="c1">#                                       self.CCs_P[n, s]))</span>
<span class="c1">#</span>
<span class="c1"># class FamilyGroupEvents(FamilyEvents):</span>
<span class="c1">#</span>
<span class="c1">#    def __init__(self, tids, db_path_T, db_path_M, db_path=cfg.INPUT_PATH):</span>
<span class="c1">#        self.tids = tids</span>
<span class="c1">#        self.n_templates = len(tids)</span>
<span class="c1">#        self.db_path_T = db_path_T</span>
<span class="c1">#        self.db_path_M = db_path_M</span>
<span class="c1">#        self.db_path = db_path</span>
<span class="c1">#        self.families = {tid: FamilyEvents(tid, db_path_T, db_path_M, db_path=db_path)</span>
<span class="c1">#                         for tid in tids}</span>
<span class="c1">#        self.sr = self.families[self.tids[0]].sr</span>
<span class="c1">#</span>
<span class="c1">#    def check_template_reloc(self):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        If templates were relocated, overwrite the catalog&#39;s location</span>
<span class="c1">#        with the template&#39;s relocated hypocenter</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if not hasattr(self, &#39;aggcat&#39;):</span>
<span class="c1">#            print(&#39;This FamilyGroupEvents instance has no FamilyGroupCatalog. &#39;</span>
<span class="c1">#                  &#39;Do nothing.&#39;)</span>
<span class="c1">#        else:</span>
<span class="c1">#            for tid in self.tids:</span>
<span class="c1">#                template = self.families[tid].template</span>
<span class="c1">#                for attr in [&#39;longitude&#39;, &#39;latitude&#39;, &#39;depth&#39;]:</span>
<span class="c1">#                    if hasattr(template, &#39;relocated_&#39;+attr):</span>
<span class="c1">#                        setattr(self.aggcat.catalogs[tid], attr, getattr(template, &#39;relocated_&#39;+attr))</span>
<span class="c1">#</span>
<span class="c1">#    def attach_catalog(self, dt_criterion=3., distance_criterion=5.,</span>
<span class="c1">#                       similarity_criterion=0.33, n_closest_stations=10,</span>
<span class="c1">#                       items_in=[]):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Creates an AggregatedCatalogs instance and</span>
<span class="c1">#        call AggregatedCatalogs.read_data(), as well as</span>
<span class="c1">#        AggregatedCatalogs.remove_multiples(). This is crucial to note</span>
<span class="c1">#        that remove_multiples returns a catalog that is ordered in time.</span>
<span class="c1">#        When reading data from the single-template families, these are</span>
<span class="c1">#        not ordered in time after concatenation.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        # force &#39;origin_times&#39; and &#39;magnitudes&#39; to be among the items</span>
<span class="c1">#        items_in = items_in + [&#39;origin_times&#39;, &#39;magnitudes&#39;,</span>
<span class="c1">#                    &#39;correlation_coefficients&#39;, &#39;unique_event&#39;]</span>
<span class="c1">#        filenames = [f&#39;multiplets{tid}catalog.h5&#39; for tid in self.tids]</span>
<span class="c1">#        self.aggcat = AggregatedCatalogs(</span>
<span class="c1">#                filenames=filenames, db_path_M=self.db_path_M, db_path=self.db_path)</span>
<span class="c1">#        self.aggcat.read_data(items_in=items_in + [&#39;location&#39;])</span>
<span class="c1">#        self.check_template_reloc()</span>
<span class="c1">#        self.catalog = self.aggcat.remove_multiples(</span>
<span class="c1">#                self.db_path_T, dt_criterion=dt_criterion,</span>
<span class="c1">#                distance_criterion=distance_criterion,</span>
<span class="c1">#                similarity_criterion=similarity_criterion,</span>
<span class="c1">#                n_closest_stations=n_closest_stations, return_catalog=True)</span>
<span class="c1">#        # load the rest of the requested attributes</span>
<span class="c1">#        rest = [item for item in items_in if item not in self.catalog.keys()]</span>
<span class="c1">#        self.catalog.update(self.aggcat.flatten_catalog(</span>
<span class="c1">#            attributes=rest, chronological_order=True))</span>
<span class="c1">#</span>
<span class="c1">#    def find_closest_stations(self, n_stations, available_stations=None):</span>
<span class="c1">#        # overriden method from parent class</span>
<span class="c1">#        stations = []</span>
<span class="c1">#        for tid in self.tids:</span>
<span class="c1">#            self.families[tid].template.n_closest_stations(</span>
<span class="c1">#                    n_stations, available_stations=available_stations)</span>
<span class="c1">#            stations.extend(self.families[tid].template.stations)</span>
<span class="c1">#        stations, counts = np.unique(stations, return_counts=True)</span>
<span class="c1">#        sorted_ind = np.argsort(counts)[::-1]</span>
<span class="c1">#        self.stations = stations[sorted_ind[:n_stations]]</span>
<span class="c1">#        network_stations = self.families[self.tids[0]].template.network_stations</span>
<span class="c1">#        self.map_to_subnet = np.int32([np.where(network_stations == sta)[0]</span>
<span class="c1">#                                       for sta in self.stations]).squeeze()</span>
<span class="c1">#        # update all subfamilies</span>
<span class="c1">#        for tid in self.tids:</span>
<span class="c1">#            self.families[tid].stations = self.stations</span>
<span class="c1">#            self.families[tid].map_to_subnet = self.map_to_subnet</span>
<span class="c1">#</span>
<span class="c1">#    def pair_events(self, random_pairing_frac=0., random_max=2):</span>
<span class="c1">#        if not hasattr(self, &#39;catalog&#39;):</span>
<span class="c1">#            # call attach_catalog() for calling remove_multiples()</span>
<span class="c1">#            # !!! the catalog that is returned like that takes all</span>
<span class="c1">#            # single-template families and order them in time, so</span>
<span class="c1">#            # it is ESSENTIAL to make sure that the data are ordered</span>
<span class="c1">#            # the same way</span>
<span class="c1">#            self.attach_catalog()</span>
<span class="c1">#        # all valid events are the unique events and also</span>
<span class="c1">#        # the events with highest CC from each family, to make</span>
<span class="c1">#        # sure all families will end up being paired by at least one event</span>
<span class="c1">#        valid_events = self.catalog[&#39;unique_event&#39;].copy()</span>
<span class="c1">#        highest_CC_events_idx = {}</span>
<span class="c1">#        for tid in self.tids:</span>
<span class="c1">#            selection = self.catalog[&#39;tids&#39;] == tid</span>
<span class="c1">#            highest_CC_events_idx[tid] = np.where(</span>
<span class="c1">#                self.catalog[&#39;correlation_coefficients&#39;]</span>
<span class="c1">#                == self.catalog[&#39;correlation_coefficients&#39;][selection].max())[0][0]</span>
<span class="c1">#            valid_events[highest_CC_events_idx[tid]] = True</span>
<span class="c1">#        self.paired = np.zeros((self.n_events, self.n_events), dtype=bool)</span>
<span class="c1">#        for n in range(self.n_events):</span>
<span class="c1">#            if valid_events[n]:</span>
<span class="c1">#                # if this is a valid event, pair it with</span>
<span class="c1">#                # all other valid events</span>
<span class="c1">#                self.paired[n, valid_events] = True</span>
<span class="c1">#            # in all cases, pair the events with all other</span>
<span class="c1">#            # events of the same family</span>
<span class="c1">#            tid = self.catalog[&#39;tids&#39;][n]</span>
<span class="c1">#            self.paired[n, self.catalog[&#39;tids&#39;] == tid] = True</span>
<span class="c1">#            # OR --------------------</span>
<span class="c1">#            # link non-unique events only to their best CC event</span>
<span class="c1">#            #self.paired[n, highest_CC_events_idx[tid]] = True</span>
<span class="c1">#            # -------------------</span>
<span class="c1">#            # and add a few randomly selected connections</span>
<span class="c1">#            unpaired = np.where(~self.paired[n, :])[0]</span>
<span class="c1">#            n_random = min(random_max, int(random_pairing_frac*len(unpaired)))</span>
<span class="c1">#            if n_random &gt; 0:</span>
<span class="c1">#                if len(unpaired) &gt; 0:</span>
<span class="c1">#                    random_choice = np.random.choice(</span>
<span class="c1">#                            unpaired, size=n_random, replace=False)</span>
<span class="c1">#                    self.paired[n, random_choice] = True</span>
<span class="c1">#        np.fill_diagonal(self.paired, False)</span>
<span class="c1">#</span>
<span class="c1">#    def read_data(self, **kwargs):</span>
<span class="c1">#        # overriden method from parent class</span>
<span class="c1">#        for tid in self.tids:</span>
<span class="c1">#            if hasattr(self, &#39;aggcat&#39;):</span>
<span class="c1">#                # use the already loaded, and potentially edited, catalog</span>
<span class="c1">#                kwargs[&#39;catalog&#39;] = self.aggcat.families[tid]</span>
<span class="c1">#            self.families[tid].read_data(**kwargs)</span>
<span class="c1">#        self.event_ids_str = \</span>
<span class="c1">#                np.asarray([event_id for tid in self.tids</span>
<span class="c1">#                           for event_id in self.families[tid].event_ids_str])</span>
<span class="c1">#        self.n_events = len(self.event_ids_str)</span>
<span class="c1">#</span>
<span class="c1">#    def read_trimmed_waveforms(self, *args, **kwargs):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        See FamilyEvents.read_trimmed_waveforms</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        # overriden method from parent class</span>
<span class="c1">#        for tid in self.tids:</span>
<span class="c1">#            self.families[tid].read_trimmed_waveforms(</span>
<span class="c1">#                    *args, **kwargs)</span>
<span class="c1">#        # agglomerate all waveforms into one array</span>
<span class="c1">#        self.trimmed_waveforms = np.concatenate(</span>
<span class="c1">#                [self.families[tid].trimmed_waveforms for tid in self.tids],</span>
<span class="c1">#                axis=0)</span>
<span class="c1">#        # add metadata</span>
<span class="c1">#        self.event_ids_str = \</span>
<span class="c1">#                np.asarray([event_id for tid in self.tids</span>
<span class="c1">#                           for event_id in self.families[tid].event_ids_str])</span>
<span class="c1">#        self.sr = self.families[self.tids[0]].sr</span>
<span class="c1">#        # reorder in chronological order</span>
<span class="c1">#        OT = []</span>
<span class="c1">#        for tid in self.tids:</span>
<span class="c1">#            #self.families[tid].attach_catalog(items_in=[&#39;origin_times&#39;])</span>
<span class="c1">#            OT.extend(self.families[tid].catalog</span>
<span class="c1">#                        .origin_times[self.families[tid].event_ids])</span>
<span class="c1">#        OT = np.float64(OT) # and now these are the correct origin times</span>
<span class="c1">#        sorted_ind = np.argsort(OT)</span>
<span class="c1">#        self.trimmed_waveforms = self.trimmed_waveforms[sorted_ind, ...]</span>
<span class="c1">#        self.event_ids_str = self.event_ids_str[sorted_ind]</span>
<span class="c1">#        self.n_events = len(self.event_ids_str)</span>
<span class="c1">#        self.event_ids = np.arange(self.n_events)</span>
<span class="c1">#</span>
<span class="c1">#    def read_trimmed_waveforms_raw(self, *args, **kwargs):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        See FamilyEvents.read_trimmed_waveforms_raw</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        # overriden method from parent class</span>
<span class="c1">#        for tid in self.tids:</span>
<span class="c1">#            self.families[tid].read_trimmed_waveforms_raw(</span>
<span class="c1">#                    *args, **kwargs)</span>
<span class="c1">#        # agglomerate all trimmed events into ine list</span>
<span class="c1">#        self.trimmed_events = sum(</span>
<span class="c1">#                [self.families[tid].trimmed_events for tid in self.tids], [])</span>
<span class="c1">#        # add metadata</span>
<span class="c1">#        self.event_ids_str = \</span>
<span class="c1">#                np.asarray([event_id for tid in self.tids</span>
<span class="c1">#                           for event_id in self.families[tid].event_ids_str])</span>
<span class="c1">#        # reorder in chronological order</span>
<span class="c1">#        OT = []</span>
<span class="c1">#        for tid in self.tids:</span>
<span class="c1">#            #self.families[tid].attach_catalog(items_in=[&#39;origin_times&#39;])</span>
<span class="c1">#            OT.extend(self.families[tid].catalog</span>
<span class="c1">#                        .origin_times[self.families[tid].event_ids])</span>
<span class="c1">#        OT = np.float64(OT) # and now these are the correct origin times</span>
<span class="c1">#        sorted_ind = np.argsort(OT)</span>
<span class="c1">#        self.trimmed_events = [self.trimmed_events[i] for i in sorted_ind]</span>
<span class="c1">#        self.event_ids_str = self.event_ids_str[sorted_ind]</span>
<span class="c1">#        self.n_events = len(self.event_ids_str)</span>
<span class="c1">#        self.event_ids = np.arange(self.n_events)</span>
<span class="c1">#</span>
<span class="c1">#    def trim_waveforms(self, *args, **kwargs):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        See FamilyEvents.trim_waveforms</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        # overriden method from parent class</span>
<span class="c1">#        for tid in self.tids:</span>
<span class="c1">#           self.families[tid].trim_waveforms(</span>
<span class="c1">#                   *args, **kwargs)</span>
<span class="c1">#        # agglomerate all waveforms into one array</span>
<span class="c1">#        self.trimmed_waveforms = np.concatenate(</span>
<span class="c1">#                [self.families[tid].trimmed_waveforms for tid in self.tids</span>
<span class="c1">#                    if self.families[tid].n_events &gt; 0], axis=0)</span>
<span class="c1">#        # reorder in chronological order</span>
<span class="c1">#        #self.attach_catalog()</span>
<span class="c1">#        # no this is wrong!!! attach_catalog() call remove_multiples()</span>
<span class="c1">#        # which already merges single-template families and order them</span>
<span class="c1">#        # in time.... so to get the actual origin times that correspond</span>
<span class="c1">#        # to the data that were loaded, we need to read from the single-</span>
<span class="c1">#        # template catalog!!!</span>
<span class="c1">#        #sorted_ind = np.argsort(self.catalog[&#39;origin_times&#39;])</span>
<span class="c1">#        OT = []</span>
<span class="c1">#        for tid in self.tids:</span>
<span class="c1">#            self.families[tid].attach_catalog(items_in=[&#39;origin_times&#39;])</span>
<span class="c1">#            OT.extend(self.families[tid].catalog</span>
<span class="c1">#                        .origin_times[self.families[tid].event_ids])</span>
<span class="c1">#        OT = np.float64(OT) # and now these are the correct origin times</span>
<span class="c1">#        sorted_ind = np.argsort(OT)</span>
<span class="c1">#        self.trimmed_waveforms = self.trimmed_waveforms[sorted_ind, ...]</span>
<span class="c1">#        self.event_ids_str = self.event_ids_str[sorted_ind]</span>
<span class="c1">#        #for attr in self.catalog.keys():</span>
<span class="c1">#        #    self.catalog[attr] = self.catalog[attr][sorted_ind]</span>
<span class="c1">#        self.event_ids = np.arange(self.n_events)</span>
<span class="c1">#</span>
<span class="c1">#    # -------------------------------------------</span>
<span class="c1">#    #       GrowClust related methods</span>
<span class="c1">#    # -------------------------------------------</span>
<span class="c1">#    def read_GrowClust_output(self, filename_out, filename_evid,</span>
<span class="c1">#                              path_out, path_evid):</span>
<span class="c1">#        print(&#39;Reading GrowClust output from {}&#39;.</span>
<span class="c1">#                format(os.path.join(path_out, filename_out)))</span>
<span class="c1">#        print(&#39;Reading event ids from {}&#39;.</span>
<span class="c1">#                format(os.path.join(path_evid, filename_evid)))</span>
<span class="c1">#        event_ids_map = pd.read_csv(</span>
<span class="c1">#                os.path.join(path_evid, filename_evid), index_col=0)</span>
<span class="c1">#        ot_, lon_, lat_, dep_, err_h_, err_v_, err_t_, evids_ = \</span>
<span class="c1">#                [], [], [], [], [], [], [], []</span>
<span class="c1">#        with open(os.path.join(path_out, filename_out), &#39;r&#39;) as f:</span>
<span class="c1">#            for line in f.readlines():</span>
<span class="c1">#                line = line.split()</span>
<span class="c1">#                year, month, day, hour, minu, sec = line[:6]</span>
<span class="c1">#                # correct date if necessary</span>
<span class="c1">#                if int(day) == 0:</span>
<span class="c1">#                    date_ = udt(f&#39;{year}-{month}-01&#39;)</span>
<span class="c1">#                    date_ -= datetime.timedelta(days=1)</span>
<span class="c1">#                    year, month, day = date_.year, date_.month, date_.day</span>
<span class="c1">#                # correct seconds if necessary</span>
<span class="c1">#                sec = float(sec)</span>
<span class="c1">#                if sec == 60.:</span>
<span class="c1">#                    sec -= 0.001</span>
<span class="c1">#                ot_.append(udt(f&#39;{year}-{month}-{day}T{hour}:{minu}:{sec}&#39;).timestamp)</span>
<span class="c1">#                event_id = int(line[6])</span>
<span class="c1">#                evids_.append(event_id)</span>
<span class="c1">#                latitude, longitude, depth = list(map(float, line[7:10]))</span>
<span class="c1">#                lon_.append(longitude)</span>
<span class="c1">#                lat_.append(latitude)</span>
<span class="c1">#                dep_.append(depth)</span>
<span class="c1">#                mag = float(line[10])</span>
<span class="c1">#                q_id, cl_id, cluster_pop = list(map(int, line[11:14]))</span>
<span class="c1">#                n_pairs, n_P_dt, n_S_dt = list(map(int, line[14:17]))</span>
<span class="c1">#                rms_P, rms_S = list(map(float, line[17:19]))</span>
<span class="c1">#                err_h, err_v, err_t = list(map(float, line[19:22])) # errors in km and sec</span>
<span class="c1">#                err_h_.append(err_h)</span>
<span class="c1">#                err_v_.append(err_v)</span>
<span class="c1">#                err_t_.append(err_t)</span>
<span class="c1">#                latitude_init, longitude_init, depth_init =\</span>
<span class="c1">#                        list(map(float, line[22:25]))</span>
<span class="c1">#        # convert all lists to np arrays</span>
<span class="c1">#        ot_ = np.float64(ot_)</span>
<span class="c1">#        lon_, lat_, dep_ = np.float32(lon_), np.float32(lat_), np.float32(dep_)</span>
<span class="c1">#        err_h_, err_v_, err_t_ = \</span>
<span class="c1">#                np.float32(err_h_), np.float32(err_v_), np.float32(err_t_)</span>
<span class="c1">#        evids_ = np.int32(evids_)</span>
<span class="c1">#        # distribute results over corresponding templates</span>
<span class="c1">#        for tid in self.tids:</span>
<span class="c1">#            selection = event_ids_map.index == tid</span>
<span class="c1">#            event_ids_tid = event_ids_map[&#39;event_ids&#39;][selection]</span>
<span class="c1">#            cat = {}</span>
<span class="c1">#            cat[&#39;origin_time&#39;] = ot_[selection]</span>
<span class="c1">#            cat[&#39;longitude&#39;] = lon_[selection]</span>
<span class="c1">#            cat[&#39;latitude&#39;] = lat_[selection]</span>
<span class="c1">#            cat[&#39;depth&#39;] = dep_[selection]</span>
<span class="c1">#            cat[&#39;error_hor&#39;] = err_h_[selection]</span>
<span class="c1">#            cat[&#39;error_ver&#39;] = err_v_[selection]</span>
<span class="c1">#            cat[&#39;error_t&#39;] = err_t_[selection]</span>
<span class="c1">#            cat[&#39;event_ids&#39;] = event_ids_tid</span>
<span class="c1">#            self.families[tid].relocated_catalog =\</span>
<span class="c1">#                    pd.DataFrame(data=cat)</span>
<span class="c1">#        # attach flattened version for convenience</span>
<span class="c1">#        cat = {}</span>
<span class="c1">#        cat[&#39;origin_time&#39;] = ot_</span>
<span class="c1">#        cat[&#39;longitude&#39;] = lon_</span>
<span class="c1">#        cat[&#39;latitude&#39;] = lat_</span>
<span class="c1">#        cat[&#39;depth&#39;] = dep_</span>
<span class="c1">#        cat[&#39;error_hor&#39;] = err_h_</span>
<span class="c1">#        cat[&#39;error_ver&#39;] = err_v_</span>
<span class="c1">#        cat[&#39;error_t&#39;] = err_t_</span>
<span class="c1">#        cat[&#39;event_ids&#39;] = event_ids_map[&#39;event_ids&#39;]</span>
<span class="c1">#        cat[&#39;tids&#39;] = event_ids_map.index</span>
<span class="c1">#        self.relocated_catalog =\</span>
<span class="c1">#                pd.DataFrame(data=cat)</span>
<span class="c1">#        self.n_events = len(self.relocated_catalog)</span>
<span class="c1">#        self.event_ids = np.arange(self.n_events, dtype=np.int32)</span>
<span class="c1">#</span>
<span class="c1">#    def write_GrowClust_eventlist(self, filename, path, fresh_start=True):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Note: The different with its single family counterpart is that</span>
<span class="c1">#        here the catalog is already in the same order as self.event_ids</span>
<span class="c1">#        (cf. trim_waveforms)</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        from obspy.core import UTCDateTime as udt</span>
<span class="c1">#        if not hasattr(self, &#39;catalog&#39;):</span>
<span class="c1">#            self.attach_catalog()</span>
<span class="c1">#        if hasattr(self, &#39;relocated_catalog&#39;) and not fresh_start:</span>
<span class="c1">#            print(&#39;Give locations from relocated catalog&#39;)</span>
<span class="c1">#        with open(os.path.join(path, filename), &#39;w&#39;) as f:</span>
<span class="c1">#            for n in range(self.n_events):</span>
<span class="c1">#                ot = udt(self.catalog[&#39;origin_times&#39;][n])</span>
<span class="c1">#                if hasattr(self, &#39;relocated_catalog&#39;) and not fresh_start:</span>
<span class="c1">#                    # start from the relocated catalog</span>
<span class="c1">#                    f.write(&#39;{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t0.\t0.\t0.\t{}\n&#39;.</span>
<span class="c1">#                            format(ot.year, ot.month, ot.day, ot.hour, ot.minute,</span>
<span class="c1">#                                   ot.second, self.relocated_catalog[&#39;latitude&#39;].iloc[n],</span>
<span class="c1">#                                   self.relocated_catalog[&#39;longitude&#39;].iloc[n],</span>
<span class="c1">#                                   self.relocated_catalog[&#39;depth&#39;].iloc[n],</span>
<span class="c1">#                                   self.catalog[&#39;magnitudes&#39;][n], self.event_ids[n]))</span>
<span class="c1">#                else:</span>
<span class="c1">#                    f.write(&#39;{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t0.\t0.\t0.\t{}\n&#39;.</span>
<span class="c1">#                            format(ot.year, ot.month, ot.day, ot.hour, ot.minute,</span>
<span class="c1">#                                   ot.second, self.catalog[&#39;latitude&#39;][n],</span>
<span class="c1">#                                   self.catalog[&#39;longitude&#39;][n], self.catalog[&#39;depth&#39;][n],</span>
<span class="c1">#                                   self.catalog[&#39;magnitudes&#39;][n], self.event_ids[n]))</span>
<span class="c1">#</span>
<span class="c1">#    def write_GrowClust_eventids(self, filename, path):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        For each flat integer event id used by GrowClust, we write</span>
<span class="c1">#        the corresponding template id and event id so that we can</span>
<span class="c1">#        link the relocated events to their template/detection.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        with open(os.path.join(path, filename), &#39;w&#39;) as f:</span>
<span class="c1">#            # write column names</span>
<span class="c1">#            f.write(&#39;tids,event_ids\n&#39;)</span>
<span class="c1">#            for n in range(self.n_events):</span>
<span class="c1">#                f.write(f&#39;{self.event_ids_str[n]}\n&#39;)</span>
<span class="c1">#                #sep = self.event_ids_str[n].find(&#39;.&#39;)</span>
<span class="c1">#                #f.write(&#39;{:d},{:d}\n&#39;.format(</span>
<span class="c1">#                #    int(self.event_ids_str[n][:sep]),</span>
<span class="c1">#                #    int(self.event_ids_str[n][sep+1:])))</span>
<span class="c1">#</span>
<span class="c1">### --------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">##class TemplateGroup(object):</span>
<span class="c1">##    &quot;&quot;&quot;A TemplateGroup class to handle groups of templates.</span>
<span class="c1">##</span>
<span class="c1">##</span>
<span class="c1">##    &quot;&quot;&quot;</span>
<span class="c1">##</span>
<span class="c1">##    def __init__(self, tids, db_path_T, db_path=cfg.INPUT_PATH):</span>
<span class="c1">##        &quot;&quot;&quot;Read the templates&#39; data and metadata.</span>
<span class="c1">##</span>
<span class="c1">##        Parameters</span>
<span class="c1">##        -----------</span>
<span class="c1">##        tids: list or nd.array</span>
<span class="c1">##            List of template ids in the group.</span>
<span class="c1">##        db_path_T: string</span>
<span class="c1">##            Name of the folder with template files.</span>
<span class="c1">##        db_path: string, default to cfg.INPUT_PATH</span>
<span class="c1">##            Name of the folder with output files.</span>
<span class="c1">##        &quot;&quot;&quot;</span>
<span class="c1">##        self.templates = []</span>
<span class="c1">##        self.tids = tids</span>
<span class="c1">##        self.n_templates = len(tids)</span>
<span class="c1">##        self.db_path_T = db_path_T</span>
<span class="c1">##        self.db_path = db_path</span>
<span class="c1">##        self.tids_map = {}</span>
<span class="c1">##        for t, tid in enumerate(tids):</span>
<span class="c1">##            self.templates.append(</span>
<span class="c1">##                    Template(f&#39;template{tid}&#39;, db_path_T, db_path=db_path))</span>
<span class="c1">##            self.tids_map[tid] = t</span>
<span class="c1">##</span>
<span class="c1">##    def attach_intertp_distances(self):</span>
<span class="c1">##        &quot;&quot;&quot;Compute distance between all template pairs.</span>
<span class="c1">##</span>
<span class="c1">##        &quot;&quot;&quot;</span>
<span class="c1">##        print(&#39;Computing the inter-template distances...&#39;)</span>
<span class="c1">##        self.intertp_distances = intertp_distances_(</span>
<span class="c1">##                templates=self.templates, return_as_pd=True)</span>
<span class="c1">##</span>
<span class="c1">##    def attach_directional_errors(self):</span>
<span class="c1">##        &quot;&quot;&quot;Compute the length of the uncertainty ellipsoid</span>
<span class="c1">##        inter-template direction.</span>
<span class="c1">##</span>
<span class="c1">##        New Attributes</span>
<span class="c1">##        ----------</span>
<span class="c1">##        directional_errors: (n_templates, n_templates) pandas DataFrame</span>
<span class="c1">##            The length, in kilometers, of the uncertainty ellipsoid in the</span>
<span class="c1">##            inter-template direction.</span>
<span class="c1">##            Example: self.directional_errors.loc[tid1, tid2] is the width of</span>
<span class="c1">##            template tid1&#39;s uncertainty ellipsoid in the direction of</span>
<span class="c1">##            template tid2.</span>
<span class="c1">##        &quot;&quot;&quot;</span>
<span class="c1">##        print(&#39;Computing the inter-template directional errors...&#39;)</span>
<span class="c1">##        from cartopy import crs</span>
<span class="c1">##        # ----------------------------------------------</span>
<span class="c1">##        #      Define the projection used to</span>
<span class="c1">##        #      work in a cartesian space</span>
<span class="c1">##        # ----------------------------------------------</span>
<span class="c1">##        data_coords = crs.PlateCarree()</span>
<span class="c1">##        longitudes = np.float32([self.templates[i].longitude for i in range(self.n_templates)])</span>
<span class="c1">##        latitudes = np.float32([self.templates[i].latitude for i in range(self.n_templates)])</span>
<span class="c1">##        depths = np.float32([self.templates[i].depth for i in range(self.n_templates)])</span>
<span class="c1">##        projection = crs.Mercator(central_longitude=np.mean(longitudes),</span>
<span class="c1">##                                  min_latitude=latitudes.min(),</span>
<span class="c1">##                                  max_latitude=latitudes.max())</span>
<span class="c1">##        XY = projection.transform_points(data_coords, longitudes, latitudes)</span>
<span class="c1">##        cartesian_coords = np.stack([XY[:, 0], XY[:, 1], depths], axis=1)</span>
<span class="c1">##        # compute the directional errors</span>
<span class="c1">##        dir_errors = np.zeros((self.n_templates, self.n_templates), dtype=np.float32)</span>
<span class="c1">##        for t in range(self.n_templates):</span>
<span class="c1">##            unit_direction = cartesian_coords - cartesian_coords[t, :]</span>
<span class="c1">##            unit_direction /= np.sqrt(np.sum(unit_direction**2, axis=1))[:, np.newaxis]</span>
<span class="c1">##            # this operation produced NaNs for i=t</span>
<span class="c1">##            unit_direction[np.isnan(unit_direction)] = 0.</span>
<span class="c1">##            # compute the length of the covariance ellipsoid</span>
<span class="c1">##            # in the direction that links the two earthquakes</span>
<span class="c1">##            cov_dir = np.abs(np.sum(</span>
<span class="c1">##                self.templates[t].cov_mat.dot(unit_direction.T)*unit_direction.T, axis=0))</span>
<span class="c1">##            # covariance is unit of [distance**2], therefore we need the sqrt:</span>
<span class="c1">##            dir_errors[t, :] = np.sqrt(cov_dir)</span>
<span class="c1">##        # format it in a pandas DataFrame</span>
<span class="c1">##        dir_errors = pd.DataFrame(columns=[tid for tid in self.tids],</span>
<span class="c1">##                                  index=[tid for tid in self.tids],</span>
<span class="c1">##                                  data=dir_errors)</span>
<span class="c1">##        self.directional_errors = dir_errors</span>
<span class="c1">##</span>
<span class="c1">##</span>
<span class="c1">##    def attach_ellipsoid_distances(self, substract_errors=True):</span>
<span class="c1">##        &quot;&quot;&quot;</span>
<span class="c1">##        Combine inter-template distances and directional errors</span>
<span class="c1">##        to compute the minimum inter-uncertainty ellipsoid distances.</span>
<span class="c1">##        This quantity can be negative if the ellipsoids overlap.</span>
<span class="c1">##        &quot;&quot;&quot;</span>
<span class="c1">##        import pandas as pd</span>
<span class="c1">##        if not hasattr(self, &#39;intertp_distances&#39;):</span>
<span class="c1">##            self.attach_intertp_distances()</span>
<span class="c1">##        if not hasattr(self, &#39;directional_errors&#39;):</span>
<span class="c1">##            self.attach_directional_errors()</span>
<span class="c1">##        if substract_errors:</span>
<span class="c1">##            ellipsoid_distances = self.intertp_distances.values\</span>
<span class="c1">##                                - self.directional_errors.values\</span>
<span class="c1">##                                - self.directional_errors.values.T</span>
<span class="c1">##        else:</span>
<span class="c1">##            ellipsoid_distances = self.intertp_distances.values</span>
<span class="c1">##        self.ellipsoid_distances = pd.DataFrame(</span>
<span class="c1">##                columns=[tid for tid in self.tids],</span>
<span class="c1">##                index=[tid for tid in self.tids],</span>
<span class="c1">##                data=ellipsoid_distances)</span>
<span class="c1">##</span>
<span class="c1">##    def read_stacks(self, **SVDWF_kwargs):</span>
<span class="c1">##        self.db_path_M = SVDWF_kwargs.get(&#39;db_path_M&#39;, &#39;none&#39;)</span>
<span class="c1">##        self.stacks = []</span>
<span class="c1">##        for t, tid in enumerate(self.tids):</span>
<span class="c1">##            stack = utils.SVDWF_multiplets(</span>
<span class="c1">##                    tid, db_path=self.db_path,</span>
<span class="c1">##                    db_path_T=self.db_path_T,</span>
<span class="c1">##                    **SVDWF_kwargs)</span>
<span class="c1">##            self.stacks.append(stack)</span>
<span class="c1">##</span>
<span class="c1">##    def read_waveforms(self):</span>
<span class="c1">##        for template in self.templates:</span>
<span class="c1">##            template.read_waveforms()</span>
<span class="c1">##</span>
<span class="c1">##    def plot_cc(self, cmap=&#39;inferno&#39;):</span>
<span class="c1">##        if not hasattr(self, &#39;intertp_cc&#39;):</span>
<span class="c1">##            print(&#39;Should call self.template_similarity first&#39;)</span>
<span class="c1">##            return</span>
<span class="c1">##        import matplotlib.pyplot as plt</span>
<span class="c1">##        fig = plt.figure(&#39;template_similarity&#39;, figsize=(18, 9))</span>
<span class="c1">##        ax = fig.add_subplot(111)</span>
<span class="c1">##        tids1_g, tids2_g = np.meshgrid(self.tids, self.tids, indexing=&#39;ij&#39;)</span>
<span class="c1">##        pc = ax.pcolormesh(tids1_g, tids2_g, self.intertp_cc.values, cmap=cmap)</span>
<span class="c1">##        ax.set_xlabel(&#39;Template id&#39;)</span>
<span class="c1">##        ax.set_ylabel(&#39;Template id&#39;)</span>
<span class="c1">##        fig.colorbar(pc, label=&#39;Correlation Coefficient&#39;)</span>
<span class="c1">##        return fig</span>
<span class="c1">##</span>
<span class="c1">##    def template_similarity(self, distance_threshold=5.,</span>
<span class="c1">##                            n_stations=10, max_lag=10,</span>
<span class="c1">##                            device=&#39;cpu&#39;):</span>
<span class="c1">##        &quot;&quot;&quot;</span>
<span class="c1">##        Parameters</span>
<span class="c1">##        -----------</span>
<span class="c1">##        distance_threshold: float, default to 5</span>
<span class="c1">##            The distance threshold, in kilometers, between two</span>
<span class="c1">##            uncertainty ellipsoids under which similarity is computed.</span>
<span class="c1">##        n_stations: integer, default to 10</span>
<span class="c1">##            The number of stations closest to each template used in</span>
<span class="c1">##            the computation of the average CC.</span>
<span class="c1">##        max_lag: integer, default to 10</span>
<span class="c1">##            Maximum lag, in samples, allowed when searching for the</span>
<span class="c1">##            maximum CC on each channel. This is to account for small</span>
<span class="c1">##            discrepancies in windowing that could occur for two templates</span>
<span class="c1">##            highly similar but associated to slightly different locations.</span>
<span class="c1">##        &quot;&quot;&quot;</span>
<span class="c1">##        import pandas as pd</span>
<span class="c1">##        import fast_matched_filter as fmf</span>
<span class="c1">##        if not hasattr(self, &#39;ellipsoid_distances&#39;):</span>
<span class="c1">##            self.attach_ellipsoid_distances()</span>
<span class="c1">##        for template in self.templates:</span>
<span class="c1">##            template.read_waveforms()</span>
<span class="c1">##            template.n_closest_stations(n_stations)</span>
<span class="c1">##        print(&#39;Computing the similarity matrix...&#39;)</span>
<span class="c1">##        # format arrays for FMF</span>
<span class="c1">##        tp_array = np.stack([tp.network_waveforms for tp in self.templates],</span>
<span class="c1">##                             axis=0)</span>
<span class="c1">##        data = tp_array.copy()</span>
<span class="c1">##        tp_array = tp_array[..., max_lag:-max_lag]</span>
<span class="c1">##        moveouts = np.zeros(tp_array.shape[:-1], dtype=np.int32)</span>
<span class="c1">##        intertp_cc = np.zeros((self.n_templates, self.n_templates),</span>
<span class="c1">##                              dtype=np.float32)</span>
<span class="c1">##        n_stations, n_components = moveouts.shape[1:]</span>
<span class="c1">##        # use FMF on one template at a time against all others</span>
<span class="c1">##        for t in range(self.n_templates):</span>
<span class="c1">##            #print(f&#39;--- {t} / {self.n_templates} ---&#39;)</span>
<span class="c1">##            template = self.templates[t]</span>
<span class="c1">##            weights = np.zeros(tp_array.shape[:-1], dtype=np.float32)</span>
<span class="c1">##            weights[:, template.map_to_subnet, :] = 1.</span>
<span class="c1">##            weights /= np.sum(weights, axis=(1, 2))[:, np.newaxis, np.newaxis]</span>
<span class="c1">##            above_thrs = self.ellipsoid_distances[self.tids[t]] &gt; distance_threshold</span>
<span class="c1">##            weights[above_thrs, ...] = 0.</span>
<span class="c1">##            below_thrs = self.ellipsoid_distances[self.tids[t]] &lt; distance_threshold</span>
<span class="c1">##            for s in range(n_stations):</span>
<span class="c1">##                for c in range(n_components):</span>
<span class="c1">##                    # use trick to keep station and component dim</span>
<span class="c1">##                    slice_ = np.index_exp[:, s:s+1, c:c+1, :]</span>
<span class="c1">##                    data_ = data[(t,)+slice_[1:]]</span>
<span class="c1">##                    # discard all templates that have weights equal to zero</span>
<span class="c1">##                    keep = (weights[:, s, c] != 0.)\</span>
<span class="c1">##                          &amp;  (np.sum(tp_array[slice_], axis=-1).squeeze() != 0.)</span>
<span class="c1">##                    if (np.sum(keep) == 0) or (np.sum(data[(t,)+slice_[1:]]) == 0):</span>
<span class="c1">##                        # occurs if this station is not among the</span>
<span class="c1">##                        # n_stations closest stations</span>
<span class="c1">##                        # or if no data were available</span>
<span class="c1">##                        continue</span>
<span class="c1">##                    cc = fmf.matched_filter(</span>
<span class="c1">##                            tp_array[slice_][keep, ...], moveouts[slice_[:-1]][keep, ...],</span>
<span class="c1">##                            weights[slice_[:-1]][keep, ...], data[(t,)+slice_[1:]],</span>
<span class="c1">##                            1, arch=device)</span>
<span class="c1">##                    # add best contribution from this channel to</span>
<span class="c1">##                    # the average inter-template CC</span>
<span class="c1">##                    intertp_cc[t, keep] += np.max(cc, axis=-1)</span>
<span class="c1">##        # make the CC matrix symmetric by averaging the lower</span>
<span class="c1">##        # and upper triangles</span>
<span class="c1">##        intertp_cc = (intertp_cc + intertp_cc.T)/2.</span>
<span class="c1">##        self.intertp_cc = pd.DataFrame(</span>
<span class="c1">##                columns=[tid for tid in self.tids],</span>
<span class="c1">##                index=[tid for tid in self.tids],</span>
<span class="c1">##                data=intertp_cc)</span>
<span class="c1">##</span>
<span class="c1">##    # -------------------------------------------</span>
<span class="c1">##    #       GrowClust related methods</span>
<span class="c1">##    # -------------------------------------------</span>
<span class="c1">##    def cross_correlate(self, duration, offset_start_S, offset_start_P,</span>
<span class="c1">##                        max_lag=20, n_stations=30):</span>
<span class="c1">##        &quot;&quot;&quot;</span>
<span class="c1">##        Create an FamilyEvents instance to access its methods.</span>
<span class="c1">##         --- Should be rewritten properly ---</span>
<span class="c1">##        &quot;&quot;&quot;</span>
<span class="c1">##        family = FamilyEvents(</span>
<span class="c1">##                self.tids[0], self.db_path_T, self.db_path_M, db_path=self.db_path)</span>
<span class="c1">##        family.detection_waveforms = \</span>
<span class="c1">##                np.float32([np.mean(stack.data, axis=0) for stack in self.stacks])</span>
<span class="c1">##        family.n_events = len(self.tids)</span>
<span class="c1">##        # trim waveforms</span>
<span class="c1">##        family.trim_waveforms(duration, offset_start_S, offset_start_P)</span>
<span class="c1">##        # cross-correlate trimmed waveforms</span>
<span class="c1">##        family.cross_correlate(</span>
<span class="c1">##                n_stations=n_stations, max_lag=max_lag, device=&#39;precise&#39;)</span>
<span class="c1">##        self.CCs_stations = family.stations</span>
<span class="c1">##        new_shape = (self.n_templates, self.n_templates, -1)</span>
<span class="c1">##        self.CCs_P = family.CCs_P.reshape(new_shape)</span>
<span class="c1">##        self.CCs_S = family.CCs_S.reshape(new_shape)</span>
<span class="c1">##        self.lags_P = family.lags_P.reshape(new_shape)</span>
<span class="c1">##        self.lags_S = family.lags_S.reshape(new_shape)</span>
<span class="c1">##        self.max_lag = max_lag</span>
<span class="c1">##        del family</span>
<span class="c1">##</span>
<span class="c1">##    def read_GrowClust_output(self, filename, path, add_results_to_db=False):</span>
<span class="c1">##        print(&#39;Reading GrowClust output from {}&#39;.</span>
<span class="c1">##                format(os.path.join(path, filename)))</span>
<span class="c1">##        ot_, lon_, lat_, dep_, err_h_, err_v_, err_t_, tids_ = \</span>
<span class="c1">##                [], [], [], [], [], [], [], []</span>
<span class="c1">##        with open(os.path.join(path, filename), &#39;r&#39;) as f:</span>
<span class="c1">##            for line in f.readlines():</span>
<span class="c1">##                line = line.split()</span>
<span class="c1">##                year, month, day, hour, minu, sec = line[:6]</span>
<span class="c1">##                # correct date if necessary</span>
<span class="c1">##                if int(day) == 0:</span>
<span class="c1">##                    date_ = udt(f&#39;{year}-{month}-01&#39;)</span>
<span class="c1">##                    date_ -= datetime.timedelta(days=1)</span>
<span class="c1">##                    year, month, day = date_.year, date_.month, date_.day</span>
<span class="c1">##                # correct seconds if necessary</span>
<span class="c1">##                sec = float(sec)</span>
<span class="c1">##                if sec == 60.:</span>
<span class="c1">##                    sec -= 0.001</span>
<span class="c1">##                ot_.append(udt(f&#39;{year}-{month}-{day}T{hour}:{minu}:{sec}&#39;).timestamp)</span>
<span class="c1">##                tid = int(line[6])</span>
<span class="c1">##                latitude, longitude, depth = list(map(float, line[7:10]))</span>
<span class="c1">##                lon_.append(longitude)</span>
<span class="c1">##                lat_.append(latitude)</span>
<span class="c1">##                dep_.append(depth)</span>
<span class="c1">##                mag = float(line[10])</span>
<span class="c1">##                q_id, cl_id, cluster_pop = list(map(int, line[11:14]))</span>
<span class="c1">##                n_pairs, n_P_dt, n_S_dt = list(map(int, line[14:17]))</span>
<span class="c1">##                rms_P, rms_S = list(map(float, line[17:19]))</span>
<span class="c1">##                err_h, err_v, err_t = list(map(float, line[19:22])) # errors in km and sec</span>
<span class="c1">##                err_h_.append(err_h)</span>
<span class="c1">##                err_v_.append(err_v)</span>
<span class="c1">##                err_t_.append(err_t)</span>
<span class="c1">##                latitude_init, longitude_init, depth_init =\</span>
<span class="c1">##                        list(map(float, line[22:25]))</span>
<span class="c1">##                tids_.append(tid)</span>
<span class="c1">##        for t, tid in enumerate(tids_):</span>
<span class="c1">##            tt = self.tids_map[tid]</span>
<span class="c1">##            self.templates[tt].relocated_latitude = lat_[t]</span>
<span class="c1">##            self.templates[tt].relocated_longitude = lon_[t]</span>
<span class="c1">##            self.templates[tt].relocated_depth = dep_[t]</span>
<span class="c1">##            self.templates[tt].reloc_err_h = err_h_[t]</span>
<span class="c1">##            self.templates[tt].reloc_err_v = err_v_[t]</span>
<span class="c1">##            if add_results_to_db:</span>
<span class="c1">##                keys = [&#39;relocated_longitude&#39;, &#39;relocated_latitude&#39;,</span>
<span class="c1">##                        &#39;relocated_depth&#39;, &#39;reloc_err_h&#39;, &#39;reloc_err_v&#39;]</span>
<span class="c1">##                with h5.File(os.path.join(</span>
<span class="c1">##                    self.db_path, self.db_path_T, f&#39;template{tid}meta.h5&#39;), &#39;a&#39;) as f:</span>
<span class="c1">##                    for key in keys:</span>
<span class="c1">##                        if key in f.keys():</span>
<span class="c1">##                            del f[key]</span>
<span class="c1">##                        f.create_dataset(key, data=getattr(self.templates[tt], key))</span>
<span class="c1">##</span>
<span class="c1">##    def write_GrowClust_stationlist(self, filename, path,</span>
<span class="c1">##                                    network_filename=&#39;all_stations.in&#39;):</span>
<span class="c1">##        &quot;&quot;&quot;</span>
<span class="c1">##        This routine assumes that cross_correlate was called</span>
<span class="c1">##        shortly before and that self.template still has the same</span>
<span class="c1">##        set of stations as the ones used for the inter-event CCs.</span>
<span class="c1">##        &quot;&quot;&quot;</span>
<span class="c1">##        net = Network(network_filename)</span>
<span class="c1">##        net.read()</span>
<span class="c1">##        subnet = net.subset(</span>
<span class="c1">##                self.CCs_stations, net.components, method=&#39;keep&#39;)</span>
<span class="c1">##        with open(os.path.join(path, filename), &#39;w&#39;) as f:</span>
<span class="c1">##            for s in range(len(subnet.stations)):</span>
<span class="c1">##                f.write(&#39;{:&lt;5}\t{:.6f}\t{:.6f}\t{:.3f}\n&#39;.</span>
<span class="c1">##                        format(subnet.stations[s], subnet.latitude[s],</span>
<span class="c1">##                               subnet.longitude[s], -1000.*subnet.depth[s]))</span>
<span class="c1">##</span>
<span class="c1">##    def write_GrowClust_eventlist(self, filename, path):</span>
<span class="c1">##        from obspy.core import UTCDateTime as udt</span>
<span class="c1">##        # fake date</span>
<span class="c1">##        ot = udt(&#39;2000-01-01&#39;)</span>
<span class="c1">##        # fake mag</span>
<span class="c1">##        mag = 1.</span>
<span class="c1">##        with open(os.path.join(path, filename), &#39;w&#39;) as f:</span>
<span class="c1">##            for t, tid in enumerate(self.tids):</span>
<span class="c1">##                # all events are given the template location</span>
<span class="c1">##                f.write(&#39;{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t0.\t0.\t0.\t{}\n&#39;.</span>
<span class="c1">##                        format(ot.year, ot.month, ot.day, ot.hour, ot.minute,</span>
<span class="c1">##                               ot.second, self.templates[t].latitude,</span>
<span class="c1">##                               self.templates[t].longitude, self.templates[t].depth,</span>
<span class="c1">##                               mag, tid))</span>
<span class="c1">##</span>
<span class="c1">##    def write_GrowClust_CC(self, filename, path, CC_threshold=0.):</span>
<span class="c1">##        if not hasattr(self, &#39;CCs_S&#39;):</span>
<span class="c1">##            print(&#39;Need to cross_correlate first.&#39;)</span>
<span class="c1">##            return</span>
<span class="c1">##        sr = self.templates[0].sampling_rate</span>
<span class="c1">##        with open(os.path.join(path, filename), &#39;w&#39;) as f:</span>
<span class="c1">##            for t1, tid1 in enumerate(self.tids):</span>
<span class="c1">##                for t2, tid2 in enumerate(self.tids):</span>
<span class="c1">##                    if t2 == t1:</span>
<span class="c1">##                        continue</span>
<span class="c1">##                    f.write(&#39;#\t{}\t{}\t0.0\n&#39;.format(tid1, tid2))</span>
<span class="c1">##                    for s in range(len(self.CCs_stations)):</span>
<span class="c1">##                        # CCs that are zero are pairs that have to be skipped</span>
<span class="c1">##                        if self.CCs_S[t1, t2, s] &gt; CC_threshold:</span>
<span class="c1">##                            f.write(&#39;  {:&gt;5} {} {:.4f} S\n&#39;.</span>
<span class="c1">##                                    format(self.CCs_stations[s],</span>
<span class="c1">##                                           self.lags_S[t1, t2, s]/sr,</span>
<span class="c1">##                                           self.CCs_S[t1, t2, s]))</span>
<span class="c1">##                        if self.CCs_P[t1, t2, s] &gt; CC_threshold:</span>
<span class="c1">##                            f.write(&#39;  {:&gt;5} {} {:.4f} P\n&#39;.</span>
<span class="c1">##                                    format(self.CCs_stations[s],</span>
<span class="c1">##                                           self.lags_P[t1, t2, s]/sr,</span>
<span class="c1">##                                           self.CCs_P[t1, t2, s]))</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Eric Beauce, William B. Frank.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>