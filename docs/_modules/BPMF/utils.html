<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BPMF.utils &mdash; BPMF 2.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script src="../../_static/documentation_options.js?v=51b770b3"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            BPMF
              <img src="../../_static/bpmf.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../updates.html">Updates</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BPMF</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">BPMF.utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for BPMF.utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">h5py</span> <span class="k">as</span> <span class="nn">h5</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pathlib</span>

<span class="kn">import</span> <span class="nn">obspy</span> <span class="k">as</span> <span class="nn">obs</span>
<span class="kn">from</span> <span class="nn">obspy.core</span> <span class="kn">import</span> <span class="n">UTCDateTime</span> <span class="k">as</span> <span class="n">udt</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span> <span class="k">as</span> <span class="n">give_time</span>

<span class="kn">from</span> <span class="nn">.config</span> <span class="kn">import</span> <span class="n">cfg</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">dataset</span>


<span class="c1"># -------------------------------------------------</span>
<span class="c1">#              Filtering routines</span>
<span class="c1"># -------------------------------------------------</span>


<div class="viewcode-block" id="bandpass_filter">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.bandpass_filter">[docs]</a>
<span class="k">def</span> <span class="nf">bandpass_filter</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="n">filter_order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">freqmin</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">MIN_FREQ_HZ</span><span class="p">,</span>
    <span class="n">freqmax</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">MAX_FREQ_HZ</span><span class="p">,</span>
    <span class="n">f_Nyq</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">SAMPLING_RATE_HZ</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">taper_alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">zerophase</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    X: (n x m) numpy array,</span>
<span class="sd">        Numpy array of n observations of m samples each.</span>
<span class="sd">        Use X.reshape(1, -1) if you want to process a</span>
<span class="sd">        single observation.</span>
<span class="sd">    filter_order: integer scalar, default to 4,</span>
<span class="sd">        Order/number of corners of the bandpass filter.</span>
<span class="sd">    freqmin: scalar float, default to cfg.MIN_FREQ_HZ,</span>
<span class="sd">        Low frequency cutoff.</span>
<span class="sd">    freqmax: scalar float, default to cfg.MAX_FREQ_HZ,</span>
<span class="sd">        High frequency cutoff.</span>
<span class="sd">    f_Nyq: scalar float, default to cfg.SAMPLING_RATE_HZ/2,</span>
<span class="sd">        Nyquist frequency of the data. By definition,</span>
<span class="sd">        the Nyquist frequency is half the sampling rate.</span>
<span class="sd">    taper_alpha: scalar float, default to 0.01,</span>
<span class="sd">        Defines the sharpness of the edges of the taper</span>
<span class="sd">        function. We use the tukey window function. The</span>
<span class="sd">        default value of 0.01 produces sharp windows.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    filtered_X: (n x m) numpy array,</span>
<span class="sd">        The input array X after filtering.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">iirfilter</span><span class="p">,</span> <span class="n">tukey</span>

    <span class="c1"># from scipy.signal import lfilter</span>
    <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">zpk2sos</span><span class="p">,</span> <span class="n">sosfilt</span>
    <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">detrend</span>

    <span class="c1"># detrend the data</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># design the taper function</span>
    <span class="n">taper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">tukey</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">taper_alpha</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">taper</span> <span class="o">=</span> <span class="n">taper</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

    <span class="c1"># design the filter</span>
    <span class="c1"># filter_num, filter_den = iirfilter(filter_order,</span>
    <span class="c1">#                                   [freqmin/f_Nyq, freqmax/f_Nyq],</span>
    <span class="c1">#                                   btype=&#39;bandpass&#39;,</span>
    <span class="c1">#                                   ftype=&#39;butter&#39;,</span>
    <span class="c1">#                                   output=&#39;ba&#39;)</span>
    <span class="c1"># filtered_X = lfilter(filter_num,</span>
    <span class="c1">#                     filter_den,</span>
    <span class="c1">#                     X*taper)</span>
    <span class="c1">## apply the filter a second time to have a</span>
    <span class="c1">## zero phase filter</span>
    <span class="c1"># filtered_X = lfilter(filter_num,</span>
    <span class="c1">#                     filter_den,</span>
    <span class="c1">#                     X[::-1])[::-1]</span>
    <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">iirfilter</span><span class="p">(</span>
        <span class="n">filter_order</span><span class="p">,</span>
        <span class="p">[</span><span class="n">freqmin</span> <span class="o">/</span> <span class="n">f_Nyq</span><span class="p">,</span> <span class="n">freqmax</span> <span class="o">/</span> <span class="n">f_Nyq</span><span class="p">],</span>
        <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;bandpass&quot;</span><span class="p">,</span>
        <span class="n">ftype</span><span class="o">=</span><span class="s2">&quot;butter&quot;</span><span class="p">,</span>
        <span class="n">output</span><span class="o">=</span><span class="s2">&quot;zpk&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">zpk2sos</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">filtered_X</span> <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">X</span> <span class="o">*</span> <span class="n">taper</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">zerophase</span><span class="p">:</span>
        <span class="n">filtered_X</span> <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">filtered_X</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">filtered_X</span></div>



<div class="viewcode-block" id="lowpass_chebyshev_I">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.lowpass_chebyshev_I">[docs]</a>
<span class="k">def</span> <span class="nf">lowpass_chebyshev_I</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">freqmax</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">max_ripple</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">zerophase</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">cheby1</span><span class="p">,</span> <span class="n">sosfilt</span>

    <span class="n">nyquist</span> <span class="o">=</span> <span class="n">sampling_rate</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="n">sos</span> <span class="o">=</span> <span class="n">cheby1</span><span class="p">(</span>
        <span class="n">order</span><span class="p">,</span>
        <span class="n">max_ripple</span><span class="p">,</span>
        <span class="n">freqmax</span> <span class="o">/</span> <span class="n">nyquist</span><span class="p">,</span>
        <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;lowpass&quot;</span><span class="p">,</span>
        <span class="n">output</span><span class="o">=</span><span class="s2">&quot;sos&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">zerophase</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">X</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">X</span></div>



<div class="viewcode-block" id="lowpass_chebyshev_II">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.lowpass_chebyshev_II">[docs]</a>
<span class="k">def</span> <span class="nf">lowpass_chebyshev_II</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">freqmax</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_attenuation_dB</span><span class="o">=</span><span class="mf">40.0</span><span class="p">,</span> <span class="n">zerophase</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">cheby2</span><span class="p">,</span> <span class="n">sosfilt</span>

    <span class="n">nyquist</span> <span class="o">=</span> <span class="n">sampling_rate</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="n">sos</span> <span class="o">=</span> <span class="n">cheby2</span><span class="p">(</span>
        <span class="n">order</span><span class="p">,</span>
        <span class="n">min_attenuation_dB</span><span class="p">,</span>
        <span class="c1"># freqmax/nyquist,</span>
        <span class="n">freqmax</span><span class="p">,</span>
        <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">fs</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
        <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;lowpass&quot;</span><span class="p">,</span>
        <span class="n">output</span><span class="o">=</span><span class="s2">&quot;sos&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">zerophase</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">X</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">X</span></div>



<div class="viewcode-block" id="preprocess_stream">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.preprocess_stream">[docs]</a>
<span class="k">def</span> <span class="nf">preprocess_stream</span><span class="p">(</span>
    <span class="n">stream</span><span class="p">,</span>
    <span class="n">freqmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">freqmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">target_SR</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">remove_response</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">remove_sensitivity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_resp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">target_duration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">target_starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">target_endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">minimum_length</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span>
    <span class="n">minimum_chunk_duration</span><span class="o">=</span><span class="mf">600.0</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">SR_decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">decimation_method</span><span class="o">=</span><span class="s2">&quot;simple&quot;</span><span class="p">,</span>
    <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;VEL&quot;</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preprocesses a stream of seismic data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stream : obspy.Stream</span>
<span class="sd">        A stream of seismic data.</span>
<span class="sd">    freqmin : float, optional</span>
<span class="sd">        The minimum frequency to bandpass filter the data.</span>
<span class="sd">    freqmax : float, optional</span>
<span class="sd">        The maximum frequency to bandpass filter the data.</span>
<span class="sd">    target_SR : float, optional</span>
<span class="sd">        The target sampling rate of the data.</span>
<span class="sd">    remove_response : bool, optional</span>
<span class="sd">        Whether to remove instrument response from the data.</span>
<span class="sd">    remove_sensitivity : bool, optional</span>
<span class="sd">        Whether to remove instrument sensitivity from the data.</span>
<span class="sd">    plot_resp : bool, optional</span>
<span class="sd">        Whether to plot the instrument response of the data.</span>
<span class="sd">    target_duration : float, optional</span>
<span class="sd">        The target duration of the data.</span>
<span class="sd">    target_starttime : obspy.UTCDateTime, optional</span>
<span class="sd">        The start time of the target data.</span>
<span class="sd">    target_endtime : obspy.UTCDateTime, optional</span>
<span class="sd">        The end time of the target data.</span>
<span class="sd">    minimum_length : float, optional</span>
<span class="sd">        The minimum length of the data as a fraction of the target duration.</span>
<span class="sd">    minimum_chunk_duration : float, optional</span>
<span class="sd">        The minimum duration of each data chunk.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Whether to print verbose output during processing.</span>
<span class="sd">    SR_decimals : int, optional</span>
<span class="sd">        The number of decimals to round sampling rate values to.</span>
<span class="sd">    decimation_method : str, optional</span>
<span class="sd">        The method used for decimation.</span>
<span class="sd">    unit : str, optional</span>
<span class="sd">        The unit of the data.</span>
<span class="sd">    n_threads : int, optional</span>
<span class="sd">        The number of threads over which preprocesing is parallelized.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Other keyword arguments to pass to the function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    obspy.Stream</span>
<span class="sd">        A preprocessed stream of seismic data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

    <span class="n">data_preprocessor</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">_preprocess_stream</span><span class="p">,</span>
        <span class="n">freqmin</span><span class="o">=</span><span class="n">freqmin</span><span class="p">,</span>
        <span class="n">freqmax</span><span class="o">=</span><span class="n">freqmax</span><span class="p">,</span>
        <span class="n">target_SR</span><span class="o">=</span><span class="n">target_SR</span><span class="p">,</span>
        <span class="n">remove_response</span><span class="o">=</span><span class="n">remove_response</span><span class="p">,</span>
        <span class="n">remove_sensitivity</span><span class="o">=</span><span class="n">remove_sensitivity</span><span class="p">,</span>
        <span class="n">plot_resp</span><span class="o">=</span><span class="n">plot_resp</span><span class="p">,</span>
        <span class="n">target_duration</span><span class="o">=</span><span class="n">target_duration</span><span class="p">,</span>
        <span class="n">target_starttime</span><span class="o">=</span><span class="n">target_starttime</span><span class="p">,</span>
        <span class="n">target_endtime</span><span class="o">=</span><span class="n">target_endtime</span><span class="p">,</span>
        <span class="n">minimum_length</span><span class="o">=</span><span class="n">minimum_length</span><span class="p">,</span>
        <span class="n">minimum_chunk_duration</span><span class="o">=</span><span class="n">minimum_chunk_duration</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">SR_decimals</span><span class="o">=</span><span class="n">SR_decimals</span><span class="p">,</span>
        <span class="n">decimation_method</span><span class="o">=</span><span class="n">decimation_method</span><span class="p">,</span>
        <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">n_threads</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>

        <span class="c1">#for tr in stream:</span>
        <span class="c1">#    tr.stats.sampling_rate = np.round(</span>
        <span class="c1">#            tr.stats.sampling_rate, decimals=SR_decimals</span>
        <span class="c1">#            )</span>
        <span class="n">stream</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_premerge</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">n_threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="c1"># we need to group traces from same channels, therefore,</span>
            <span class="c1"># we use merge to fill gaps with masked arrays</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>
            <span class="n">preprocessed_stream</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">data_preprocessor</span><span class="p">,</span> <span class="n">stream</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">preprocessed_stream</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">tr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">preprocessed_stream</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">preprocessed_stream</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">preprocessed_stream</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">))</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obs</span><span class="o">.</span><span class="n">Stream</span><span class="p">(</span><span class="n">preprocessed_stream</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data_preprocessor</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_premerge</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Clean-up stream before calling merge.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># first, make a list of all stations in stream</span>
    <span class="n">stations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
        <span class="n">stations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">)</span>
    <span class="n">stations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">stations</span><span class="p">))</span>
    <span class="c1"># second, make a list of all channel types for each station</span>
    <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">station</span><span class="p">)</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
            <span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">channels</span><span class="p">))</span>
        <span class="c1"># third, for each channel type, make a list of all sampling</span>
        <span class="c1"># rates and detect anomalies if there are more than one single</span>
        <span class="c1"># sampling rate</span>
        <span class="n">sampling_rates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cha</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="n">st_cha</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">channel</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cha</span><span class="si">}</span><span class="s2">*&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st_cha</span><span class="p">:</span>
                <span class="n">sampling_rates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
        <span class="n">unique_sampling_rates</span><span class="p">,</span> <span class="n">sampling_rates_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="n">sampling_rates</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="c1"># if more than one sampling rate, remove the traces with the least</span>
        <span class="c1"># represented sampling rate</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_sampling_rates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sampling_rates_counts</span><span class="p">[</span><span class="n">unique_sampling_rates</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">ref_sampling_rate</span> <span class="o">=</span> <span class="n">unique_sampling_rates</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ref_sampling_rate</span> <span class="o">=</span> <span class="n">unique_sampling_rates</span><span class="p">[</span><span class="n">sampling_rates_counts</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
            <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">!=</span> <span class="n">ref_sampling_rate</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removing </span><span class="si">{</span><span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> because not desired sampling rate &quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">ref_sampling_rate</span><span class="si">}</span><span class="s2">)&quot;</span>  <span class="p">)</span>
                    <span class="n">stream</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stream</span><span class="p">,</span> <span class="n">stations</span>


<span class="k">def</span> <span class="nf">_preprocess_stream</span><span class="p">(</span>
    <span class="n">stream</span><span class="p">,</span>
    <span class="n">freqmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">freqmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">target_SR</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">remove_response</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">remove_sensitivity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_resp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">target_duration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">target_starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">target_endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">minimum_length</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span>
    <span class="n">minimum_chunk_duration</span><span class="o">=</span><span class="mf">600.0</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">SR_decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">decimation_method</span><span class="o">=</span><span class="s2">&quot;simple&quot;</span><span class="p">,</span>
    <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;VEL&quot;</span><span class="p">,</span>
    <span class="n">pre_filt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See `preprocess_stream`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">obs</span><span class="o">.</span><span class="n">Trace</span><span class="p">):</span>
        <span class="c1"># user gave a single trace instead of a stream</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">Stream</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
    <span class="n">preprocessed_stream</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Input data is empty!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">preprocessed_stream</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target_duration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">target_starttime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">target_endtime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="n">target_duration</span> <span class="o">=</span> <span class="n">target_endtime</span> <span class="o">-</span> <span class="n">target_starttime</span>
    <span class="c1"># find errors in sampling rate metadata</span>
    <span class="c1"># first, round sampling rates that may be misrepresented in floating point numbers</span>
    <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">SR_decimals</span><span class="p">)</span>
        <span class="c1"># and remove the short chunks now to gain time</span>
        <span class="c1"># (only works if the traces do not come with masked arrays)</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span> <span class="o">&lt;</span> <span class="n">minimum_chunk_duration</span><span class="p">:</span>
            <span class="c1"># don&#39;t include this chunk</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Removed all traces because they were too short.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">preprocessed_stream</span>
    <span class="n">stream</span><span class="p">,</span> <span class="n">stations</span> <span class="o">=</span> <span class="n">_premerge</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="c1"># start by cleaning the gaps if there are any</span>
    <span class="c1"># start with a simple merge to unite data from same channels into unique</span>
    <span class="c1"># trace but without losing information on gaps</span>
    <span class="n">stream</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
        <span class="n">trace_id</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">id</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Problem with </span><span class="si">{</span><span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> (detected NaNs)!&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="n">T2</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="n">trace_duration</span> <span class="o">=</span> <span class="n">T2</span> <span class="o">-</span> <span class="n">T1</span>
        <span class="k">if</span> <span class="n">trace_duration</span> <span class="o">&lt;</span> <span class="n">minimum_length</span> <span class="o">*</span> <span class="n">target_duration</span><span class="p">:</span>
            <span class="c1"># don&#39;t include this trace</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too much gap duration on </span><span class="si">{</span><span class="n">trace_id</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Duration is: </span><span class="si">{</span><span class="n">trace_duration</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s (min is </span><span class="si">{</span><span class="n">minimum_length</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">target_duration</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s)&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="c1"># split will lose information about start and end times</span>
        <span class="c1"># if the start or the end is masked</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">udt</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span> <span class="o">&lt;</span> <span class="n">minimum_chunk_duration</span><span class="p">:</span>
                <span class="c1"># don&#39;t include this chunk</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># all chunks were too short</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All chunks within </span><span class="si">{</span><span class="n">trace_id</span><span class="si">}</span><span class="s2"> were too short.&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="c1"># measure gap duration</span>
        <span class="n">gap_duration</span> <span class="o">=</span> <span class="n">target_duration</span> <span class="o">-</span> <span class="n">trace_duration</span>
        <span class="k">for</span> <span class="n">gap</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">get_gaps</span><span class="p">():</span>
            <span class="n">gap_duration</span> <span class="o">+=</span> <span class="n">gap</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">target_duration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">gap_duration</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">minimum_length</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_duration</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too much gap duration on </span><span class="si">{</span><span class="n">trace_id</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Duration is: </span><span class="si">{</span><span class="n">trace_duration</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s (min is </span><span class="si">{</span><span class="p">(</span><span class="mf">1.</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">minimum_length</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">target_duration</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s)&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="s2">&quot;constant&quot;</span><span class="p">)</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="s2">&quot;linear&quot;</span><span class="p">)</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">taper</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;cosine&quot;</span><span class="p">)</span>
        <span class="c1"># it&#39;s now safe to fill the gaps with zeros</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">T1</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">T2</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">preprocessed_stream</span> <span class="o">+=</span> <span class="n">tr</span>
    <span class="c1"># if the trace came as separated segments without masked</span>
    <span class="c1"># elements, it is necessary to merge the stream</span>
    <span class="n">preprocessed_stream</span> <span class="o">=</span> <span class="n">preprocessed_stream</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="c1"># delete the original data to save memory</span>
    <span class="k">del</span> <span class="n">stream</span>
    <span class="c1"># resample if necessary:</span>
    <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">preprocessed_stream</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">target_SR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">sr_ratio</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">/</span> <span class="n">target_SR</span>
        <span class="k">if</span> <span class="n">sr_ratio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">lowpass_chebyshev_II</span><span class="p">(</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="mf">0.49</span> <span class="o">*</span> <span class="n">target_SR</span><span class="p">,</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;antialiasing_filter_order&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                <span class="n">min_attenuation_dB</span><span class="o">=</span><span class="mf">40.0</span><span class="p">,</span>
                <span class="n">zerophase</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">sr_ratio</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">sr_ratio</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="n">decimation_method</span> <span class="o">==</span> <span class="s2">&quot;simple&quot;</span><span class="p">:</span>
                <span class="c1"># tr&#39;s sampling rate is an integer</span>
                <span class="c1"># multiple of target_SR</span>
                <span class="c1"># do not re-filter the data</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">decimate</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sr_ratio</span><span class="p">),</span> <span class="n">no_filter</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">decimation_method</span> <span class="o">==</span> <span class="s2">&quot;fourier&quot;</span><span class="p">:</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">target_SR</span><span class="p">,</span> <span class="n">no_filter</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">target_SR</span><span class="p">,</span> <span class="n">no_filter</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sr_ratio</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sampling rate is too high on </span><span class="si">{tr.id}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
            <span class="n">preprocessed_stream</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="c1"># remove response if requested</span>
    <span class="k">if</span> <span class="n">remove_response</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">preprocessed_stream</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="s2">&quot;response&quot;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find the instrument response for </span><span class="si">{</span><span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">pre_filt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">T_max</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="o">*</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
                <span class="n">T_min</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
                <span class="n">f_min</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">T_max</span>
                <span class="n">f_max</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">T_min</span><span class="p">)</span>
                <span class="n">pre_filt</span> <span class="o">=</span> <span class="p">[</span><span class="n">f_min</span><span class="p">,</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">f_min</span><span class="p">,</span> <span class="mf">0.90</span> <span class="o">*</span> <span class="n">f_max</span><span class="p">,</span> <span class="mf">0.97</span> <span class="o">*</span> <span class="n">f_max</span><span class="p">]</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">remove_response</span><span class="p">(</span><span class="n">pre_filt</span><span class="o">=</span><span class="n">pre_filt</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot_resp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">remove_sensitivity</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">preprocessed_stream</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="s2">&quot;response&quot;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find the instrument response for </span><span class="si">{</span><span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">remove_sensitivity</span><span class="p">()</span>
    <span class="c1"># filter</span>
    <span class="n">preprocessed_stream</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="s2">&quot;constant&quot;</span><span class="p">)</span>
    <span class="n">preprocessed_stream</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="s2">&quot;linear&quot;</span><span class="p">)</span>
    <span class="n">preprocessed_stream</span><span class="o">.</span><span class="n">taper</span><span class="p">(</span><span class="mf">0.02</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;cosine&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">freqmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">freqmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># no filtering</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">freqmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># lowpass filtering</span>
        <span class="n">preprocessed_stream</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s2">&quot;lowpass&quot;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freqmax</span><span class="p">,</span> <span class="n">zerophase</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">freqmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># highpass filtering</span>
        <span class="n">preprocessed_stream</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s2">&quot;highpass&quot;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freqmin</span><span class="p">,</span> <span class="n">zerophase</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># bandpass filtering</span>
        <span class="n">preprocessed_stream</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="s2">&quot;bandpass&quot;</span><span class="p">,</span> <span class="n">freqmin</span><span class="o">=</span><span class="n">freqmin</span><span class="p">,</span> <span class="n">freqmax</span><span class="o">=</span><span class="n">freqmax</span><span class="p">,</span> <span class="n">zerophase</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="c1"># adjust duration</span>
    <span class="k">if</span> <span class="n">target_starttime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">preprocessed_stream</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">target_starttime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">target_endtime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">preprocessed_stream</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">endtime</span><span class="o">=</span><span class="n">target_endtime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">target_duration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">preprocessed_stream</span><span class="p">)):</span>
            <span class="n">n_samples</span> <span class="o">=</span> <span class="n">sec_to_samp</span><span class="p">(</span>
                <span class="n">target_duration</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">preprocessed_stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span>
            <span class="p">)</span>
            <span class="n">preprocessed_stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">preprocessed_stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="n">n_samples</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">preprocessed_stream</span>


<span class="c1"># -------------------------------------------------</span>
<span class="c1">#       Loading travel-time data</span>
<span class="c1"># -------------------------------------------------</span>


<div class="viewcode-block" id="get_moveout_array">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.get_moveout_array">[docs]</a>
<span class="k">def</span> <span class="nf">get_moveout_array</span><span class="p">(</span><span class="n">tts</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">phases</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Format the travel times into a numpy.ndarray.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    tts: dictionary</span>
<span class="sd">        Output of `load_travel_times`.</span>
<span class="sd">    stations: list of strings</span>
<span class="sd">        List of station names. Determine the order in which travel times are</span>
<span class="sd">        written in the output array.</span>
<span class="sd">    phases: list of strings</span>
<span class="sd">        List of seismic phases. Determine the order in which travel times are</span>
<span class="sd">        writtem in the output array.</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">    moveout_arr: (n_sources, n_stations, n_phases) numpy.ndarray</span>
<span class="sd">        Numpy array of travel times, in the order specified by `stations` and</span>
<span class="sd">        `phases`. At this stage, moveout_arr should still be in units of</span>
<span class="sd">        seconds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_stations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">)</span>
    <span class="n">n_phases</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span>
    <span class="n">moveout_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tts</span><span class="p">[</span><span class="n">ph</span><span class="p">][</span><span class="n">sta</span><span class="p">]</span> <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">stations</span> <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">moveout_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_stations</span><span class="p">,</span> <span class="n">n_phases</span><span class="p">)</span></div>



<div class="viewcode-block" id="load_travel_times">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.load_travel_times">[docs]</a>
<span class="k">def</span> <span class="nf">load_travel_times</span><span class="p">(</span>
    <span class="n">path</span><span class="p">,</span> <span class="n">phases</span><span class="p">,</span> <span class="n">source_indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stations</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load the travel times from `path`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    path: string</span>
<span class="sd">        Path to the file with the travel times.</span>
<span class="sd">    phases: list of strings</span>
<span class="sd">        List of the seismic phases to load.</span>
<span class="sd">    source_indexes: (n_sources,) int numpy.ndarray, default to None</span>
<span class="sd">        If not None, this is used to select a subset of sources from the grid.</span>
<span class="sd">    return_coords: boolean, default to False</span>
<span class="sd">        If True, also return the source coordinates.</span>
<span class="sd">    stations: list of strings, default to None</span>
<span class="sd">        If not None, only read the travel times for stations in `stations`.</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">    tts: dictionary</span>
<span class="sd">        Dictionary with one field per phase. `tts[phase_n]` is itself</span>
<span class="sd">        a dictionary with one field per station.</span>
<span class="sd">    source_coords: dictionary, optional</span>
<span class="sd">        Returned only if `return_coords` is True. This is a dictionary with</span>
<span class="sd">        three (n_sources,) numpy.ndarray: `source_coords[&#39;latitude&#39;]`,</span>
<span class="sd">        `source_coords[&#39;longitude&#39;]`, `source_coords[&#39;depth&#39;]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">phases</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">stations</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;source_coordinates&quot;</span><span class="p">][</span><span class="s2">&quot;depth&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;tt_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">stations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sta</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># flatten the lon/lat/dep grid as we work with</span>
                <span class="c1"># flat source indexes</span>
                <span class="k">if</span> <span class="n">source_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># select a subset of the source grid</span>
                    <span class="n">source_indexes_unravelled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span>
                        <span class="n">source_indexes</span><span class="p">,</span> <span class="n">grid_shape</span>
                    <span class="p">)</span>
                    <span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                    <span class="n">selection</span><span class="p">[</span><span class="n">source_indexes_unravelled</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">tts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="n">ph</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;tt_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">][</span><span class="n">selection</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sta</span><span class="p">,</span> <span class="n">ph</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;tt_</span><span class="si">{</span><span class="n">ph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="n">sta</span><span class="p">][()]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">return_coords</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">source_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">source_indexes_unravelled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">source_indexes</span><span class="p">,</span> <span class="n">grid_shape</span><span class="p">)</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">selection</span><span class="p">[</span><span class="n">source_indexes_unravelled</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">source_coords</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">source_indexes</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;source_coordinates&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">source_coords</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">source_indexes</span><span class="p">,</span> <span class="n">coord</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;source_coordinates&quot;</span><span class="p">][</span>
                        <span class="n">coord</span>
                    <span class="p">][</span><span class="n">selection</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">source_coords</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">],</span>
                    <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;source_coordinates&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">source_coords</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;source_coordinates&quot;</span><span class="p">][</span><span class="n">coord</span><span class="p">][()]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">return_coords</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tts</span><span class="p">,</span> <span class="n">source_coords</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tts</span></div>



<span class="c1"># -------------------------------------------------</span>
<span class="c1">#             Stacking routines</span>
<span class="c1"># -------------------------------------------------</span>


<div class="viewcode-block" id="SVDWF">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.SVDWF">[docs]</a>
<span class="k">def</span> <span class="nf">SVDWF</span><span class="p">(</span>
    <span class="n">matrix</span><span class="p">,</span>
    <span class="n">expl_var</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
    <span class="n">max_singular_values</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">freqmin</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">MIN_FREQ_HZ</span><span class="p">,</span>
    <span class="n">freqmax</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">MAX_FREQ_HZ</span><span class="p">,</span>
    <span class="n">sampling_rate</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">SAMPLING_RATE_HZ</span><span class="p">,</span>
    <span class="n">wiener_filter_colsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of the Singular Value Decomposition Wiener Filter (SVDWF)</span>
<span class="sd">    described in Moreau et al 2017.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    matrix: (n x m) numpy array</span>
<span class="sd">        n is the number of events, m is the number of time samples</span>
<span class="sd">        per event.</span>
<span class="sd">    n_singular_values: scalar float</span>
<span class="sd">        Number of singular values to retain in the</span>
<span class="sd">        SVD decomposition of matrix.</span>
<span class="sd">    max_freq: scalar float, default to cfg.MAX_FREQ_HZ</span>
<span class="sd">        The maximum frequency of the data, or maximum target</span>
<span class="sd">        frequency, is used to determined the size in the</span>
<span class="sd">        time axis of the Wiener filter.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    filtered_data: (n x m) numpy array</span>
<span class="sd">        The matrix filtered through the SVD procedure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">svd</span>
    <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">wiener</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Problem while computing the svd...!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wiener_filter_colsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wiener_filter_colsize</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># wiener_filter = [wiener_filter_colsize, int(cfg.SAMPLING_RATE_HZ/max_freq)]</span>
    <span class="n">wiener_filter</span> <span class="o">=</span> <span class="p">[</span><span class="n">wiener_filter_colsize</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Vt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1"># select the number of singular values</span>
    <span class="c1"># in order to explain 100xn_singular_values%</span>
    <span class="c1"># of the variance of the matrix</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">var</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="c1"># only zeros in matrix</span>
        <span class="k">return</span> <span class="n">filtered_data</span>
    <span class="n">var</span> <span class="o">/=</span> <span class="n">var</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_singular_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">var</span> <span class="o">&gt;=</span> <span class="n">expl_var</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">n_singular_values</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_singular_values</span><span class="p">,</span> <span class="n">n_singular_values</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_singular_values</span><span class="p">)):</span>
        <span class="n">s_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">s_n</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">projection_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s_n</span><span class="p">),</span> <span class="n">Vt</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">wiener_filter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">wiener_filter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># no wiener filtering</span>
            <span class="n">filtered_projection</span> <span class="o">=</span> <span class="n">projection_n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the following application of Wiener filtering is questionable: because each projection in this loop is a projection</span>
            <span class="c1"># onto a vector space with one dimension, all the waveforms are colinear: they just differ by an amplitude factor (but same shape).</span>
            <span class="n">filtered_projection</span> <span class="o">=</span> <span class="n">wiener</span><span class="p">(</span>
                <span class="n">projection_n</span><span class="p">,</span>
                <span class="c1"># mysize=[max(2, int(U.shape[0]/10)), int(cfg.SAMPLING_RATE_HZ/freqmax)]</span>
                <span class="n">mysize</span><span class="o">=</span><span class="n">wiener_filter</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># filtered_projection = projection_n</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">filtered_projection</span><span class="o">.</span><span class="n">max</span><span class="p">()):</span>
            <span class="k">continue</span>
        <span class="n">filtered_data</span> <span class="o">+=</span> <span class="n">filtered_projection</span>
    <span class="k">if</span> <span class="n">wiener_filter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">wiener_filter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># no wiener filtering</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">wiener</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">,</span> <span class="n">mysize</span><span class="o">=</span><span class="n">wiener_filter</span><span class="p">)</span>
    <span class="c1"># remove nans or infs</span>
    <span class="n">filtered_data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">filtered_data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1"># SVD adds noise in the low and the high frequencies</span>
    <span class="c1"># refiltering the SVD-filtered data seems necessary</span>
    <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">bandpass_filter</span><span class="p">(</span>
        <span class="n">filtered_data</span><span class="p">,</span>
        <span class="n">filter_order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">freqmin</span><span class="o">=</span><span class="n">freqmin</span><span class="p">,</span>
        <span class="n">freqmax</span><span class="o">=</span><span class="n">freqmax</span><span class="p">,</span>
        <span class="n">f_Nyq</span><span class="o">=</span><span class="n">sampling_rate</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">filtered_data</span></div>



<div class="viewcode-block" id="fetch_detection_waveforms">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.fetch_detection_waveforms">[docs]</a>
<span class="k">def</span> <span class="nf">fetch_detection_waveforms</span><span class="p">(</span>
    <span class="n">tid</span><span class="p">,</span>
    <span class="n">db_path_T</span><span class="p">,</span>
    <span class="n">db_path_M</span><span class="p">,</span>
    <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">INPUT_PATH</span><span class="p">,</span>
    <span class="n">best_CC</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_n_events</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">norm_rms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">ordering</span><span class="o">=</span><span class="s2">&quot;correlation_coefficients&quot;</span><span class="p">,</span>
    <span class="n">flip_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">selection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_event_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">unique_events</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">catalog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">groupby</span>
    <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>

    <span class="k">if</span> <span class="n">catalog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cat</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">Catalog</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;multiplets</span><span class="si">{</span><span class="n">tid</span><span class="si">}</span><span class="s2">catalog.h5&quot;</span><span class="p">,</span> <span class="n">db_path_M</span><span class="p">)</span>
        <span class="n">cat</span><span class="o">.</span><span class="n">read_data</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cat</span> <span class="o">=</span> <span class="n">catalog</span>
    <span class="n">CC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">correlation_coefficients</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">max_n_events</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">max_n_events</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_n_events</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">CC</span><span class="p">))</span>
        <span class="n">CC_thres</span> <span class="o">=</span> <span class="n">CC</span><span class="p">[</span><span class="o">-</span><span class="n">max_n_events</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">best_CC</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span>
            <span class="n">CC_thres</span> <span class="o">=</span> <span class="n">CC</span><span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">70</span><span class="p">:</span>
            <span class="n">CC_thres</span> <span class="o">=</span> <span class="n">CC</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mf">7.0</span> <span class="o">/</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">CC</span><span class="p">))]</span>  <span class="c1"># the best 30%</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
            <span class="n">CC_thres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span>  <span class="c1"># the best 50%</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">CC_thres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">CC</span><span class="p">,</span> <span class="mf">33.0</span><span class="p">)</span>  <span class="c1"># the best 66% detections</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">CC_thres</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">CC_thres</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">correlation_coefficients</span> <span class="o">&gt;=</span> <span class="n">CC_thres</span>
        <span class="k">if</span> <span class="n">unique_events</span><span class="p">:</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span> <span class="o">&amp;</span> <span class="n">cat</span><span class="o">.</span><span class="n">unique_events</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">return_event_ids</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">filenames</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">filenames</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span>
    <span class="n">CCs</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">correlation_coefficients</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span>
    <span class="n">event_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">origin_times</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)[</span><span class="n">selection</span><span class="p">]</span>
    <span class="n">detection_waveforms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">give_time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">filename</span><span class="p">,</span> <span class="n">rows</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">indices</span><span class="p">),</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
        <span class="n">full_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">db_path_M</span><span class="p">,</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;wav.h5&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">full_filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">detection_waveforms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">tid</span><span class="p">)][</span><span class="s2">&quot;waveforms&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
    <span class="n">detection_waveforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">detection_waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">norm_rms</span><span class="p">:</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">detection_waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">norm</span><span class="p">[</span><span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">detection_waveforms</span> <span class="o">/=</span> <span class="n">norm</span>
    <span class="n">n_detections</span> <span class="o">=</span> <span class="n">detection_waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">give_time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2"> s to retrieve the waveforms.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ordering</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># use the requested attribute to order the detections</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">ordering</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The catalog does not have the </span><span class="si">{</span><span class="n">ordering</span><span class="si">}</span><span class="s2"> attribute, &quot;</span>
                <span class="s2">&quot;return by chronological order.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">ordering</span><span class="p">)[</span><span class="n">selection</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">flip_order</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">detection_waveforms</span> <span class="o">=</span> <span class="n">detection_waveforms</span><span class="p">[</span><span class="n">order</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
            <span class="n">CCs</span> <span class="o">=</span> <span class="n">CCs</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
            <span class="n">event_ids</span> <span class="o">=</span> <span class="n">event_ids</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_event_ids</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">detection_waveforms</span><span class="p">,</span> <span class="n">CCs</span><span class="p">,</span> <span class="n">event_ids</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">detection_waveforms</span><span class="p">,</span> <span class="n">CCs</span></div>



<div class="viewcode-block" id="fetch_detection_waveforms_refilter">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.fetch_detection_waveforms_refilter">[docs]</a>
<span class="k">def</span> <span class="nf">fetch_detection_waveforms_refilter</span><span class="p">(</span>
    <span class="n">tid</span><span class="p">,</span>
    <span class="n">db_path_T</span><span class="p">,</span>
    <span class="n">db_path_M</span><span class="p">,</span>
    <span class="n">net</span><span class="p">,</span>
    <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">INPUT_PATH</span><span class="p">,</span>
    <span class="n">best_CC</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_n_events</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">norm_rms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">freqmin</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">freqmax</span><span class="o">=</span><span class="mf">12.0</span><span class="p">,</span>
    <span class="n">target_SR</span><span class="o">=</span><span class="mf">50.0</span><span class="p">,</span>
    <span class="n">integrate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">t0</span><span class="o">=</span><span class="s2">&quot;detection_time&quot;</span><span class="p">,</span>
    <span class="n">ordering</span><span class="o">=</span><span class="s2">&quot;correlation_coefficients&quot;</span><span class="p">,</span>
    <span class="n">flip_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">preprocess_kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="c1"># sys.path.append(os.path.join(cfg.base, &#39;earthquake_location_eb&#39;))</span>
    <span class="c1"># import relocation_utils</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">event_extraction</span>

    <span class="n">cat</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">Catalog</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;multiplets</span><span class="si">{</span><span class="n">tid</span><span class="si">}</span><span class="s2">catalog.h5&quot;</span><span class="p">,</span> <span class="n">db_path_M</span><span class="p">)</span>
    <span class="n">cat</span><span class="o">.</span><span class="n">read_data</span><span class="p">()</span>
    <span class="n">CC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">correlation_coefficients</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="n">T</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">Template</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;template</span><span class="si">{</span><span class="n">tid</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">db_path_T</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t0</span> <span class="o">==</span> <span class="s2">&quot;detection_time&quot;</span><span class="p">:</span>
        <span class="n">correction_time</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">reference_absolute_time</span> <span class="o">-</span> <span class="n">cfg</span><span class="o">.</span><span class="n">BUFFER_EXTRACTED_EVENTS_SEC</span>
    <span class="k">elif</span> <span class="n">t0</span> <span class="o">==</span> <span class="s2">&quot;origin_time&quot;</span><span class="p">:</span>
        <span class="n">correction_time</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;t0 should either be detection_time or origin_time&quot;</span><span class="p">)</span>
    <span class="c1"># ------------------------------</span>
    <span class="n">CC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_n_events</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">max_n_events</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_n_events</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">CC</span><span class="p">))</span>
        <span class="n">CC_thres</span> <span class="o">=</span> <span class="n">CC</span><span class="p">[</span><span class="o">-</span><span class="n">max_n_events</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">best_CC</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span>
            <span class="n">CC_thres</span> <span class="o">=</span> <span class="n">CC</span><span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">70</span><span class="p">:</span>
            <span class="n">CC_thres</span> <span class="o">=</span> <span class="n">CC</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mf">7.0</span> <span class="o">/</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">CC</span><span class="p">))]</span>  <span class="c1"># the best 30%</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
            <span class="n">CC_thres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span>  <span class="c1"># the best 50%</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">CC_thres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">CC</span><span class="p">,</span> <span class="mf">33.0</span><span class="p">)</span>  <span class="c1"># the best 66% detections</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">CC_thres</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">CC_thres</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="n">selection</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">correlation_coefficients</span> <span class="o">&gt;=</span> <span class="n">CC_thres</span>
    <span class="n">CCs</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">correlation_coefficients</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span>
    <span class="n">OTs</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">origin_times</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span>
    <span class="n">detection_waveforms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">give_time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ot</span> <span class="ow">in</span> <span class="n">OTs</span><span class="p">:</span>
        <span class="c1"># the OT in the h5 files correspond to the</span>
        <span class="c1"># beginning of the windows that were extracted</span>
        <span class="c1"># during the matched-filter search</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Extracting event from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">udt</span><span class="p">(</span><span class="n">ot</span><span class="p">)))</span>
        <span class="n">event</span> <span class="o">=</span> <span class="n">event_extraction</span><span class="o">.</span><span class="n">extract_event_parallel</span><span class="p">(</span>
            <span class="n">ot</span> <span class="o">+</span> <span class="n">correction_time</span><span class="p">,</span>
            <span class="n">net</span><span class="p">,</span>
            <span class="n">duration</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">multiplet_len</span><span class="p">,</span>
            <span class="n">offset_start</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">folder</span><span class="o">=</span><span class="s2">&quot;raw&quot;</span><span class="p">,</span>
            <span class="n">attach_response</span><span class="o">=</span><span class="n">preprocess_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;attach_response&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">integrate</span><span class="p">:</span>
            <span class="n">event</span><span class="o">.</span><span class="n">integrate</span><span class="p">()</span>
        <span class="n">filtered_ev</span> <span class="o">=</span> <span class="n">event_extraction</span><span class="o">.</span><span class="n">preprocess_event</span><span class="p">(</span>
            <span class="n">event</span><span class="p">,</span>
            <span class="n">freqmin</span><span class="o">=</span><span class="n">freqmin</span><span class="p">,</span>
            <span class="n">freqmax</span><span class="o">=</span><span class="n">freqmax</span><span class="p">,</span>
            <span class="n">target_SR</span><span class="o">=</span><span class="n">target_SR</span><span class="p">,</span>
            <span class="n">target_duration</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">multiplet_len</span><span class="p">,</span>
            <span class="o">**</span><span class="n">preprocess_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_ev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">detection_waveforms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_np_array</span><span class="p">(</span><span class="n">filtered_ev</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">detection_waveforms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">stations</span><span class="p">),</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">components</span><span class="p">),</span>
                        <span class="n">sec_to_samp</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">multiplet_len</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">target_SR</span><span class="p">),</span>
                    <span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
    <span class="n">detection_waveforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">detection_waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">norm_rms</span><span class="p">:</span>
        <span class="c1"># one normalization factor for each 3-comp seismogram</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">detection_waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">norm</span><span class="p">[</span><span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">detection_waveforms</span> <span class="o">/=</span> <span class="n">norm</span>
    <span class="n">n_detections</span> <span class="o">=</span> <span class="n">detection_waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">give_time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2"> s to retrieve the waveforms.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ordering</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># use the requested attribute to order the detections</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">ordering</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The catalog does not have the </span><span class="si">{</span><span class="n">ordering</span><span class="si">}</span><span class="s2"> attribute, &quot;</span>
                <span class="s2">&quot;return by chronological order.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">ordering</span><span class="p">)[</span><span class="n">selection</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">flip_order</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">detection_waveforms</span> <span class="o">=</span> <span class="n">detection_waveforms</span><span class="p">[</span><span class="n">order</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
            <span class="n">CCs</span> <span class="o">=</span> <span class="n">CCs</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">detection_waveforms</span><span class="p">,</span> <span class="n">CCs</span></div>



<div class="viewcode-block" id="SVDWF_multiplets">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.SVDWF_multiplets">[docs]</a>
<span class="k">def</span> <span class="nf">SVDWF_multiplets</span><span class="p">(</span>
    <span class="n">tid</span><span class="p">,</span>
    <span class="n">db_path</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">INPUT_PATH</span><span class="p">,</span>
    <span class="n">db_path_M</span><span class="o">=</span><span class="s2">&quot;matched_filter_1&quot;</span><span class="p">,</span>
    <span class="n">db_path_T</span><span class="o">=</span><span class="s2">&quot;template_db_1&quot;</span><span class="p">,</span>
    <span class="n">best</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">norm_rms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">max_singular_values</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">expl_var</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
    <span class="n">freqmin</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">MIN_FREQ_HZ</span><span class="p">,</span>
    <span class="n">freqmax</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">MAX_FREQ_HZ</span><span class="p">,</span>
    <span class="n">sampling_rate</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">SAMPLING_RATE_HZ</span><span class="p">,</span>
    <span class="n">wiener_filter_colsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">attach_raw_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">detection_waveforms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    tid: scalar integer,</span>
<span class="sd">        Template id.</span>
<span class="sd">    db_path: string, default to cfg.INPUT_PATH</span>
<span class="sd">        Root path of the database.</span>
<span class="sd">    db_path_M: string, default to &#39;matched_filter_1&#39;</span>
<span class="sd">        Name of the folder where matched-filtering results</span>
<span class="sd">        are stored.</span>
<span class="sd">    db_path_T: string, default to &#39;template_db_1&#39;</span>
<span class="sd">        Name of the folder where template files are stored.</span>
<span class="sd">    best: boolean, default to False</span>
<span class="sd">        If True, only use the detections with higher</span>
<span class="sd">        correlation coefficients.</span>
<span class="sd">    norm_rms: boolean, default to True</span>
<span class="sd">        If True, individual event are RMS-normalized</span>
<span class="sd">        before stacking.</span>
<span class="sd">    max_singular_values: scalar integer, default to 5</span>
<span class="sd">        Disregarding how many singular values are needed</span>
<span class="sd">        to reconstruct 100xexp_var% of the variance of</span>
<span class="sd">        the detection matrix, the number of singular values</span>
<span class="sd">        will not be larger than max_singular_values.</span>
<span class="sd">    max_freq: scalar float, default to cfg.MAX_FREQ_HZ</span>
<span class="sd">        The maximum frequency of the data, or maximum target</span>
<span class="sd">        frequency, is used to determined the size in the</span>
<span class="sd">        time axis of the Wiener filter.</span>
<span class="sd">    wiener_filter_colsize: scalar integer, default to None,</span>
<span class="sd">        Size of the wiener filter in the vertical direction</span>
<span class="sd">        (i.e. in the observation axis). If set to None,</span>
<span class="sd">        then it will be equal to the number of rows.</span>
<span class="sd">    attach_raw_data: boolean, default to False.</span>
<span class="sd">        If True, the data extracted during the matched-filter</span>
<span class="sd">        search are returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    S: obspy Stream,</span>
<span class="sd">        Return the SVDWF-processed detections traces in the</span>
<span class="sd">        format of an obspy Stream. Stacked traces can be</span>
<span class="sd">        found in the obspy Traces, and the filtered (and raw,</span>
<span class="sd">        if attach_raw_data is True) data matrix is returned as</span>
<span class="sd">        an attribute. See also all the useful metadata in</span>
<span class="sd">        the attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># -----------------------------------------------------------------------------------------------</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">Template</span><span class="p">(</span><span class="s2">&quot;template</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tid</span><span class="p">),</span> <span class="n">db_path_T</span><span class="p">,</span> <span class="n">db_path</span><span class="o">=</span><span class="n">db_path</span><span class="p">)</span>
    <span class="c1"># -----------------------------------------------------------------------------------------------</span>
    <span class="n">files_all</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">db_path</span><span class="p">,</span> <span class="n">db_path_M</span><span class="p">,</span> <span class="s2">&quot;*multiplets_*meta.h5&quot;</span><span class="p">))</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># ------------------------------</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">Stack</span><span class="p">(</span>
        <span class="n">T</span><span class="o">.</span><span class="n">network_stations</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">tid</span><span class="o">=</span><span class="n">tid</span>
    <span class="p">)</span>
    <span class="n">n_stations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">stations</span><span class="p">)</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">latitude</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">longitude</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">longitude</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">depth</span>
    <span class="c1"># ------------------------------</span>
    <span class="k">if</span> <span class="n">detection_waveforms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">detection_waveforms</span><span class="p">,</span> <span class="n">CCs</span> <span class="o">=</span> <span class="n">fetch_detection_waveforms</span><span class="p">(</span>
            <span class="n">tid</span><span class="p">,</span> <span class="n">db_path_T</span><span class="p">,</span> <span class="n">db_path_M</span><span class="p">,</span> <span class="n">best_CC</span><span class="o">=</span><span class="n">best</span><span class="p">,</span> <span class="n">norm_rms</span><span class="o">=</span><span class="n">norm_rms</span><span class="p">,</span> <span class="n">db_path</span><span class="o">=</span><span class="n">db_path</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># provided by the user</span>
        <span class="k">pass</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:d}</span><span class="s2"> events.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">detection_waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">detection_waveforms</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_stations</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_components</span><span class="p">):</span>
            <span class="n">filtered_data</span><span class="p">[:,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">SVDWF</span><span class="p">(</span>
                <span class="n">detection_waveforms</span><span class="p">[:,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:],</span>
                <span class="n">max_singular_values</span><span class="o">=</span><span class="n">max_singular_values</span><span class="p">,</span>
                <span class="n">expl_var</span><span class="o">=</span><span class="n">expl_var</span><span class="p">,</span>
                <span class="n">freqmin</span><span class="o">=</span><span class="n">freqmin</span><span class="p">,</span>
                <span class="n">freqmax</span><span class="o">=</span><span class="n">freqmax</span><span class="p">,</span>
                <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
                <span class="n">wiener_filter_colsize</span><span class="o">=</span><span class="n">wiener_filter_colsize</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">[:,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Problem with station </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{:d}</span><span class="s2">), component </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{:d}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">stations</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">s</span><span class="p">,</span> <span class="n">stack</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">c</span>
                    <span class="p">)</span>
                <span class="p">)</span>
    <span class="n">stacked_waveforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">stacked_waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">norm</span><span class="p">[</span><span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">stacked_waveforms</span> <span class="o">/=</span> <span class="n">norm</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">stacked_waveforms</span><span class="p">)</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">filtered_data</span>
    <span class="k">if</span> <span class="n">attach_raw_data</span><span class="p">:</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">raw_data</span> <span class="o">=</span> <span class="n">detection_waveforms</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">n_detections</span> <span class="o">=</span> <span class="n">detection_waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">correlation_coefficients</span> <span class="o">=</span> <span class="n">CCs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">correlation_coefficients</span> <span class="o">=</span> <span class="s2">&quot;N/A&quot;</span>
    <span class="k">return</span> <span class="n">stack</span></div>



<span class="c1"># ------------------------------------</span>
<span class="c1">#      hierarchical clustering</span>
<span class="c1"># ------------------------------------</span>


<div class="viewcode-block" id="extract_colors_from_tree">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.extract_colors_from_tree">[docs]</a>
<span class="k">def</span> <span class="nf">extract_colors_from_tree</span><span class="p">(</span><span class="n">dendogram</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">color_singleton</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Routine to build the map from cluster ids to dendogram colors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dendogram: dendogram from scipy.hierarchy.dendogram.</span>
<span class="sd">    labels: (n_samples) numpy array,</span>
<span class="sd">        Labels, or cluster ids, returned by</span>
<span class="sd">        scipy.hierarchy.fcluster. For each of the initial</span>
<span class="sd">        n_samples samples, this function returns its</span>
<span class="sd">        cluster membership. labels[i] = k, means that</span>
<span class="sd">        data point i belongs to cluster k.</span>
<span class="sd">    color_singleton: string,</span>
<span class="sd">        Color given to the singleton when calling</span>
<span class="sd">        scipy.hierarchy.dendogram.</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">    cluster_colors: dictionary,</span>
<span class="sd">        Map between cluster id and plotting color.</span>
<span class="sd">        cluster_colors[k] = &#39;C0&#39; means that cluster k</span>
<span class="sd">        is colored in &#39;C0&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">groupby</span>

    <span class="c1"># --------------------</span>
    <span class="n">list_summary</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">color</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">dendogram</span><span class="p">[</span><span class="s2">&quot;color_list&quot;</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="n">color_singleton</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
            <span class="n">elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
        <span class="n">list_summary</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">color</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)])</span>
    <span class="n">leaf_colors</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">leaf_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cluster_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">leaf_count</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dendogram</span><span class="p">[</span><span class="s2">&quot;leaves&quot;</span><span class="p">]):</span>
            <span class="k">break</span>
        <span class="n">ev_clusterid</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">dendogram</span><span class="p">[</span><span class="s2">&quot;leaves&quot;</span><span class="p">][</span><span class="n">leaf_count</span><span class="p">]]</span>
        <span class="n">ev_cluster_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">ev_clusterid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ev_cluster_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># next leaf is of color &quot;color_singleton&quot;</span>
            <span class="n">leaf_colors</span><span class="p">[</span><span class="n">dendogram</span><span class="p">[</span><span class="s2">&quot;leaves&quot;</span><span class="p">][</span><span class="n">leaf_count</span><span class="p">]]</span> <span class="o">=</span> <span class="n">color_singleton</span>
            <span class="n">leaf_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">list_summary</span><span class="p">[</span><span class="n">cluster_count</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_branches</span> <span class="o">=</span> <span class="n">list_summary</span><span class="p">[</span><span class="n">cluster_count</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">leaf_count</span><span class="p">,</span> <span class="n">leaf_count</span> <span class="o">+</span> <span class="n">n_branches</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">leaf_colors</span><span class="p">[</span><span class="n">dendogram</span><span class="p">[</span><span class="s2">&quot;leaves&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">color</span>
            <span class="n">leaf_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">cluster_count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># leaf_colors should match what is plotted on the dendogram</span>
    <span class="c1"># we are mostly interested in the color of each cluster</span>
    <span class="n">cluster_colors</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leaf_colors</span><span class="p">)):</span>
        <span class="n">ev_id</span> <span class="o">=</span> <span class="n">dendogram</span><span class="p">[</span><span class="s2">&quot;leaves&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">cl_id</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">ev_id</span><span class="p">]</span>
        <span class="n">cluster_colors</span><span class="p">[</span><span class="n">cl_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf_colors</span><span class="p">[</span><span class="n">ev_id</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">cluster_colors</span></div>



<div class="viewcode-block" id="find_template_clusters">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.find_template_clusters">[docs]</a>
<span class="k">def</span> <span class="nf">find_template_clusters</span><span class="p">(</span>
    <span class="n">TpGroup</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;single&quot;</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">,</span>
    <span class="n">criterion</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span>
    <span class="n">clustering_threshold</span><span class="o">=</span><span class="mf">0.33</span><span class="p">,</span>
    <span class="n">color_singleton</span><span class="o">=</span><span class="s2">&quot;dimgray&quot;</span><span class="p">,</span>
    <span class="n">ax_dendogram</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find non-overlapping groups of similar templates</span>
<span class="sd">    with the hierarchical clustering package from scipy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">squareform</span>
    <span class="kn">from</span> <span class="nn">scipy.cluster</span> <span class="kn">import</span> <span class="n">hierarchy</span>

    <span class="c1"># first, transform the CC matrix into a condensed matrix</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">TpGroup</span><span class="o">.</span><span class="n">intertp_cc</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">corr_dist</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">TpGroup</span><span class="o">.</span><span class="n">intertp_cc</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">corr_dist</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.0e-6</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Prob with FMF&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># avoid tiny negative values because of numerical imprecision</span>
        <span class="n">corr_dist</span><span class="p">[</span><span class="n">corr_dist</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1"># link the events</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">hierarchy</span><span class="o">.</span><span class="n">linkage</span><span class="p">(</span>
        <span class="n">corr_dist</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">optimal_ordering</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="c1"># get cluster labels</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">hierarchy</span><span class="o">.</span><span class="n">fcluster</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">clustering_threshold</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="n">criterion</span><span class="p">)</span>
    <span class="n">cluster_ids</span><span class="p">,</span> <span class="n">cluster_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax_dendogram</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># plot dendogram</span>
        <span class="n">dendogram</span> <span class="o">=</span> <span class="n">hierarchy</span><span class="o">.</span><span class="n">dendrogram</span><span class="p">(</span>
            <span class="n">Z</span><span class="p">,</span>
            <span class="n">count_sort</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">above_threshold_color</span><span class="o">=</span><span class="n">color_singleton</span><span class="p">,</span>
            <span class="n">color_threshold</span><span class="o">=</span><span class="n">clustering_threshold</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax_dendogram</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># get cluster colors from the dendogram</span>
        <span class="n">cluster_colors</span> <span class="o">=</span> <span class="n">extract_colors_from_tree</span><span class="p">(</span><span class="n">dendogram</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">color_singleton</span><span class="p">)</span>
        <span class="c1">## count all singleton clusters as one, for plotting purposes</span>
        <span class="c1"># n_clusters = np.sum(cluster_sizes &gt; 1)</span>
        <span class="c1"># if np.sum(cluster_sizes == 1) &gt; 0:</span>
        <span class="c1">#        n_clusters += 1</span>
        <span class="c1">#        sort_by_size = np.argsort(cluster_sizes)</span>
        <span class="k">return</span> <span class="n">labels</span><span class="p">,</span> <span class="n">cluster_ids</span><span class="p">,</span> <span class="n">cluster_sizes</span><span class="p">,</span> <span class="n">dendogram</span><span class="p">,</span> <span class="n">cluster_colors</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">labels</span><span class="p">,</span> <span class="n">cluster_ids</span><span class="p">,</span> <span class="n">cluster_sizes</span></div>



<span class="c1"># -------------------------------------------------</span>
<span class="c1">#           Convert and round times</span>
<span class="c1"># -------------------------------------------------</span>


<div class="viewcode-block" id="round_time">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.round_time">[docs]</a>
<span class="k">def</span> <span class="nf">round_time</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">SAMPLING_RATE_HZ</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    t: scalar float,</span>
<span class="sd">        Time, in seconds, to be rounded so that the number</span>
<span class="sd">        of meaningful decimals is consistent with the precision</span>
<span class="sd">        allowed by the sampling rate.</span>
<span class="sd">    sr: scalar float, default to cfg.SAMPLING_RATE_HZ,</span>
<span class="sd">        Sampling rate of the data. It is used to</span>
<span class="sd">        round the time.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    t: scalar float,</span>
<span class="sd">        Rounded time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert t to samples</span>
    <span class="n">t_samp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">sr</span><span class="p">)</span>
    <span class="c1"># get it back to seconds</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">t_samp</span><span class="p">)</span> <span class="o">/</span> <span class="n">sr</span>
    <span class="k">return</span> <span class="n">t</span></div>



<div class="viewcode-block" id="sec_to_samp">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.sec_to_samp">[docs]</a>
<span class="k">def</span> <span class="nf">sec_to_samp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">SAMPLING_RATE_HZ</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert seconds to samples taking into account rounding errors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># we add epsilon so that we fall onto the right</span>
    <span class="c1"># integer number even if there is a small precision</span>
    <span class="c1"># error in the floating point number</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">t_samp_float</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">sr</span><span class="p">)</span> <span class="o">+</span> <span class="n">epsilon</span>
    <span class="c1"># round and restore sign</span>
    <span class="n">t_samp_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">sign</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">t_samp_float</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">t_samp_int</span></div>



<div class="viewcode-block" id="time_range">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.time_range">[docs]</a>
<span class="k">def</span> <span class="nf">time_range</span><span class="p">(</span>
    <span class="n">start_time</span><span class="p">,</span>
    <span class="n">end_time</span><span class="p">,</span>
    <span class="n">dt_sec</span><span class="p">,</span>
    <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;ms&quot;</span><span class="p">,</span>
    <span class="n">unit_value</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ms&quot;</span><span class="p">:</span> <span class="mf">1.0e3</span><span class="p">,</span> <span class="s2">&quot;us&quot;</span><span class="p">:</span> <span class="mf">1.0e6</span><span class="p">,</span> <span class="s2">&quot;ns&quot;</span><span class="p">:</span> <span class="mf">1.0e9</span><span class="p">},</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute a range of datetime64.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    start_time: string or datetime</span>
<span class="sd">        Start of the time range.</span>
<span class="sd">    end_time: string or datetime</span>
<span class="sd">        End of the time range.</span>
<span class="sd">    dt_sec: scalar float</span>
<span class="sd">        Time step, in seconds, of the time range.</span>
<span class="sd">    unit: string, default to &#39;ms&#39;</span>
<span class="sd">        Unit in which dt_sec is converted in order to reach an integer number.</span>
<span class="sd">    unit_value: dictionary, optional</span>
<span class="sd">        Dictionary with the value of 1 second in different units.</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">    time_range: (n_samples,) numpy.ndarray of numpy.datetime64</span>
<span class="sd">        The time range computed from the input parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">dt_sec</span> <span class="o">*</span> <span class="n">unit_value</span><span class="p">[</span><span class="n">unit</span><span class="p">]),</span> <span class="n">unit</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span></div>



<span class="c1"># -------------------------------------------------</span>
<span class="c1">#                    Regression</span>
<span class="c1"># -------------------------------------------------</span>


<div class="viewcode-block" id="linear_regression">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.linear_regression">[docs]</a>
<span class="k">def</span> <span class="nf">linear_regression</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    cf. https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a: slope</span>
<span class="sd">    b: intercept</span>
<span class="sd">    r_val: correlation coefficient, usually</span>
<span class="sd">           people use the coefficient of determination</span>
<span class="sd">           R**2 = r_val**2 to measure the quality of</span>
<span class="sd">           the fit</span>
<span class="sd">    p_val: two-sided p-value for a hypothesis test whose null</span>
<span class="sd">           hypothesis is that the slope is zero</span>
<span class="sd">    std_err: standard error of the estimated slope</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">linregress</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r_val</span><span class="p">,</span> <span class="n">p_val</span><span class="p">,</span> <span class="n">std_err</span> <span class="o">=</span> <span class="n">linregress</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r_val</span><span class="p">,</span> <span class="n">p_val</span><span class="p">,</span> <span class="n">std_err</span></div>



<div class="viewcode-block" id="weighted_linear_regression">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.weighted_linear_regression">[docs]</a>
<span class="k">def</span> <span class="nf">weighted_linear_regression</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">W</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    X: (n,) numpy array or list</span>
<span class="sd">    Y: (n,) numpy array or list</span>
<span class="sd">    W: default to None, (n,) numpy array or list</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    best_slope: scalar float,</span>
<span class="sd">        Best slope from the least square formula</span>
<span class="sd">    best_intercept: scalar float,</span>
<span class="sd">        Best intercept from the least square formula</span>
<span class="sd">    std_err: scalar float,</span>
<span class="sd">        Error on the slope</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">W_sum</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">x_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="n">X</span><span class="p">)</span> <span class="o">/</span> <span class="n">W_sum</span>
    <span class="n">y_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="n">Y</span><span class="p">)</span> <span class="o">/</span> <span class="n">W_sum</span>
    <span class="n">x_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">x_mean</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">xy_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">x_mean</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Y</span> <span class="o">-</span> <span class="n">y_mean</span><span class="p">))</span>
    <span class="n">best_slope</span> <span class="o">=</span> <span class="n">xy_cov</span> <span class="o">/</span> <span class="n">x_var</span>
    <span class="n">best_intercept</span> <span class="o">=</span> <span class="n">y_mean</span> <span class="o">-</span> <span class="n">best_slope</span> <span class="o">*</span> <span class="n">x_mean</span>
    <span class="c1"># errors in best_slope and best_intercept</span>
    <span class="n">estimate</span> <span class="o">=</span> <span class="n">best_intercept</span> <span class="o">+</span> <span class="n">best_slope</span> <span class="o">*</span> <span class="n">X</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">estimate</span> <span class="o">-</span> <span class="n">Y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">s2_intercept</span> <span class="o">=</span> <span class="n">s2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">x_mean</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_var</span><span class="p">))</span>
    <span class="n">s2_slope</span> <span class="o">=</span> <span class="n">s2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_var</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">best_slope</span><span class="p">,</span> <span class="n">best_intercept</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s2_slope</span><span class="p">)</span></div>



<span class="c1"># -------------------------------------------------</span>
<span class="c1">#             Others</span>
<span class="c1"># -------------------------------------------------</span>

<div class="viewcode-block" id="cov_mat_intersection">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.cov_mat_intersection">[docs]</a>
<span class="k">def</span> <span class="nf">cov_mat_intersection</span><span class="p">(</span><span class="n">cov_mat</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute intersection between covariance matrix and plane.</span>

<span class="sd">    Note that we assume the following coordinate system:</span>
<span class="sd">    - X: westward</span>
<span class="sd">    - Y: southward</span>
<span class="sd">    - Z: upward</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cov_mat : numpy.ndarray</span>
<span class="sd">        The (3x3) covariance matrix returned by Event.relocate(method=&#39;NLLoc&#39;).</span>
<span class="sd">    axis1 : integer, optional</span>
<span class="sd">        Index of the first axis defining the intersecting plane.</span>
<span class="sd">    axis2 : integer, optional</span>
<span class="sd">        Index of the second axis defining the intersecting plane.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    max_unc : float</span>
<span class="sd">        Maximum uncertainty, in km, of the intersected covariance matrix.</span>
<span class="sd">    min_unc : float</span>
<span class="sd">        Minimum uncertainty, in km, of the intersected covariance matrix.</span>
<span class="sd">    az_max : float</span>
<span class="sd">        &quot;Azimuth&quot;, that is, angle from `axis2` of maximum uncertainty.</span>
<span class="sd">    az_min : float</span>
<span class="sd">        &quot;Azimuth&quot;, that is, angle from `axis2` of minimum uncertainty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># X: west, Y: south, Z: upward</span>
    <span class="n">s_68_3df</span> <span class="o">=</span> <span class="mf">3.52</span>
    <span class="n">s_68_2df</span> <span class="o">=</span> <span class="mf">2.28</span>
    <span class="c1"># eigendecomposition of restricted matrix</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">])</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">cov_mat</span><span class="p">[</span><span class="n">indexes</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">indexes</span><span class="p">])</span>
    <span class="n">semi_axis_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_68_2df</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">max_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">semi_axis_length</span><span class="p">)</span>
    <span class="n">min_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">semi_axis_length</span><span class="p">)</span>
    <span class="n">max_dir</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">w</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
    <span class="n">min_dir</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">w</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
    <span class="c1"># &quot;azimuth&quot; is angle between `axis2` (`max_dir[1]`) and ellipse&#39;s semi-axis</span>
    <span class="n">az_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">max_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_dir</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">az_min</span> <span class="o">=</span> <span class="p">(</span><span class="n">az_max</span> <span class="o">+</span> <span class="mf">90.</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.</span>
    <span class="k">return</span> <span class="n">max_unc</span><span class="p">,</span> <span class="n">min_unc</span><span class="p">,</span> <span class="n">az_max</span><span class="p">,</span> <span class="n">az_min</span></div>



<div class="viewcode-block" id="compute_distances">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.compute_distances">[docs]</a>
<span class="k">def</span> <span class="nf">compute_distances</span><span class="p">(</span>
    <span class="n">source_longitudes</span><span class="p">,</span>
    <span class="n">source_latitudes</span><span class="p">,</span>
    <span class="n">source_depths</span><span class="p">,</span>
    <span class="n">receiver_longitudes</span><span class="p">,</span>
    <span class="n">receiver_latitudes</span><span class="p">,</span>
    <span class="n">receiver_depths</span><span class="p">,</span>
    <span class="n">return_epicentral_distances</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fast distance computation between all source points and all receivers.</span>

<span class="sd">    This function uses `cartopy.geodesic.Geodesic` to compute pair-wise distances</span>
<span class="sd">    between source points and receivers. It computes both hypocentral distances</span>
<span class="sd">    and, if specified, epicentral distances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source_longitudes : numpy.ndarray or list</span>
<span class="sd">        Longitudes, in decimal degrees, of the source points.</span>
<span class="sd">    source_latitudes : numpy.ndarray or list</span>
<span class="sd">        Latitudes, in decimal degrees, of the source points.</span>
<span class="sd">    source_depths : numpy.ndarray or list</span>
<span class="sd">        Depths, in kilometers, of the source points.</span>
<span class="sd">    receiver_longitudes : numpy.ndarray or list</span>
<span class="sd">        Longitudes, in decimal degrees, of the receivers.</span>
<span class="sd">    receiver_latitudes : numpy.ndarray or list</span>
<span class="sd">        Latitudes, in decimal degrees, of the receivers.</span>
<span class="sd">    receiver_depths : numpy.ndarray or list</span>
<span class="sd">        Depths, in kilometers, of the receivers. Negative depths indicate</span>
<span class="sd">        receivers located at the surface.</span>
<span class="sd">    return_epicentral_distances : bool, optional</span>
<span class="sd">        Flag indicating whether to return epicentral distances in addition to</span>
<span class="sd">        hypocentral distances. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hypocentral_distances : numpy.ndarray</span>
<span class="sd">        Array of hypocentral distances between source points and receivers.</span>
<span class="sd">        The shape of the array is (n_sources, n_receivers).</span>
<span class="sd">    epicentral_distances : numpy.ndarray, optional</span>
<span class="sd">        Array of epicentral distances between source points and receivers.</span>
<span class="sd">        This array is returned only if `return_epicentral_distances` is True.</span>
<span class="sd">        The shape of the array is (n_sources, n_receivers).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">cartopy.geodesic</span> <span class="kn">import</span> <span class="n">Geodesic</span>

    <span class="c1"># convert types if necessary</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_longitudes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">source_longitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">source_longitudes</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_latitudes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">source_latitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">source_latitudes</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_depths</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">source_depths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">source_depths</span><span class="p">)</span>

    <span class="c1"># initialize distance array</span>
    <span class="n">hypocentral_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">source_latitudes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">receiver_latitudes</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
    <span class="p">)</span>
    <span class="n">epicentral_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">source_latitudes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">receiver_latitudes</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
    <span class="p">)</span>
    <span class="c1"># initialize the Geodesic instance</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">Geodesic</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">receiver_latitudes</span><span class="p">)):</span>
        <span class="n">epi_distances</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">receiver_longitudes</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">receiver_latitudes</span><span class="p">[</span><span class="n">s</span><span class="p">]]]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">source_longitudes</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">source_latitudes</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="n">epicentral_distances</span><span class="p">[:,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">epi_distances</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="n">hypocentral_distances</span><span class="p">[:,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">epicentral_distances</span><span class="p">[:,</span> <span class="n">s</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">source_depths</span> <span class="o">-</span> <span class="n">receiver_depths</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_epicentral_distances</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hypocentral_distances</span><span class="p">,</span> <span class="n">epicentral_distances</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hypocentral_distances</span></div>



<div class="viewcode-block" id="event_count">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.event_count">[docs]</a>
<span class="k">def</span> <span class="nf">event_count</span><span class="p">(</span>
    <span class="n">event_timings_str</span><span class="p">,</span>
    <span class="n">start_date</span><span class="p">,</span>
    <span class="n">end_date</span><span class="p">,</span>
    <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;1D&quot;</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">trim_start</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">trim_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;end&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    event_timings_str: list of array of str</span>
<span class="sd">        Timings of the events given as strings of characters.</span>
<span class="sd">    start_date: str</span>
<span class="sd">        Starting date of the event count time series.</span>
<span class="sd">    end_date: str</span>
<span class="sd">        End date of the event count time series.</span>
<span class="sd">    freq: str, default to &#39;1D&#39;</span>
<span class="sd">        Desired frequency of the event count time series.</span>
<span class="sd">        Default is one day.</span>
<span class="sd">    offset: float, default to 0.</span>
<span class="sd">        Fraction of the frequency used for defining</span>
<span class="sd">        the beginning of each bin. For example, offset=0.5</span>
<span class="sd">        with freq=&#39;1D&#39; will return daily event counts</span>
<span class="sd">        from noon to noon.</span>
<span class="sd">    mode: str, default to &#39;end&#39;</span>
<span class="sd">        Can be &#39;end&#39; or &#39;beginning&#39;. This string defines whether</span>
<span class="sd">        the seismicity counted between time 1 and time 2 is</span>
<span class="sd">        indexed at time 2 (&#39;end&#39;) or time 1 (&#39;beginning&#39;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    event_count: Pandas Series</span>
<span class="sd">        Pandas Series with temporal indexes defined</span>
<span class="sd">        by freq and base, and values given by the</span>
<span class="sd">        event count.</span>
<span class="sd">        To get a numpy array from this Pandas Series,</span>
<span class="sd">        use: event_count.values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

    <span class="n">start_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">start_date</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">))</span>
    <span class="n">end_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">end_date</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">))</span>
    <span class="n">offset_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">freq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">event_occurrence</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">event_timings_str</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">event_timings_str</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="s2">&quot;datetime64[ns]&quot;</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="c1"># trick to force a good match between initial indexes and new indexes</span>
    <span class="n">event_occurrence</span><span class="p">[</span><span class="n">start_date</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">event_occurrence</span><span class="p">[</span><span class="n">end_date</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;end&quot;</span><span class="p">:</span>
        <span class="c1"># note: we use mode=&#39;end&#39; so that the number of events</span>
        <span class="c1"># counted at time t is the event count between t-dt and t</span>
        <span class="c1"># this is consistent with the timing convention of pandas diff()</span>
        <span class="c1"># namely: diff(t) = x(t)-x(t-dt)</span>
        <span class="n">event_count</span> <span class="o">=</span> <span class="n">event_occurrence</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">Grouper</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset_str</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;beginning&quot;</span><span class="p">:</span>
        <span class="n">event_count</span> <span class="o">=</span> <span class="n">event_occurrence</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">Grouper</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset_str</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mode should be end or beginning&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">event_count</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">start_date</span><span class="p">):</span>
        <span class="n">event_count</span><span class="p">[</span><span class="n">event_count</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">freq</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">event_count</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">end_date</span><span class="p">):</span>
        <span class="n">event_count</span><span class="p">[</span><span class="n">event_count</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">freq</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">trim_start</span> <span class="ow">or</span> <span class="n">offset</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">event_count</span> <span class="o">=</span> <span class="n">event_count</span><span class="p">[</span><span class="n">event_count</span><span class="o">.</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">start_date</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">trim_end</span> <span class="ow">or</span> <span class="n">offset</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">stop_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">end_date</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stop_date</span> <span class="o">=</span> <span class="n">end_date</span>
        <span class="n">event_count</span> <span class="o">=</span> <span class="n">event_count</span><span class="p">[</span><span class="n">event_count</span><span class="o">.</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">stop_date</span><span class="p">]</span>
    <span class="c1"># force the manually added items to be well</span>
    <span class="c1"># located in time</span>
    <span class="n">event_count</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">event_count</span></div>



<div class="viewcode-block" id="get_np_array">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.get_np_array">[docs]</a>
<span class="k">def</span> <span class="nf">get_np_array</span><span class="p">(</span>
    <span class="n">stream</span><span class="p">,</span>
    <span class="n">stations</span><span class="p">,</span>
    <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
    <span class="n">priority</span><span class="o">=</span><span class="s2">&quot;HH&quot;</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">component_aliases</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]},</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fetch data from Obspy Stream and returns an ndarray.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    stream: Obspy Stream instance</span>
<span class="sd">        The Obspy Stream instance with the waveform time series.</span>
<span class="sd">    stations: list of strings</span>
<span class="sd">        Names of the stations to include in the output array. Define the order</span>
<span class="sd">        of the station axis.</span>
<span class="sd">    components: list of strings, default to [&#39;N&#39;,&#39;E&#39;,&#39;Z&#39;]</span>
<span class="sd">        Names of the components to include in the output array. Define the order</span>
<span class="sd">        of the component axis.</span>
<span class="sd">    component_aliases: dictionary, optional</span>
<span class="sd">        Sometimes, components might be named differently than N, E, Z. This</span>
<span class="sd">        dictionary tells the function which alternative component names can be</span>
<span class="sd">        associated with each &quot;canonical&quot; component. For example,</span>
<span class="sd">        `component_aliases[&#39;N&#39;] = [&#39;N&#39;, &#39;1&#39;]` means that the function will also</span>
<span class="sd">        check the &#39;1&#39; component in case the &#39;N&#39; component doesn&#39;t exist.</span>
<span class="sd">    priority: string, default to &#39;HH&#39;</span>
<span class="sd">        When a station has multiple instruments, this string tells which</span>
<span class="sd">        channel to use in priority.</span>
<span class="sd">    n_samples: scalar int, default to None</span>
<span class="sd">        Duration, in samples, of the output numpy.ndarray. Select the</span>
<span class="sd">        `n_samples` first samples of each trace. If None, take `n_samples` as</span>
<span class="sd">        the length of the first trace.</span>
<span class="sd">    verbose: boolean, default to True</span>
<span class="sd">        If True, print extra output in case the target data cannot be fetched.</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">    data: (n_stations, n_components, n_samples) numpy.ndarray</span>
<span class="sd">        The waveform time series formatted as an numpy.ndarray.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The input data stream is empty!&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">n_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">stream</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">size</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">),</span> <span class="n">n_samples</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">sta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stations</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">components</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">cp_alias</span> <span class="ow">in</span> <span class="n">component_aliases</span><span class="p">[</span><span class="n">cp</span><span class="p">]:</span>
                <span class="n">channel</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">sta</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">cp_alias</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># succesfully retrieved data</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># try selecting the preferred channel if it exists</span>
                    <span class="n">cha</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">channel</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">priority</span><span class="si">}{</span><span class="n">cp_alias</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># data[s, c, :] = channel.select(</span>
                    <span class="c1">#        channel=f&#39;{priority}{cp_alias}&#39;)[0].data[:n_samples]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="n">cha</span> <span class="o">=</span> <span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># data[s, c, :] = channel[0].data[:n_samples]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cha</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_samples</span><span class="p">:</span>
                    <span class="n">length_diff</span> <span class="o">=</span> <span class="n">n_samples</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">cha</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">cha</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">length_diff</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cha</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="n">n_samples</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">data</span></div>



<div class="viewcode-block" id="max_norm">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.max_norm">[docs]</a>
<span class="k">def</span> <span class="nf">max_norm</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="n">max_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">max_</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">X</span> <span class="o">/</span> <span class="n">max_</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">X</span></div>



<div class="viewcode-block" id="running_mad">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.running_mad">[docs]</a>
<span class="k">def</span> <span class="nf">running_mad</span><span class="p">(</span><span class="n">time_series</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">n_mad</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mf">0.75</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">median_abs_deviation</span> <span class="k">as</span> <span class="n">scimad</span>

    <span class="c1"># calculate n_windows given window</span>
    <span class="c1"># and overlap</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">*</span> <span class="n">window</span><span class="p">)</span>
    <span class="n">n_windows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">time_series</span><span class="p">)</span> <span class="o">-</span> <span class="n">window</span><span class="p">)</span> <span class="o">//</span> <span class="n">shift</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">mad_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_windows</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">med_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_windows</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_windows</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_windows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">shift</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time_series</span><span class="p">),</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">window</span><span class="p">)</span>
        <span class="n">sliding_window</span> <span class="o">=</span> <span class="n">time_series</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">]</span>
        <span class="c1"># non_zero = cnr_window != 0</span>
        <span class="c1"># if sum(non_zero) &lt; 3:</span>
        <span class="c1">#    # won&#39;t be possible to calculate median</span>
        <span class="c1">#    # and mad on that few samples</span>
        <span class="c1">#    continue</span>
        <span class="c1"># med_[i] = np.median(cnr_window[non_zero])</span>
        <span class="c1"># mad_[i] = scimad(cnr_window[non_zero])</span>
        <span class="n">med_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sliding_window</span><span class="p">)</span>
        <span class="n">mad_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scimad</span><span class="p">(</span><span class="n">sliding_window</span><span class="p">)</span>
        <span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="c1"># add boundary cases manually</span>
    <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">mad_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mad_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">med_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">med_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_series</span><span class="p">)</span>
    <span class="n">mad_</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mad_</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">med_</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">med_</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">running_stat</span> <span class="o">=</span> <span class="n">med_</span> <span class="o">+</span> <span class="n">n_mad</span> <span class="o">*</span> <span class="n">mad_</span>
    <span class="n">interpolator</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">running_stat</span><span class="p">,</span>
        <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;slinear&quot;</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="p">(</span><span class="n">running_stat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">running_stat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">full_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_series</span><span class="p">))</span>
    <span class="n">running_stat</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">full_time</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">running_stat</span></div>


<div class="viewcode-block" id="spectrogram">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.spectrogram">[docs]</a>
<span class="k">def</span> <span class="nf">spectrogram</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">window_duration_sec</span><span class="p">,</span>
        <span class="n">overlap</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">,</span>
        <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
        <span class="n">nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">boundary</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">padded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">scaling</span><span class="o">=</span><span class="s2">&quot;spectrum&quot;</span>
        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    window_duration_sec : float</span>
<span class="sd">        Duration of the sliding window, in seconds, of the</span>
<span class="sd">        short-time Fourier transform. This is later converted to</span>
<span class="sd">        samples to define the `nperseg` argument for `scipy.signal.stft`.</span>
<span class="sd">    overlap : float</span>
<span class="sd">        Ratio of overlap, from 0 to 1, between subsequent windows. This is</span>
<span class="sd">        later converted to samples to define the `noverlap` argument for</span>
<span class="sd">        `scipy.signal.stft`.</span>
<span class="sd">    detrend : bool, optional</span>
<span class="sd">        If False, no detrending is done. If it is a string or a function,</span>
<span class="sd">        detrending is done (see doc of `scipy.signal.stft`).</span>
<span class="sd">        Defaults to False.</span>
<span class="sd">    window : str or tuple or array-like, optional</span>
<span class="sd">        The string is the name of the taper window to apply to each segment.</span>
<span class="sd">        See the doc of `scipy.signal.stft` for more details.</span>
<span class="sd">    boundary : str or None, optional</span>
<span class="sd">        Define how the time series are extended at the boundaries. See the</span>
<span class="sd">        doc of `scipy.signal.stft` for more details. Defaults to None (only</span>
<span class="sd">        valid segments are used).</span>
<span class="sd">    padded : bool, optional</span>
<span class="sd">        If True, padding occurs after boundary extension. Defaults to False.</span>
<span class="sd">    scaling : str, optional</span>
<span class="sd">        Either &#39;spectrum&#39; or &#39;psd&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frequency : numpy.ndarray</span>
<span class="sd">        Frequencies, in Hertz, at which the spectra are estimated.</span>
<span class="sd">    time : numpy.ndarray</span>
<span class="sd">        Times, in seconds, of the sliding windows.</span>
<span class="sd">    spectrogram : numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">stft</span>

    <span class="n">stft_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">stft_params</span><span class="p">[</span><span class="s2">&quot;nperseg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_duration_sec</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">stft_params</span><span class="p">[</span><span class="s2">&quot;noverlap&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">overlap</span> <span class="o">*</span> <span class="n">stft_params</span><span class="p">[</span><span class="s2">&quot;nperseg&quot;</span><span class="p">])</span>
    <span class="n">stft_params</span><span class="p">[</span><span class="s2">&quot;detrend&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detrend</span>
    <span class="n">stft_params</span><span class="p">[</span><span class="s2">&quot;window&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">window</span>
    <span class="n">stft_params</span><span class="p">[</span><span class="s2">&quot;nfft&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nfft</span>
    <span class="n">stft_params</span><span class="p">[</span><span class="s2">&quot;boundary&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary</span>
    <span class="n">stft_params</span><span class="p">[</span><span class="s2">&quot;padded&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">padded</span>
    <span class="n">stft_params</span><span class="p">[</span><span class="s2">&quot;scaling&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaling</span>

    <span class="n">frequency</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="o">**</span><span class="n">stft_params</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span></div>


<div class="viewcode-block" id="two_point_epicentral_distance">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.two_point_epicentral_distance">[docs]</a>
<span class="k">def</span> <span class="nf">two_point_epicentral_distance</span><span class="p">(</span><span class="n">lon_1</span><span class="p">,</span> <span class="n">lat_1</span><span class="p">,</span> <span class="n">lon_2</span><span class="p">,</span> <span class="n">lat_2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the distance between two points.</span>


<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    lon_1: scalar, float</span>
<span class="sd">        Longitude of Point 1.</span>
<span class="sd">    lat_1: scalar, float</span>
<span class="sd">        Latitude of Point 1.</span>
<span class="sd">    lon_2: scalar, float</span>
<span class="sd">        Longitude of Point 2.</span>
<span class="sd">    lat_2: scalar, float</span>
<span class="sd">        Latitude of Point 2.</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">    dist: scalar, float</span>
<span class="sd">        Distance between Point 1 and Point 2 in kilometers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">obspy.geodetics.base</span> <span class="kn">import</span> <span class="n">calc_vincenty_inverse</span>

    <span class="n">dist</span><span class="p">,</span> <span class="n">az</span><span class="p">,</span> <span class="n">baz</span> <span class="o">=</span> <span class="n">calc_vincenty_inverse</span><span class="p">(</span><span class="n">lat_1</span><span class="p">,</span> <span class="n">lon_1</span><span class="p">,</span> <span class="n">lat_2</span><span class="p">,</span> <span class="n">lon_2</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">/=</span> <span class="mf">1000.0</span>  <span class="c1"># from m to km</span>
    <span class="k">return</span> <span class="n">dist</span></div>


<div class="viewcode-block" id="two_point_distance">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.two_point_distance">[docs]</a>
<span class="k">def</span> <span class="nf">two_point_distance</span><span class="p">(</span><span class="n">lon_1</span><span class="p">,</span> <span class="n">lat_1</span><span class="p">,</span> <span class="n">depth_1</span><span class="p">,</span> <span class="n">lon_2</span><span class="p">,</span> <span class="n">lat_2</span><span class="p">,</span> <span class="n">depth_2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the distance between two points.</span>


<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    lon_1: scalar, float</span>
<span class="sd">        Longitude of Point 1.</span>
<span class="sd">    lat_1: scalar, float</span>
<span class="sd">        Latitude of Point 1.</span>
<span class="sd">    depth_1: scalar, float</span>
<span class="sd">        Depth of Point 1 (in km).</span>
<span class="sd">    lon_2: scalar, float</span>
<span class="sd">        Longitude of Point 2.</span>
<span class="sd">    lat_2: scalar, float</span>
<span class="sd">        Latitude of Point 2.</span>
<span class="sd">    depth_2: scalar, float</span>
<span class="sd">        Depth of Point 2 (in km).</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">    dist: scalar, float</span>
<span class="sd">        Distance between Point 1 and Point 2 in kilometers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">obspy.geodetics.base</span> <span class="kn">import</span> <span class="n">calc_vincenty_inverse</span>

    <span class="n">dist</span><span class="p">,</span> <span class="n">az</span><span class="p">,</span> <span class="n">baz</span> <span class="o">=</span> <span class="n">calc_vincenty_inverse</span><span class="p">(</span><span class="n">lat_1</span><span class="p">,</span> <span class="n">lon_1</span><span class="p">,</span> <span class="n">lat_2</span><span class="p">,</span> <span class="n">lon_2</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">/=</span> <span class="mf">1000.0</span>  <span class="c1"># from m to km</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dist</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">depth_1</span> <span class="o">-</span> <span class="n">depth_2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dist</span></div>



<div class="viewcode-block" id="donefun">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.donefun">[docs]</a>
<span class="k">def</span> <span class="nf">donefun</span><span class="p">(</span><span class="n">french</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Super useful function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">french</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;ALL DONE!&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.25</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;HOP LÀ!&quot;</span>
        <span class="k">elif</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.50</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;VOILÀ!&quot;</span>
        <span class="k">elif</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.75</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;BIM!&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;STYLÉ!&quot;</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀</span>
<span class="s2">    ⠀⠀⠀⠀⠀⠀⢀⡤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡀⠀⠀⠀⠀⠀⠀</span>
<span class="s2">    ⠀⠀⠀⠀⠀⢀⡏⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⣀⠴⠋⠉⠉⡆⠀⠀⠀⠀⠀</span>
<span class="s2">    ⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠈⠉⠉⠙⠓⠚⠁⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀</span>
<span class="s2">    ⠀⠀⠀⠀⢀⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣄⠀⠀⠀⠀</span>
<span class="s2">    ⠀⠀⠀⠀⡞⠀⠀⠀⠀⠀⠶⠀⠀⠀⠀⠀⠀⠦⠀⠀⠀⠀⠀⠸⡆⠀⠀⠀</span>
<span class="s2">    ⢠⣤⣶⣾⣧⣤⣤⣀⡀⠀⠀⠀⠀⠈⠀⠀⠀⢀⡤⠴⠶⠤⢤⡀⣧⣀⣀⠀</span>
<span class="s2">    ⠻⠶⣾⠁⠀⠀⠀⠀⠙⣆⠀⠀⠀⠀⠀⠀⣰⠋⠀⠀⠀⠀⠀⢹⣿⣭⣽⠇</span>
<span class="s2">    ⠀⠀⠙⠤⠴⢤⡤⠤⠤⠋⠉⠉⠉⠉⠉⠉⠉⠳⠖⠦⠤⠶⠦⠞⠁⠀⠀⠀</span>
<span class="s2">                ⠀</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">⠀⠀⠀</span>
<span class="s2">    &quot;&quot;&quot;</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="write_lock_file">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.write_lock_file">[docs]</a>
<span class="k">def</span> <span class="nf">write_lock_file</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Lock file </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> already exists!&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">flush</span><span class="p">:</span>
        <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">fsync</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>



<div class="viewcode-block" id="read_write_waiting_list">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.read_write_waiting_list">[docs]</a>
<span class="k">def</span> <span class="nf">read_write_waiting_list</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">unit_wait_time</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read/write queue to avoid conflicts between jobs.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>

    <span class="n">path_no_ext</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">path_lock</span> <span class="o">=</span> <span class="n">path_no_ext</span> <span class="o">+</span> <span class="s2">&quot;_lock&quot;</span>
            <span class="n">path_wait</span> <span class="o">=</span> <span class="n">path_no_ext</span> <span class="o">+</span> <span class="s2">&quot;_waiting_list&quot;</span>
            <span class="n">sleep</span><span class="p">(</span><span class="n">unit_wait_time</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
            <span class="n">waiting_list_position</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">path_wait</span> <span class="o">+</span> <span class="s2">&quot;*&quot;</span><span class="p">))</span>
            <span class="n">waiting_list_ticket</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path_wait</span><span class="si">}{</span><span class="n">waiting_list_position</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># take place in waiting list by creating empty file</span>
                    <span class="n">write_lock_file</span><span class="p">(</span><span class="n">waiting_list_ticket</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                    <span class="c1"># several jobs trying to create the same ticket?</span>
                    <span class="c1"># randomness will solve the conflict</span>
                    <span class="n">waiting_list_position</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
                    <span class="n">waiting_list_ticket</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path_wait</span><span class="si">}{</span><span class="n">waiting_list_position</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">next_place_ticket</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path_wait</span><span class="si">}{</span><span class="n">waiting_list_position</span><span class="o">-</span><span class="mi">1</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="c1"># print(f&quot;1: Created {os.path.basename(waiting_list_ticket)}&quot;)</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># sleep(unit_wait_time * np.random.random())</span>
                <span class="k">if</span> <span class="n">waiting_list_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># is first in the waiting list!</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path_lock</span><span class="p">):</span>
                        <span class="c1"># first, create lock file</span>
                        <span class="n">write_lock_file</span><span class="p">(</span><span class="n">path_lock</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="c1"># print(f&quot;2: Created {os.path.basename(path_lock)}&quot;)</span>
                        <span class="c1"># then, free the waiting list position #0</span>
                        <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">waiting_list_ticket</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
                        <span class="c1"># print(f&quot;2: Deleted {os.path.basename(waiting_list_ticket)}&quot;)</span>
                        <span class="c1"># now the process can proceed with the reading or writing</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># wait a bit</span>
                        <span class="n">sleep</span><span class="p">(</span><span class="n">unit_wait_time</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">next_place_ticket</span><span class="p">):</span>
                    <span class="c1"># front place in the waiting list was freed!</span>
                    <span class="c1"># first, create new ticket at the new position</span>
                    <span class="n">write_lock_file</span><span class="p">(</span><span class="n">next_place_ticket</span><span class="p">)</span>
                    <span class="c1"># print(f&quot;3: Created {os.path.basename(next_place_ticket)}&quot;)</span>
                    <span class="c1"># then, free previous place in the waiting list</span>
                    <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">waiting_list_ticket</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
                    <span class="c1"># print(f&quot;3: Deleted {os.path.basename(waiting_list_ticket)}&quot;)</span>
                    <span class="c1"># update place in waiting list</span>
                    <span class="n">waiting_list_position</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="c1"># update ticket names</span>
                    <span class="n">waiting_list_ticket</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path_wait</span><span class="si">}{</span><span class="n">waiting_list_position</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">next_place_ticket</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path_wait</span><span class="si">}{</span><span class="n">waiting_list_position</span><span class="o">-</span><span class="mi">1</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="c1"># and wait for its turn</span>
                    <span class="n">sleep</span><span class="p">(</span><span class="n">unit_wait_time</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># waiting list didn&#39;t change, just wait</span>
                    <span class="n">sleep</span><span class="p">(</span><span class="n">unit_wait_time</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
            <span class="c1"># start reading/writing</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">func</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">path_lock</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
                <span class="k">raise</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">path_lock</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="k">break</span>
            <span class="c1"># done!</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;4: Concurent error, reset queue &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(last ticket was </span><span class="si">{</span><span class="n">waiting_list_ticket</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">waiting_list_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path_lock</span><span class="p">))</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">path_lock</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="k">continue</span></div>


<span class="c1"># =======================================================</span>
<span class="c1">#         routines for automatic picking</span>
<span class="c1"># =======================================================</span>


<div class="viewcode-block" id="normalize_batch">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.normalize_batch">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_batch</span><span class="p">(</span><span class="n">seismogram</span><span class="p">,</span> <span class="n">normalization_window_sample</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mf">0.50</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply Z-score normalization in running windows.</span>

<span class="sd">    Following Zhu et al. 2019, this function applied Z-score</span>
<span class="sd">    normalization in running windows with length `normalization_window_sample`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    seismogram : numpy.ndarray</span>
<span class="sd">        Three-component seismograms. `seismogram` has shape</span>
<span class="sd">        (num_traces, num_channels=3, num_time_samples).</span>
<span class="sd">    normalization_window_sample : integer, optional</span>
<span class="sd">        The window length, in samples, over which normalization is applied.</span>
<span class="sd">        Default is 3000 (like in Zhu et al. 2019).</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    normalized_seismogram : numpy.ndarray</span>
<span class="sd">        Normalized seismogram with same shape as `seismogram`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>

    <span class="c1">#shift = normalization_window_sample // 2</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">*</span> <span class="n">normalization_window_sample</span><span class="p">)</span>
    <span class="n">num_stations</span><span class="p">,</span> <span class="n">num_channels</span><span class="p">,</span> <span class="n">num_time_samples</span> <span class="o">=</span> <span class="n">seismogram</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># std in sliding windows</span>
    <span class="n">seismogram_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
        <span class="n">seismogram</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">shift</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span>
    <span class="p">)</span>
    <span class="c1"># time = np.arange(0, num_time_samples, shift, dtype=np.int32)</span>
    <span class="n">seismogram_view</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">sliding_window_view</span><span class="p">(</span>
        <span class="n">seismogram_pad</span><span class="p">,</span> <span class="n">normalization_window_sample</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
    <span class="p">)[:,</span> <span class="p">:,</span> <span class="p">::</span><span class="n">shift</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">sliding_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">seismogram_view</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sliding_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">seismogram_view</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># time at centers of sliding windows</span>
    <span class="n">num_sliding_windows</span> <span class="o">=</span> <span class="n">seismogram_view</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">num_time_samples</span> <span class="o">-</span> <span class="n">shift</span><span class="p">,</span> <span class="n">num_sliding_windows</span><span class="p">)</span>

    <span class="n">sliding_std</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sliding_mean</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sliding_std</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">sliding_mean</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">sliding_std</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sliding_mean</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sliding_std</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">sliding_mean</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">sliding_std</span><span class="p">[</span><span class="n">sliding_std</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># normalize data with sliding std and mean</span>
    <span class="n">t_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_time_samples</span><span class="p">)</span>
    <span class="n">std_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">t_interp</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">sld_std</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">sld_std</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">sld_std</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">sld_std</span> <span class="ow">in</span> <span class="n">sliding_std</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sliding_std</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="n">sliding_std</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_interp</span><span class="p">),)</span>
                    <span class="p">)</span>
    <span class="n">mean_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">t_interp</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">m_std</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">m_std</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">m_std</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">m_std</span> <span class="ow">in</span> <span class="n">sliding_mean</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sliding_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="n">sliding_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_interp</span><span class="p">),)</span>
                    <span class="p">)</span>

    <span class="n">seismogram</span> <span class="o">=</span> <span class="p">(</span><span class="n">seismogram</span> <span class="o">-</span> <span class="n">mean_interp</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_interp</span>

    <span class="k">return</span> <span class="n">seismogram</span></div>


<div class="viewcode-block" id="trigger_picks">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.trigger_picks">[docs]</a>
<span class="k">def</span> <span class="nf">trigger_picks</span><span class="p">(</span>
        <span class="n">probability</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">,</span>
        <span class="n">minimum_peak_distance_samp</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">1.</span> <span class="o">*</span> <span class="n">cfg</span><span class="o">.</span><span class="n">SAMPLING_RATE_HZ</span><span class="p">)</span>
        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    probability : 1D array_like</span>
<span class="sd">    threshold : float</span>
<span class="sd">    minimum_peak_distance_samp : integer</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    probability_at_peak : 1D array_like</span>
<span class="sd">    peak_indexes : 1D array_like</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">peak_indexes</span> <span class="o">=</span> <span class="n">_detect_peaks</span><span class="p">(</span>
            <span class="n">probability</span><span class="p">,</span> <span class="n">mph</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">mpd</span><span class="o">=</span><span class="n">minimum_peak_distance_samp</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">probability</span><span class="p">[</span><span class="n">peak_indexes</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">peak_indexes</span><span class="p">)</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="get_picks">
<a class="viewcode-back" href="../../usage/api/utils.html#BPMF.utils.get_picks">[docs]</a>
<span class="k">def</span> <span class="nf">get_picks</span><span class="p">(</span>
        <span class="n">picks</span><span class="p">,</span>
        <span class="n">buffer_length</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">cfg</span><span class="o">.</span><span class="n">SAMPLING_RATE_HZ</span><span class="p">),</span>
        <span class="n">prior_knowledge</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">search_win_samp</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">4.</span> <span class="o">*</span> <span class="n">cfg</span><span class="o">.</span><span class="n">SAMPLING_RATE_HZ</span><span class="p">)</span>
        <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Select a single P- and S-pick on each 3-comp seismogram.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    picks: dictionary</span>
<span class="sd">        Dictionary returned by `automatic_picking`.</span>
<span class="sd">    buffer_length: scalar int, optional</span>
<span class="sd">        Picks that are before this buffer length, in samples, are discarded.</span>
<span class="sd">    prior_knowledge: pandas.DataFrame, optional</span>
<span class="sd">        If given, picks that are closer to the a priori pick</span>
<span class="sd">        (for example, given by a preliminary location) will be given</span>
<span class="sd">        a larger weight and will be more likely to be selected. In practice,</span>
<span class="sd">        pick probabilities are multiplied by gaussian weights and the highest</span>
<span class="sd">        modified pick probability is selected.</span>
<span class="sd">    search_win_samp: scalar int, optional</span>
<span class="sd">        Standard deviation, in samples, used in the gaussian weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">prior_knowledge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">prior_knowledge</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">prior_P</span> <span class="o">=</span> <span class="n">prior_knowledge</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">st</span><span class="p">,</span> <span class="s2">&quot;P&quot;</span><span class="p">]</span>
            <span class="n">prior_S</span> <span class="o">=</span> <span class="n">prior_knowledge</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">st</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prior_P</span><span class="p">,</span> <span class="n">prior_S</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="c1">#for n in range(len(picks[&quot;P_picks&quot;][st])):</span>
        <span class="c1"># ----------------</span>
        <span class="c1"># remove picks from the buffer length</span>
        <span class="n">valid_P_picks</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">buffer_length</span><span class="p">)</span>
        <span class="n">valid_S_picks</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">buffer_length</span><span class="p">)</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">][</span><span class="n">valid_P_picks</span><span class="p">]</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">][</span><span class="n">valid_S_picks</span><span class="p">]</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">][</span><span class="n">valid_P_picks</span><span class="p">]</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">][</span><span class="n">valid_S_picks</span><span class="p">]</span>
        <span class="n">search_S_pick</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">search_P_pick</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># if no valid S pick: fill in with nan</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">search_S_pick</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># if no valid P pick: fill in with nan</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">search_P_pick</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">search_S_pick</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prior_S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># take only the highest probability trigger</span>
                <span class="n">best_S_trigger</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># use a priori picks</span>
                <span class="n">tapered_S_probas</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span>
                        <span class="o">*</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                            <span class="o">-</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">-</span> <span class="n">prior_S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">search_win_samp</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                <span class="n">best_S_trigger</span> <span class="o">=</span> <span class="n">tapered_S_probas</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
                <span class="c1">## don&#39;t keep if too far from a priori</span>
                <span class="c1">#if abs(picks[&quot;S_picks&quot;][st][best_S_trigger] - prior_S) &gt; 4 * search_win_samp:</span>
                <span class="c1">#    best_S_trigger = np.nan</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_S_trigger</span><span class="p">):</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">][</span><span class="n">best_S_trigger</span><span class="p">]</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">][</span><span class="n">best_S_trigger</span><span class="p">]</span>
            <span class="c1"># update P picks: keep only those that are before the best S pick</span>
            <span class="k">if</span> <span class="n">search_P_pick</span><span class="p">:</span>
                <span class="n">valid_P_picks</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">][</span><span class="n">valid_P_picks</span><span class="p">]</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">][</span><span class="n">valid_P_picks</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># if no valid P pick: fill in with nan</span>
                    <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">search_P_pick</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">search_P_pick</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prior_P</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># take only the highest probability trigger</span>
                <span class="n">best_P_trigger</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># use a priori picks</span>
                <span class="n">tapered_P_probas</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span>
                        <span class="o">*</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                            <span class="o">-</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">-</span> <span class="n">prior_P</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">search_win_samp</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                <span class="n">best_P_trigger</span> <span class="o">=</span> <span class="n">tapered_P_probas</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
                <span class="c1">## don&#39;t keep if too far from a priori</span>
                <span class="c1">#if abs(picks[&quot;P_picks&quot;][st][best_P_trigger] - prior_P) &gt; 4 * search_win_samp:</span>
                <span class="c1">#    best_P_trigger = np.nan</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">best_P_trigger</span><span class="p">):</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">][</span><span class="n">best_P_trigger</span><span class="p">]</span>
                <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">][</span><span class="n">best_P_trigger</span><span class="p">]</span>
        <span class="c1"># convert picks to float to allow NaNs</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]))</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_picks&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]))</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;P_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]))</span>
        <span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">picks</span><span class="p">[</span><span class="s2">&quot;S_proba&quot;</span><span class="p">][</span><span class="n">st</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">picks</span></div>


<span class="k">def</span> <span class="nf">_detect_peaks</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">mph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mpd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">edge</span><span class="o">=</span><span class="s2">&quot;rising&quot;</span><span class="p">,</span>
    <span class="n">kpsh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">valley</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Detect peaks in data based on their amplitude and other features.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1D array_like</span>
<span class="sd">        data.</span>
<span class="sd">    mph : {None, number}, optional (default = None)</span>
<span class="sd">        detect peaks that are greater than minimum peak height.</span>
<span class="sd">    mpd : positive integer, optional (default = 1)</span>
<span class="sd">        detect peaks that are at least separated by minimum peak distance (in</span>
<span class="sd">        number of data).</span>
<span class="sd">    threshold : positive number, optional (default = 0)</span>
<span class="sd">        detect peaks (valleys) that are greater (smaller) than `threshold`</span>
<span class="sd">        in relation to their immediate neighbors.</span>
<span class="sd">    edge : {None, &#39;rising&#39;, &#39;falling&#39;, &#39;both&#39;}, optional (default = &#39;rising&#39;)</span>
<span class="sd">        for a flat peak, keep only the rising edge (&#39;rising&#39;), only the</span>
<span class="sd">        falling edge (&#39;falling&#39;), both edges (&#39;both&#39;), or don&#39;t detect a</span>
<span class="sd">        flat peak (None).</span>
<span class="sd">    kpsh : bool, optional (default = False)</span>
<span class="sd">        keep peaks with same height even if they are closer than `mpd`.</span>
<span class="sd">    valley : bool, optional (default = False)</span>
<span class="sd">        if True (1), detect valleys (local minima) instead of peaks.</span>
<span class="sd">    show : bool, optional (default = False)</span>
<span class="sd">        if True (1), plot data in matplotlib figure.</span>
<span class="sd">    ax : a matplotlib.axes.Axes instance, optional (default = None).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ind : 1D array_like</span>
<span class="sd">        indeces of the peaks in `x`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The detection of valleys instead of peaks is performed internally by simply</span>
<span class="sd">    negating the data: `ind_valleys = detect_peaks(-x)`</span>

<span class="sd">    The function can handle NaN&#39;s</span>

<span class="sd">    See this IPython Notebook [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1]:http://nbviewer.ipython.org/github/demotu/BMC/blob/master/</span>
<span class="sd">        notebooks/DetectPeaks.ipynb</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from detect_peaks import detect_peaks</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.randn(100)</span>
<span class="sd">    &gt;&gt;&gt; x[60:81] = np.nan</span>
<span class="sd">    &gt;&gt;&gt; # detect all peaks and plot data</span>
<span class="sd">    &gt;&gt;&gt; ind = detect_peaks(x, show=True)</span>
<span class="sd">    &gt;&gt;&gt; print(ind)</span>

<span class="sd">    &gt;&gt;&gt; x = np.sin(2*np.pi*5*np.linspace(0, 1, 200)) + np.random.randn(200)/5</span>
<span class="sd">    &gt;&gt;&gt; # set minimum peak height = 0 and minimum peak distance = 20</span>
<span class="sd">    &gt;&gt;&gt; detect_peaks(x, mph=0, mpd=20, show=True)</span>

<span class="sd">    &gt;&gt;&gt; x = [0, 1, 0, 2, 0, 3, 0, 2, 0, 1, 0]</span>
<span class="sd">    &gt;&gt;&gt; # set minimum peak distance = 2</span>
<span class="sd">    &gt;&gt;&gt; detect_peaks(x, mpd=2, show=True)</span>

<span class="sd">    &gt;&gt;&gt; x = np.sin(2*np.pi*5*np.linspace(0, 1, 200)) + np.random.randn(200)/5</span>
<span class="sd">    &gt;&gt;&gt; # detection of valleys instead of peaks</span>
<span class="sd">    &gt;&gt;&gt; detect_peaks(x, mph=0, mpd=20, valley=True, show=True)</span>

<span class="sd">    &gt;&gt;&gt; x = [0, 1, 1, 0, 1, 1, 0]</span>
<span class="sd">    &gt;&gt;&gt; # detect both edges</span>
<span class="sd">    &gt;&gt;&gt; detect_peaks(x, edge=&#39;both&#39;, show=True)</span>

<span class="sd">    &gt;&gt;&gt; x = [-2, 1, -2, 2, 1, 1, 3, 0]</span>
<span class="sd">    &gt;&gt;&gt; # set threshold = 2</span>
<span class="sd">    &gt;&gt;&gt; detect_peaks(x, threshold = 2, show=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">valley</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
    <span class="c1"># find indices of all peaks</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># handle NaN&#39;s</span>
    <span class="n">indnan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">indnan</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">x</span><span class="p">[</span><span class="n">indnan</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">dx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dx</span><span class="p">))[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">ine</span><span class="p">,</span> <span class="n">ire</span><span class="p">,</span> <span class="n">ife</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[],</span> <span class="p">[],</span> <span class="p">[]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">edge</span><span class="p">:</span>
        <span class="n">ine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">dx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;rising&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">]:</span>
            <span class="n">ire</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">dx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;falling&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">]:</span>
            <span class="n">ife</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">dx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ine</span><span class="p">,</span> <span class="n">ire</span><span class="p">,</span> <span class="n">ife</span><span class="p">)))</span>
    <span class="c1"># handle NaN&#39;s</span>
    <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">indnan</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="c1"># NaN&#39;s and values close to NaN&#39;s cannot be peaks</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span>
                <span class="n">ind</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">indnan</span><span class="p">,</span> <span class="n">indnan</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">indnan</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))),</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="c1"># first and last values of x cannot be peaks</span>
    <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">ind</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># remove peaks &lt; minimum peak height</span>
    <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">mph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">mph</span><span class="p">]</span>
    <span class="c1"># remove peaks - neighbors &lt; threshold</span>
    <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dx</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># detect small peaks closer than minimum peak distance</span>
    <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">mpd</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">])][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># sort ind by peak height</span>
        <span class="n">idel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ind</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ind</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">idel</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="c1"># keep peaks with the same height if kpsh is True</span>
                <span class="n">idel</span> <span class="o">=</span> <span class="n">idel</span> <span class="o">|</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&gt;=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">mpd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">mpd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">if</span> <span class="n">kpsh</span> <span class="k">else</span> <span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">idel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Keep current peak</span>
        <span class="c1"># remove the small peaks and sort back the indices by their occurrence</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="o">~</span><span class="n">idel</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">indnan</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">indnan</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">valley</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
        <span class="n">_plot_peaks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mph</span><span class="p">,</span> <span class="n">mpd</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">valley</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ind</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Eric Beauce, William B. Frank.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>